{
  "source": "doc/api/all.markdown",
  "miscs": [
    {
      "textRaw": "About this Documentation",
      "name": "About this Documentation",
      "type": "misc",
      "desc": "<p>The goal of this documentation is to comprehensively explain the Node.js\nAPI, both from a reference as well as a conceptual point of view.  Each\nsection describes a built-in module or high-level concept.\n\n</p>\n<p>Where appropriate, property types, method arguments, and the arguments\nprovided to event handlers are detailed in a list underneath the topic\nheading.\n\n</p>\n<p>Every <code>.html</code> document has a corresponding <code>.json</code> document presenting\nthe same information in a structured manner.  This feature is\nexperimental, and added for the benefit of IDEs and other utilities that\nwish to do programmatic things with the documentation.\n\n</p>\n<p>Every <code>.html</code> and <code>.json</code> file is generated based on the corresponding\n<code>.markdown</code> file in the <code>doc/api/</code> folder in node&apos;s source tree.  The\ndocumentation is generated using the <code>tools/doc/generate.js</code> program.\nThe HTML template is located at <code>doc/template.html</code>.\n\n</p>\n",
      "miscs": [
        {
          "textRaw": "Stability Index",
          "name": "Stability Index",
          "type": "misc",
          "desc": "<p>Throughout the documentation, you will see indications of a section&apos;s\nstability.  The Node.js API is still somewhat changing, and as it\nmatures, certain parts are more reliable than others.  Some are so\nproven, and so relied upon, that they are unlikely to ever change at\nall.  Others are brand new and experimental, or known to be hazardous\nand in the process of being redesigned.\n\n</p>\n<p>The notices look like this:\n\n</p>\n<pre><code>Stability: 1 Experimental</code></pre>\n<p>The stability indices are as follows:\n\n</p>\n<ul>\n<li><strong>0 - Deprecated</strong>  This feature is known to be problematic, and changes are\nplanned.  Do not rely on it.  Use of the feature may cause warnings.  Backwards\ncompatibility should not be expected.</li>\n</ul>\n<ul>\n<li><strong>1 - Experimental</strong>  This feature was introduced recently, and may change\nor be removed in future versions.  Please try it out and provide feedback.\nIf it addresses a use-case that is important to you, tell the node core team.</li>\n</ul>\n<ul>\n<li><strong>2 - Unstable</strong>  The API is in the process of settling, but has not yet had\nsufficient real-world testing to be considered stable. Backwards-compatibility\nwill be maintained if reasonable.</li>\n</ul>\n<ul>\n<li><strong>3 - Stable</strong>  The API has proven satisfactory, but cleanup in the underlying\ncode may cause minor changes.  Backwards-compatibility is guaranteed.</li>\n</ul>\n<ul>\n<li><strong>4 - API Frozen</strong>  This API has been tested extensively in production and is\nunlikely to ever have to change.</li>\n</ul>\n<ul>\n<li><strong>5 - Locked</strong>  Unless serious bugs are found, this code will not ever\nchange.  Please do not suggest changes in this area; they will be refused.</li>\n</ul>\n"
        },
        {
          "textRaw": "JSON Output",
          "name": "json_output",
          "stability": 1,
          "stabilityText": "Experimental",
          "desc": "<p>Every HTML file in the markdown has a corresponding JSON file with the\nsame data.\n\n</p>\n<p>This feature is new as of node v0.6.12.  It is experimental.\n\n</p>\n",
          "type": "misc",
          "displayName": "JSON Output"
        }
      ]
    },
    {
      "textRaw": "Sinopsis",
      "name": "Sinopsis",
      "type": "misc",
      "desc": "<p>Un ejemplo de un <a href=\"http.html\">servidor web</a> escrito en Node que responde con &apos;Hola\nmundo&apos;:\n\n</p>\n<pre><code>var http = require(&apos;http&apos;);\n\nhttp.createServer(function (request, response) {\n  response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});\n  response.end(&apos;Hola mundo\\n&apos;);\n}).listen(8124);\n\nconsole.log(&apos;Servidor ejecutándose en http://127.0.0.1:8124/&apos;);</code></pre>\n<p>Para ejecutar el servidor, copie el código en un fichero llamado <code>example.js</code> y ejecútelo\ncon el programa node\n\n</p>\n<pre><code>&gt; node example.js\nServidor ejecutándose en http://127.0.0.1:8124/</code></pre>\n<p>Todos los ejemplos en está documentación son ejecutados de manera similar.\n</p>\n"
    },
    {
      "textRaw": "Objetos Globales",
      "name": "Objetos Globales",
      "type": "misc",
      "desc": "<p>Estos objectos estan disponibles en todos los módulos. Algunos de estos\nobjetos no están en el ámbito global pero si a nivel módulo - Tómelo en cuenta.\n\n</p>\n",
      "globals": [
        {
          "textRaw": "global",
          "name": "global",
          "type": "global",
          "desc": "<p>En los navegadores, el ambito del nivel superior es el ambito global. Esto significa\nque en los navegadores si tu estas en el ambito global <code>var something</code> definirá una variable.\nEn Node esto es diferente. El ambito del nivel superior no es el ambito global; \n<code>var something</code> dentro de un módulo de node será local para este módulo.\n\n</p>\n",
          "globals": [
            {
              "textRaw": "process",
              "name": "process",
              "type": "global",
              "desc": "<p>El objeto process. Véase la sección <a href=\"process.html#process\">objeto process</a>.\n\n</p>\n"
            },
            {
              "textRaw": "console",
              "name": "console",
              "type": "global",
              "desc": "<p>Usado para la salida de pantalla de stdout y stderr. Véase la sección <a href=\"stdio.html\">stdio</a>\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: Buffer",
          "type": "global",
          "name": "Buffer",
          "desc": "<p>Used to handle binary data. See the <a href=\"buffer.html\">buffer section</a>.\n\n</p>\n"
        },
        {
          "textRaw": "clearInterval(t)",
          "type": "global",
          "name": "clearInterval",
          "desc": "<p>The timer functions are global variables. See the <a href=\"timers.html\">timers</a> section.\n</p>\n"
        },
        {
          "textRaw": "console",
          "name": "console",
          "stability": 4,
          "stabilityText": "API Frozen",
          "type": "global",
          "desc": "<p>For printing to stdout and stderr.  Similar to the console object functions\nprovided by most web browsers, here the output is sent to stdout or stderr.\n\n\n</p>\n",
          "methods": [
            {
              "textRaw": "console.log()",
              "type": "method",
              "name": "log",
              "desc": "<p>Prints to stdout with newline. This function can take multiple arguments in a\n<code>printf()</code>-like way. Example:\n\n</p>\n<pre><code>console.log(&apos;count: %d&apos;, count);</code></pre>\n<p>If formatting elements are not found in the first string then <code>util.inspect</code>\nis used on each argument.\nSee <a href=\"util.html#util.format\">util.format()</a> for more information.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "console.info()",
              "type": "method",
              "name": "info",
              "desc": "<p>Same as <code>console.log</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "console.warn()",
              "type": "method",
              "name": "warn",
              "desc": "<p>Same as <code>console.log</code> but prints to stderr.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                },
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "console.error()",
              "type": "method",
              "name": "error",
              "desc": "<p>Same as <code>console.log</code> but prints to stderr.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "console.dir(obj)",
              "type": "method",
              "name": "dir",
              "desc": "<p>Uses <code>util.inspect</code> on <code>obj</code> and prints resulting string to stderr.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.time(label)",
              "type": "method",
              "name": "time",
              "desc": "<p>Mark a time.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "label"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.timeEnd(label)",
              "type": "method",
              "name": "timeEnd",
              "desc": "<p>Finish timer, record output. Example\n\n</p>\n<pre><code>console.time(&apos;100-elements&apos;);\nfor (var i = 0; i &lt; 100; i++) {\n  ;\n}\nconsole.timeEnd(&apos;100-elements&apos;);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "label"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.trace()",
              "type": "method",
              "name": "trace",
              "desc": "<p>Print a stack trace to stderr of the current position.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "console.assert()",
              "type": "method",
              "name": "assert",
              "desc": "<p>Same as <code>assert.ok()</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "vars": [
        {
          "textRaw": "require()",
          "type": "var",
          "name": "require",
          "desc": "<p>Para requerir módulos. Véase la sección <a href=\"modules.html#modules\">Módules</a>.\n<code>require</code> no es global sino más bien local para cada módulo.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "require.resolve()",
              "type": "method",
              "name": "resolve",
              "desc": "<p>Usa el mecanismo interno de <code>require()</code> para buscar la localización de un módulo,\npero en lugar de cargar el módulo, solo devuelve el nombre del fichero que lo contine.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "`cache` {Object} ",
              "name": "cache",
              "desc": "<p>Modules are cached in this object when they are required. By deleting a key\nvalue from this object, the next <code>require</code> will reload the module.\n\n</p>\n"
            }
          ],
          "vars": [
            {
              "textRaw": "__filename",
              "name": "__filename",
              "type": "var",
              "desc": "<p>El nombre del fichero que contiene al script que esta siendo ejecutado. \nEste esta definido como ruta absoluta, y no es necesariamente el mismo nombre\ndel fichero pasado como argumento en la linea de comando. El valor dentro\ndel módulo es la ruta al mismo.\n\n</p>\n<p>Ejemplo: Ejecutando <code>node example.js</code> desde <code>/User/mjr</code>\n\n</p>\n<pre><code>console.log(__filename);\n// /Users/mjr/example.js</code></pre>\n<p><code>__filename</code> isn&apos;t actually a global but rather local to each module.\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "__dirname",
          "name": "__dirname",
          "type": "var",
          "desc": "<p>El nombre del directorio del script que esta siendo ejecutado.\n\n</p>\n<p>Ejemplo:Ejecutando <code>node example.js</code> desde <code>/User/mjr</code>\n\n</p>\n<pre><code>console.log(__dirname);\n// /Users/mjr</code></pre>\n<p><code>__dirname</code> isn&apos;t actually a global but rather local to each module.\n\n\n</p>\n"
        },
        {
          "textRaw": "module",
          "name": "module",
          "type": "var",
          "desc": "<p>Una referencia al actual módulo. En particular \n<code>module.exports</code> es igual al objeto <code>exports</code>.\n<code>module</code> isn&apos;t actually a global but rather local to each module.\n\n</p>\n<p>Véase <a href=\"modules.html\">la documentación del sistema de módulos</a> para más\ninformación.\n\n</p>\n"
        },
        {
          "textRaw": "exports",
          "name": "exports",
          "type": "var",
          "desc": "<p>An object which is shared between all instances of the current module and\nmade accessible through <code>require()</code>.\n<code>exports</code> is the same as the <code>module.exports</code> object.\n<code>exports</code> isn&apos;t actually a global but rather local to each module.\n\n</p>\n<p>See the <a href=\"modules.html\">module system documentation</a> for more\ninformation.\n\n</p>\n<p>See the <a href=\"modules.html\">module section</a> for more information.\n\n</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "setInterval(cb, ms)",
          "type": "method",
          "name": "setInterval",
          "desc": "<p>The timer functions are global variables. See the <a href=\"timers.html\">timers</a> section.\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "cb"
                },
                {
                  "name": "ms"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "textRaw": "Depurador",
      "name": "Depurador",
      "stability": 3,
      "stabilityText": "Stable",
      "type": "misc",
      "desc": "<p>V8 viene con el complemento depurador (debugger), el cual puede ser accedido desde fuera \ndel proceso vía el <a href=\"http://code.google.com/p/v8/wiki/DebuggerProtocol\">protocolo TCP</a>.\nNode posee un cliente incorporado para el depurador. Para usarlo, inicie Node con el argumento\n<code>debug</code>; y aparecerá:\n\n</p>\n<pre><code>% node debug myscript.js\n&lt; debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\ndebug&gt;</code></pre>\n<p>El cliente depurador de Node no soporta toda una gama de comandos, pero\npara cosas sencillas y tareas de inspección es posible su uso. Al poner la declaración <code>debugger;</code>\nen el código fuente del script, permitirá un punto de interrupción.\n\n</p>\n<p>Por ejemplo, supongamos que <code>myscript.js</code> era así:\n\n</p>\n<pre><code>// myscript.js\nx = 5;\nsetTimeout(function () {\n  debugger;\n  console.log(&quot;mundo&quot;);\n}, 1000);\nconsole.log(&quot;hola&quot;);</code></pre>\n<p>Entonces una vez que el depurador se ejecute, se generará un break en la línea 4.\n\n</p>\n<pre><code>% node debug myscript.js\n&lt; debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\ndebug&gt; cont\n&lt; hello\nbreak in /home/indutny/Code/git/indutny/myscript.js:3\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\n  4   console.log(&quot;world&quot;);\n  5 }, 1000);\ndebug&gt; next\nbreak in /home/indutny/Code/git/indutny/myscript.js:4\n  2 setTimeout(function () {\n  3   debugger;\n  4   console.log(&quot;world&quot;);\n  5 }, 1000);\n  6 console.log(&quot;hello&quot;);\ndebug&gt; repl\nPress Ctrl + C to leave debug repl\n&gt; x\n5\n&gt; 2+2\n4\ndebug&gt; next\n&lt; world\nbreak in /home/indutny/Code/git/indutny/myscript.js:5\n  3   debugger;\n  4   console.log(&quot;world&quot;);\n  5 }, 1000);\n  6 console.log(&quot;hello&quot;);\n  7\ndebug&gt; quit\n%</code></pre>\n<p>El comando <code>repl</code> te permite evaluar el código remotamente. El comando <code>next</code> \ncontinúa la siguiente línea. Hay otros comandos disponibles y algunos más por venir de\ntipo ayuda. Escriba <code>help</code> para ver otros comandos.\n\n</p>\n",
      "miscs": [
        {
          "textRaw": "Watchers",
          "name": "watchers",
          "desc": "<p>You can watch expression and variable values while debugging your code.\nOn every breakpoint each expression from the watchers list will be evaluated\nin the current context and displayed just before the breakpoint&apos;s source code\nlisting.\n\n</p>\n<p>To start watching an expression, type <code>watch(&quot;my_expression&quot;)</code>. <code>watchers</code>\nprints the active watchers. To remove a watcher, type\n<code>unwatch(&quot;my_expression&quot;)</code>.\n\n</p>\n",
          "type": "misc",
          "displayName": "Watchers"
        },
        {
          "textRaw": "Commands reference",
          "name": "commands_reference",
          "modules": [
            {
              "textRaw": "Execution control",
              "name": "Execution control",
              "type": "module",
              "displayName": "Various"
            },
            {
              "textRaw": "Various",
              "name": "various",
              "type": "module",
              "displayName": "Various"
            }
          ],
          "type": "misc",
          "displayName": "Commands reference"
        },
        {
          "textRaw": "Uso avanzado",
          "name": "uso_avanzado",
          "desc": "<p>El depurador V8 puede ser habilitado y accedido ya sea al iniciar Node con el \ncomando <code>--debug</code> o al señalar un proceso en Node existente \ncon <code>SIGUSR1</code>.\n</p>\n",
          "type": "misc",
          "displayName": "Uso avanzado"
        }
      ]
    }
  ],
  "globals": [
    {
      "textRaw": "global",
      "name": "global",
      "type": "global",
      "desc": "<p>En los navegadores, el ambito del nivel superior es el ambito global. Esto significa\nque en los navegadores si tu estas en el ambito global <code>var something</code> definirá una variable.\nEn Node esto es diferente. El ambito del nivel superior no es el ambito global; \n<code>var something</code> dentro de un módulo de node será local para este módulo.\n\n</p>\n",
      "globals": [
        {
          "textRaw": "process",
          "name": "process",
          "type": "global",
          "desc": "<p>El objeto process. Véase la sección <a href=\"process.html#process\">objeto process</a>.\n\n</p>\n"
        },
        {
          "textRaw": "console",
          "name": "console",
          "type": "global",
          "desc": "<p>Usado para la salida de pantalla de stdout y stderr. Véase la sección <a href=\"stdio.html\">stdio</a>\n\n</p>\n"
        }
      ]
    },
    {
      "textRaw": "Class: Buffer",
      "type": "global",
      "name": "Buffer",
      "desc": "<p>Used to handle binary data. See the <a href=\"buffer.html\">buffer section</a>.\n\n</p>\n"
    },
    {
      "textRaw": "clearInterval(t)",
      "type": "global",
      "name": "clearInterval",
      "desc": "<p>The timer functions are global variables. See the <a href=\"timers.html\">timers</a> section.\n</p>\n"
    },
    {
      "textRaw": "console",
      "name": "console",
      "stability": 4,
      "stabilityText": "API Frozen",
      "type": "global",
      "desc": "<p>For printing to stdout and stderr.  Similar to the console object functions\nprovided by most web browsers, here the output is sent to stdout or stderr.\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "console.log()",
          "type": "method",
          "name": "log",
          "desc": "<p>Prints to stdout with newline. This function can take multiple arguments in a\n<code>printf()</code>-like way. Example:\n\n</p>\n<pre><code>console.log(&apos;count: %d&apos;, count);</code></pre>\n<p>If formatting elements are not found in the first string then <code>util.inspect</code>\nis used on each argument.\nSee <a href=\"util.html#util.format\">util.format()</a> for more information.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.info()",
          "type": "method",
          "name": "info",
          "desc": "<p>Same as <code>console.log</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.warn()",
          "type": "method",
          "name": "warn",
          "desc": "<p>Same as <code>console.log</code> but prints to stderr.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            },
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.error()",
          "type": "method",
          "name": "error",
          "desc": "<p>Same as <code>console.log</code> but prints to stderr.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.dir(obj)",
          "type": "method",
          "name": "dir",
          "desc": "<p>Uses <code>util.inspect</code> on <code>obj</code> and prints resulting string to stderr.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "obj"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.time(label)",
          "type": "method",
          "name": "time",
          "desc": "<p>Mark a time.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "label"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.timeEnd(label)",
          "type": "method",
          "name": "timeEnd",
          "desc": "<p>Finish timer, record output. Example\n\n</p>\n<pre><code>console.time(&apos;100-elements&apos;);\nfor (var i = 0; i &lt; 100; i++) {\n  ;\n}\nconsole.timeEnd(&apos;100-elements&apos;);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "label"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.trace()",
          "type": "method",
          "name": "trace",
          "desc": "<p>Print a stack trace to stderr of the current position.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.assert()",
          "type": "method",
          "name": "assert",
          "desc": "<p>Same as <code>assert.ok()</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ]
    }
  ],
  "vars": [
    {
      "textRaw": "require()",
      "type": "var",
      "name": "require",
      "desc": "<p>Para requerir módulos. Véase la sección <a href=\"modules.html#modules\">Módules</a>.\n<code>require</code> no es global sino más bien local para cada módulo.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "require.resolve()",
          "type": "method",
          "name": "resolve",
          "desc": "<p>Usa el mecanismo interno de <code>require()</code> para buscar la localización de un módulo,\npero en lugar de cargar el módulo, solo devuelve el nombre del fichero que lo contine.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`cache` {Object} ",
          "name": "cache",
          "desc": "<p>Modules are cached in this object when they are required. By deleting a key\nvalue from this object, the next <code>require</code> will reload the module.\n\n</p>\n"
        }
      ],
      "vars": [
        {
          "textRaw": "__filename",
          "name": "__filename",
          "type": "var",
          "desc": "<p>El nombre del fichero que contiene al script que esta siendo ejecutado. \nEste esta definido como ruta absoluta, y no es necesariamente el mismo nombre\ndel fichero pasado como argumento en la linea de comando. El valor dentro\ndel módulo es la ruta al mismo.\n\n</p>\n<p>Ejemplo: Ejecutando <code>node example.js</code> desde <code>/User/mjr</code>\n\n</p>\n<pre><code>console.log(__filename);\n// /Users/mjr/example.js</code></pre>\n<p><code>__filename</code> isn&apos;t actually a global but rather local to each module.\n\n</p>\n"
        }
      ]
    },
    {
      "textRaw": "__dirname",
      "name": "__dirname",
      "type": "var",
      "desc": "<p>El nombre del directorio del script que esta siendo ejecutado.\n\n</p>\n<p>Ejemplo:Ejecutando <code>node example.js</code> desde <code>/User/mjr</code>\n\n</p>\n<pre><code>console.log(__dirname);\n// /Users/mjr</code></pre>\n<p><code>__dirname</code> isn&apos;t actually a global but rather local to each module.\n\n\n</p>\n"
    },
    {
      "textRaw": "module",
      "name": "module",
      "type": "var",
      "desc": "<p>Una referencia al actual módulo. En particular \n<code>module.exports</code> es igual al objeto <code>exports</code>.\n<code>module</code> isn&apos;t actually a global but rather local to each module.\n\n</p>\n<p>Véase <a href=\"modules.html\">la documentación del sistema de módulos</a> para más\ninformación.\n\n</p>\n"
    },
    {
      "textRaw": "exports",
      "name": "exports",
      "type": "var",
      "desc": "<p>An object which is shared between all instances of the current module and\nmade accessible through <code>require()</code>.\n<code>exports</code> is the same as the <code>module.exports</code> object.\n<code>exports</code> isn&apos;t actually a global but rather local to each module.\n\n</p>\n<p>See the <a href=\"modules.html\">module system documentation</a> for more\ninformation.\n\n</p>\n<p>See the <a href=\"modules.html\">module section</a> for more information.\n\n</p>\n"
    }
  ],
  "methods": [
    {
      "textRaw": "setInterval(cb, ms)",
      "type": "method",
      "name": "setInterval",
      "desc": "<p>The timer functions are global variables. See the <a href=\"timers.html\">timers</a> section.\n</p>\n",
      "signatures": [
        {
          "params": [
            {
              "name": "cb"
            },
            {
              "name": "ms"
            }
          ]
        }
      ]
    }
  ],
  "modules": [
    {
      "textRaw": "Timer",
      "name": "timer",
      "methods": [
        {
          "textRaw": "setTimeout(callback, delay, [arg], [...])",
          "type": "method",
          "name": "setTimeout",
          "desc": "<p>Para programar la ejecución de <code>callback</code> después de <code>delay</code> milisegundos. Devuelve un <code>timeoutId</code> para un posible uso con <code>clearTimeout()</code>. Opcionalmente, tu puedes también pasar argumentos al callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearTimeout(timeoutId)",
          "type": "method",
          "name": "clearTimeout",
          "desc": "<p>Evita la ejecución de un callback por uno de sus disparadores.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "timeoutId"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "setInterval(callback, delay, [arg], [...])",
          "type": "method",
          "name": "setInterval",
          "desc": "<p>Para programar la repetición repetitiva de un <code>callback</code> cada <code>delay</code> milisegundos. Devuelve un <code>intervalId</code> para un posible uso con <code>clearInterval()</code>. Opcionalmente, tu puedes también pasar argumentos al callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearInterval(intervalId)",
          "type": "method",
          "name": "clearInterval",
          "desc": "<p>Evita la ejecución de un callback por uno de sus disparadores.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "intervalId"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Timer"
    },
    {
      "textRaw": "Módulos",
      "name": "módulos",
      "desc": "<p>Node posee un secillo sistema de carga.  En Node, los ficheros y módulos son de\ncorrespondencia biunívoca.  A modo de ejemplo, <code>foo.js</code> carga el módulo\n<code>circle.js</code> en el mismo directorio.\n\n</p>\n<p>El contenido de <code>foo.js</code>:\n\n</p>\n<pre><code>var circle = require(&apos;./circle.js&apos;);\nconsole.log( &apos;El área de un círculo con radio 4 es &apos;\n           + circle.area(4));</code></pre>\n<p>El contenido de <code>circle.js</code>:\n\n</p>\n<pre><code>var PI = Math.PI;\n\nexports.area = function (r) {\n  return PI * r * r;\n};\n\nexports.circumference = function (r) {\n  return 2 * PI * r;\n};</code></pre>\n<p>El módulo <code>circle.js</code> ha exportado las functiones <code>area()</code> y\n<code>circumference()</code>.  Para exportar a un objeto, debe añadir el objeto especial\n<code>exports</code>.\n\n\n</p>\n<p>Las variables locales del módulo serán privadas. En este ejemplo la variable <code>PI</code> es\nprivada en <code>circle.js</code>.\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Módulos básicos",
          "name": "módulos_básicos",
          "desc": "<p>Node posee varios módulos compilados en binario.  Estos módulos son\ndescritos con más detalle en las siguientes secciones del documento.\n\n</p>\n<p>Los módulos básicos son definidos en el código fuente de node en la carpeta <code>lib/</code>.\n\n</p>\n<p>Los módulos básicos tienen la preferencia de cargarse primero si su indentificador es\npasado desde <code>require()</code>. Por ejemplo, <code>require(&apos;http&apos;)</code> siempre\ndevolverá lo construido en el módulo HTTP, incluso si hay un fichero con ese nombre.\n\n</p>\n",
          "type": "module",
          "displayName": "Módulos básicos"
        },
        {
          "textRaw": "Módulo File",
          "name": "módulo_file",
          "desc": "<p>Si el nombre exacto del fichero no es encontrado, entonces node intentará cargar \nel nombre del fichero seguido de la extensión <code>.js</code>, y a continuación con <code>.node</code>.\n\n</p>\n<p>Los ficheros <code>.js</code> son interpretados como ficheros de texto en JavaScript, y los ficheros <code>.node</code>\nson interpretados como extensiones de módulos compilados cargados con <code>dlopen</code>.\n\n</p>\n<p>Un módulo con el prefijo <code>&apos;/&apos;</code> indica la ruta absoluta al fichero.  Por\nejemplo, <code>require(&apos;/home/marco/foo.js&apos;)</code> cargará el fichero en\n<code>/home/marco/foo.js</code>.\n\n</p>\n<p>Un módulo con el prefijo <code>&apos;./&apos;</code> es relativo al fichero llamado con <code>require()</code>.\nEs decir, <code>circle.js</code> debe estar en el mismo directorio que <code>foo.js</code> para que \n<code>require(&apos;./circle&apos;)</code> lo encuentre.\n\n</p>\n<p>Si se omite el uso de &apos;/&apos; o &apos;./&apos; en el fichero, el módulo puede ser un\n&quot;módulo básico&quot; o se cargará desde la carpeta <code>node_modules</code>.\n\n\n</p>\n",
          "type": "module",
          "displayName": "Módulo File"
        },
        {
          "textRaw": "Cargando desde la carpeta `node_modules`",
          "name": "cargando_desde_la_carpeta_`node_modules`",
          "desc": "<p>Si el identificador del módulo pasa a <code>require()</code> no es un módulo nativo,\ny no comienza con <code>&apos;/&apos;</code>, <code>&apos;../&apos;</code>, o <code>&apos;./&apos;</code>, entonces node inicia en el \ndirectorio principal del módulo actual, y añade <code>/node_modules</code>, e\nintenta cargar el módulo desde esa ubicación.\n\n</p>\n<p>Si no se encuentra, entonces se dirige al directorio principal, y así \nsucesivamente, hasta que el módulo es encontrado, hasta en la raíz del árbol es\nencontrado.\n\n</p>\n<p>Por ejemplo, si el fichero en <code>&apos;/home/ry/projects/foo.js&apos;</code> es llamado como\n<code>require(&apos;bar.js&apos;)</code>, entonces node buscaría en las siguientes ubicaciones, en\neste orden:\n\n</p>\n<ul>\n<li><code>/home/ry/projects/node_modules/bar.js</code></li>\n<li><code>/home/ry/node_modules/bar.js</code></li>\n<li><code>/home/node_modules/bar.js</code></li>\n<li><code>/node_modules/bar.js</code></li>\n</ul>\n<p>Esto permite que los programas encuentren sus dependencias, de modo que no\nentren en conflicto.\n\n\n</p>\n",
          "modules": [
            {
              "textRaw": "Optimización de proceso de búsqueda en `node_modules`",
              "name": "optimización_de_proceso_de_búsqueda_en_`node_modules`",
              "desc": "<p>Cuando existen muchos niveles de dependencias anidadas, es posible que los\nárboles de directorios tomen bastante tiempo. Las siguientes optimizaciones se\nrealizan para este proceso.\n\n</p>\n<p>Primero, <code>/node_modules</code> no debe ser anexado a una carpeta ya que termina en\n<code>/node_modules</code>.\n\n</p>\n<p>Segundo, si el fichero es llamado con  <code>require()</code> ya esta en la jerarquía de\n<code>node_modules</code>, entonces el nivel superior de la carpeta <code>node_modules</code> es tratada como\nla raíz del árbol de búsqueda.\n\n</p>\n<p>For example, if the file at\n<code>&apos;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&apos;</code>\ncalled <code>require(&apos;asdf.js&apos;)</code>, then node would search the following\nlocations:\n\n</p>\n<p>Por ejemplo, si el fichero en\n<code>&apos;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&apos;</code>\nllama como <code>require(&apos;asdf.js&apos;)</code>, entonces node buscaría en las siguientes\nubicaciones:\n\n</p>\n<ul>\n<li><code>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/asdf.js</code></li>\n<li><code>/home/ry/projects/foo/node_modules/bar/node_modules/asdf.js</code></li>\n<li><code>/home/ry/projects/foo/node_modules/asdf.js</code></li>\n</ul>\n",
              "type": "module",
              "displayName": "Optimización de proceso de búsqueda en `node_modules`"
            }
          ],
          "type": "module",
          "displayName": "Cargando desde la carpeta `node_modules`"
        },
        {
          "textRaw": "Carpetas como módulos",
          "name": "carpetas_como_módulos",
          "desc": "<p>Es conveniente organizar los programas y librerías en los mismos directorios,\ny proporcionar un único punto de entrar a la biblioteca.\nExiste tres formas en donde una carpeta pueda usar <code>require()</code> como\nun argumento.\n\n</p>\n<p>Lo primero es crear el fichero <code>package.json</code>en la raíz de la carpeta,\nque especifique el módulo <code>main</code>. Un ejemplo de package.json podría verse\ncomo esto:\n\n\n</p>\n<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,\n  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>\n<p>Si fuera una carpeta en <code>./some-library</code>, entonces\n<code>require(&apos;./some-library&apos;)</code> trataría de cargar\n<code>./some-library/lib/some-library.js</code>.\n\n</p>\n<p>Este es el mayor grado de conciencia de Node con el fichero package.json .\n\n</p>\n<p>Si no hay ningún fichero package.json presente en el directorio, entonces node\nintentará cargar el fichero <code>index.js</code> o <code>index.node</code> de ese directorio.\nPor ejemplo, si no hay ninguín fichero package.json en el ejemplo anterior,\nentonces <code>require(&apos;./some-library&apos;)</code> intentará cargar:\n\n</p>\n<ul>\n<li><code>./some-library/index.js</code></li>\n<li><code>./some-library/index.node</code></li>\n</ul>\n",
          "type": "module",
          "displayName": "Carpetas como módulos"
        },
        {
          "textRaw": "Almacenamiento en la caché",
          "name": "almacenamiento_en_la_caché",
          "desc": "<p>Los módulos se alamacenan en la caché después que fueron cargados por primera vez.\nEsto significa (entre otras cosas) que todas las llamadas a <code>require(&apos;foo&apos;)</code> devuelve\nel mismo ojecto exacto, si se resolvería en el mismo fichero\n\n</p>\n",
          "type": "module",
          "displayName": "Almacenamiento en la caché"
        },
        {
          "textRaw": "Todos juntos...",
          "name": "todos_juntos...",
          "desc": "<p>Para obtener el nombre exacto del fichero que se cargará cuando se llame con <code>require()</code>, use\nla función <code>require.resolve()</code>.\n\n</p>\n<p>Uniendo todo lo anterior, aquí se muestra un algoritmo de alto nievel\nen pseudocódigo de lo que haría require.resolve :\n\n</p>\n<pre><code>require(X)\n1. Si X es módulo básico,\n   a. devolver el módulo básico\n   b. STOP\n2. Si X inicia con con `./` or `/`,\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n3. LOAD_NODE_MODULES(X, dirname(Y))\n4. THROW &quot;not found&quot;\n\nLOAD_AS_FILE(X)\n1. Si X es un fichero, cargar X como texto JavaScript.  STOP\n2. Si X.js es un fichero, cargar X.js como texto JavaScript.  STOP\n3. Si X.node es un fichero, cargar X.node como extensión binaria.  STOP\n\nLOAD_AS_DIRECTORY(X)\n1. Si X/package.json es un fichero,\n   a. Parsear X/package.json, y buscar el campo &quot;main&quot;.\n   b. let M = X + (json main field)\n   c. LOAD_AS_FILE(M)\n2. LOAD_AS_FILE(X/index)\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let ROOT = index es una instancia de &quot;node_modules&quot; en PARTS, o 0\n3. let I = count of PARTS - 1\n4. let DIRS = []\n5. while I &gt; ROOT,\n   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE\n   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)\n   b. DIRS = DIRS + DIR\n6. return DIRS</code></pre>\n",
          "type": "module",
          "displayName": "Todos juntos..."
        },
        {
          "textRaw": "Addenda: Consejos para administrar paquetes",
          "name": "addenda:_consejos_para_administrar_paquetes",
          "desc": "<p>La semántica de Node en la función <code>require()</code> fue diseñada para ser lo \nsuficientemente general para soportar una serie de esctructuras de directorios.\nLos paquetes de programas como <code>dpkg</code>, <code>rpm</code>, y <code>npm</code> se esperan que sean construidos \ncomo paquetes nativos desde los módulos de Node sin modificaciones.\n\n</p>\n<p>A continuación sugerimos una estructura en la que puede trabajar:\n\n</p>\n<p>Supongamos que se desea tener en \n<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> se mantenga el contenido de una\nversión específica de un paquete.\n\n</p>\n<p>Los paquetes pueden depender uno del otro. Con el fin de instalar el paquete <code>foo</code>, \npuede que tenga que instalar una versión específica del paquete <code>bar</code>.  El paquete\n <code>bar</code> puede tener dependencias, y en algunos casos, estas dependencias, incluso pueden \nentrar en conflicto o crear ciclos.\n\n</p>\n<p>Desde la búsqueda con Node de la <code>ruta</code> de cualquier módulo cargado (es decir,\nresueltos los enlaces simbólicos), y luego de buscar sus dependencias en la\ncarpeta <code>node_modules</code> como se describió anteriormente, esta situación es muy simple de \nresolver con la siguiente arquitectura:\n\n</p>\n<ul>\n<li><code>/usr/lib/node/foo/1.2.3/</code> - Contenido del paquete <code>foo</code>, versión 1.2.3.</li>\n<li><code>/usr/lib/node/bar/4.3.2/</code> - Contenido del paquete <code>bar</code> que es\ndependencia de <code>foo</code>.</li>\n<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Enlace simbólico a\n<code>/usr/lib/node/bar/4.3.2/</code>.</li>\n<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Enlaces simbólicos a los paquetes\nque <code>bar</code> depende.</li>\n</ul>\n<p>Por lo tanto, incluso si se encuentra, o si hay problemas de dependencias,\ncada módulo será capza de obtener una versión de su dependencia para ser\nutilizada.\n\n</p>\n<p>Cuando el código en el paquete <code>foo</code> utiliza <code>require(&apos;bar&apos;)</code>, se obtendrá la\nversión al enlace simbólico en <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.\nLuego, cuando el código del paquete <code>bar</code> llame a <code>require(&apos;quux&apos;)</code>, obtendrá\nla versión simbólica en <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.\n\n</p>\n<p>Además, para hacer el proceso de búsqueda del módulo aún más óptima, en lugar\nde poner los paquetes directamente en <code>/usr/lib/node</code>, se puede poner estos en\n<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Entonces node no se molestará en\nbuscar por dependencias no encontradas en <code>/usr/node_modules</code> o <code>/node_modules</code>.\n\n</p>\n<p>A fin de que los módulos disponibles para node en REPL, puedan ser útiles,\nañade también la carpeta <code>/usr/lib/node_modules</code> a la variable de entorno <code>$NODE_PATH</code>.\nDesde el módulo de búsquedas usando la carpeta <code>node_modules</code> donde todo es\nrelativo, y basado en la ruta real de los ficheros llamados por <code>require()</code>, \nlos paquetes pueden ser llamado desde cualquier lugar.\n\n</p>\n",
          "type": "module",
          "displayName": "Addenda: Consejos para administrar paquetes"
        }
      ],
      "properties": [
        {
          "textRaw": "Cargar desde las carpetas de `require.paths`",
          "name": "paths`",
          "desc": "<p>En node, <code>require.paths</code> es un array de strings que representa las rutas de\nacceso a los módulos cuando estos no tienen el prefijo <code>&apos;/&apos;</code>, <code>&apos;./&apos;</code>, o\n<code>&apos;../&apos;</code>.  Por ejemplo, si establece require.paths como:\n\n</p>\n<pre><code>[ &apos;/home/micheil/.node_modules&apos;,\n  &apos;/usr/local/lib/node_modules&apos; ]</code></pre>\n<p>A continuación se llama a <code>require(&apos;bar/baz.js&apos;)</code> y buscará en las siguientes\nubicaciones:\n\n</p>\n<ul>\n<li>1: <code>&apos;/home/micheil/.node_modules/bar/baz.js&apos;</code></li>\n<li>2: <code>&apos;/usr/local/lib/node_modules/bar/baz.js&apos;</code></li>\n</ul>\n<p>El array en <code>require.paths</code> puede ser transformado en tiempo de ejecución para modificar\neste comportamiento.\n\n</p>\n<p>Se establece inicialmente la variable de entorno <code>NODE_PATH</code>, que contiene \nuna lista delimitada por dos puntos de rutas exactas.  En el anterior ejemplo,\nla variable de entorno <code>NODE_PATH</code> puedo haber sido establecido como:\n\n</p>\n<pre><code>/home/micheil/.node_modules:/usr/local/lib/node_modules</code></pre>\n<p>Cargar las ubicaciones desde <code>require.paths</code> sólo se realiza si el\nmódulon no se ha encontrado desde el algoritmo <code>node_modules</code>.\nLos módulos globarles son de baja prioridad para las dependencias de los paquetes.\n\n</p>\n",
          "properties": [
            {
              "textRaw": "**Nota:** Por favor evite la modificación de `require.paths`",
              "name": "paths`",
              "desc": "<p>Por razones de compatibilidad, <code>require.paths</code> sigue siendo la primera prioridad\nen el proceso de búsqueda de módulos. Sin embargo, puede desaparecer en una próxima\nversión.\n\n</p>\n<p>Aunque parecía una buena idea en aquel tiempo, y ha permitido ser un \nexperimento muy útil, en la práctica la transformación de <code>require.paths</code> es una\nlista a menudo con problemas y dolores de cabeza.\n\n</p>\n",
              "modules": [
                {
                  "textRaw": "Establecer `require.paths` a algún otro valor para nada.",
                  "name": "establecer_`require.paths`_a_algún_otro_valor_para_nada.",
                  "desc": "<p>Esto no hace nada de lo que se podría esperar:\n\n</p>\n<pre><code>require.paths = [ &apos;/usr/lib/node&apos; ];</code></pre>\n<p>Todo lo que se hace aquí es perder la referencia <em>actual</em> de node en la búsqueda\nde rutas, y crea una nueva referencia a otra cosa que no sirve\npara nada.\n\n</p>\n",
                  "type": "module",
                  "displayName": "Establecer `require.paths` a algún otro valor para nada."
                },
                {
                  "textRaw": "Poner rutas relativas en `require.paths` es... raro.",
                  "name": "poner_rutas_relativas_en_`require.paths`_es..._raro.",
                  "desc": "<p>Si hace esto:\n\n</p>\n<pre><code>require.paths.push(&apos;./lib&apos;);</code></pre>\n<p>entonces <em>no</em> añada la ruta completa donde se resolvió <code>./lib</code>\nen este sistema de ficheros.  En cambio, esto añade literalmente <code>&apos;./lib&apos;</code>,\nlo que significa si hace <code>require(&apos;y.js&apos;)</code> en  <code>/a/b/x.js</code>, entonces se ve\nen <code>/a/b/lib/y.js</code>.  Si a continuación se usa <code>require(&apos;y.js&apos;)</code> en\n<code>/l/m/n/o/p.js</code>, entonces se ve en <code>/l/m/n/o/lib/y.js</code>.\n\n</p>\n<p>En la práctica, las personas han usado esto de una manera ad hoc para la\ndependencia de paquetes, pero esta técnica es frágil.\n\n</p>\n",
                  "type": "module",
                  "displayName": "Poner rutas relativas en `require.paths` es... raro."
                },
                {
                  "textRaw": "Cero aislamiento",
                  "name": "cero_aislamiento",
                  "desc": "<p>Existe (debido a un diseño lamentable), sólo un array <code>require.paths</code> utilizado para\ntodos los módulos.\n\n</p>\n<p>Como resultado, si un programa en node trata de confiar de este comportamiento, es posible\nque de manera permanente y sutilmente altere el comportamiento de todos los programas \nescritos en node el mismo proceso. A media que el stack crece, y se reune más\nfuncionalidades, ya que esto es un problema con las partes que interactúan en forma\ndifíciles de predecir.\n\n</p>\n",
                  "type": "module",
                  "displayName": "Cero aislamiento"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Módulos"
    },
    {
      "textRaw": "Addons",
      "name": "addons",
      "desc": "<p>Addons son objetos enlazados dinamicamente. Ellos pueden ser el pegamento entre las librerias C y C++ con NodeJS. La API (en estos momentos) es algo compleja, siendo necesario el conocimiento de varias librerias.\n\n</p>\n<ul>\n<li><p>V8 JavaScript, una libreria C++. Usada como interfaz con JavaScript:\ncreación de objetos, llamada a funciones, etc. Documentada extensamente en fichero de cabecera <code>v8.h</code> (<code>deps/v8/include/v8.h</code> en el arbol de fuentes de Node).</p>\n</li>\n<li><p>libev, C libreria para crear un bucle de evento. En cualquier momentos que sea necesario esperar para que el descriptor de un fichero llegue a ser legible, esperar por un timer, o esperar por una señal, que llevarlo a cabo será necesario utilizar el intefez de libev. Esto es, si tu realizas cualquier I/O, necesitaras usar libev. Node usa en bucle de evento <code>EV_DEFAULT</code>. La documentación puede ser encontrada <a href=\"http://cvs.schmorp.de/libev/ev.html\">aqui</a>.</p>\n</li>\n<li><p>libie, librería para manejar el pool de las hebras. Usado para hacer llamadas bloqueantes POSIX del sistema de forma asincrona. Una amplia variedad de envolturas ya existe para cada llamada, en <code>src/file.cc</code> por lo que posiblemente no tengas que usarla. Si necesitas usarla echale un vistazo al fichero de cabecera <code>deps/libie/eio.h</code>.</p>\n</li>\n<li><p>Librerias internas de Node. La más importante es la clase <code>node::ObjectWrap</code> que probablemente de la que tu desearas heredar.</p>\n</li>\n<li><p>Otras. Mira en <code>deps/</code> para cualquier cosa disponible.</p>\n</li>\n</ul>\n<p>Node estáticamente compila todas las dependencias dentro del ejecutable. Cuando compiles tú módulo, tu no tendrás que preocuparte sobre enlazar ninguna de estas librerias.\n\n</p>\n<p>Para comenzar hagamos un pequeño Addon el cual hará lo siguiente in C++:\n\n</p>\n<pre><code>exports.hello = &apos;world&apos;;</code></pre>\n<p>Para comenzar creamos el fichero <code>hello.cc</code>:\n\n</p>\n<pre><code>#include &lt;v8.h&gt;\n\nusing namespace v8;\n\nextern &quot;C&quot; void\ninit (Handle&lt;Object&gt; target)\n{\n  HandleScope scope;\n  target-&gt;Set(String::New(&quot;hello&quot;), String::New(&quot;world&quot;));\n}</code></pre>\n<p>Este código fuente necesita ser construido dentro de <code>hello.node</code>, el Addon binario. Para hacer esto nosotros creamos un fichero llamado <code>wscript</code> el cual es código python y se ve como sigue:\n\n</p>\n<pre><code>srcdir = &apos;.&apos;\nblddir = &apos;build&apos;\nVERSION = &apos;0.0.1&apos;\n\ndef set_options(opt):\n  opt.tool_options(&apos;compiler_cxx&apos;)\n\ndef configure(conf):\n  conf.check_tool(&apos;compiler_cxx&apos;)\n  conf.check_tool(&apos;node_addon&apos;)\n\ndef build(bld):\n  obj = bld.new_task_gen(&apos;cxx&apos;, &apos;shlib&apos;, &apos;node_addon&apos;)\n  obj.target = &apos;hello&apos;\n  obj.source = &apos;hello.cc&apos;</code></pre>\n<p>Lanzando <code>node-waf configure build</code> crearemos un fichero <code>build/default/hello.node</code> el cual es nuestro Addon.\n\n</p>\n<p><code>node-waf</code> es solo <a href=\"http://code.google.com/p/waf\">WAF</a>, el sistema de construcción basado en python. <code>node-waf</code> is proporcionado para la facilidad de los usuarios.\n\n</p>\n<p>Todos los Addons de Node deben exportar un función llamada <code>init</code> con la siguiente constitución:\n\n</p>\n<pre><code>extern &apos;C&apos; void init (Handle&lt;Object&gt; target)</code></pre>\n<p>Por el momento, esta es toda la documentación sobre Addons. Por favor, mira <a href=\"https://github.com/ry/node_postgres\">https://github.com/ry/node_postgres</a> para un ejemplo real.\n\n</p>\n",
      "type": "module",
      "displayName": "Addons"
    },
    {
      "textRaw": "process",
      "name": "process",
      "desc": "<p>El objeto <code>process</code> es un objeto global y puede ser accedido desde cualquier parte.\nEs una instancia de <code>EventEmitter</code>.\n\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Evento: 'exit'",
          "name": "evento:_'exit'",
          "desc": "<p><code>function () {}</code>\n\n</p>\n<p>Emitido cuando el proceso está apunto de salir. Es un buen hook para realizar \nun control del tiempo constante del estado del módulo (por ejemplo para tests unitarios).<br>El bucle del evento principal no seguirá ejecutándose después de finalizar el callback &apos;exit&apos;, \npor lo tanto los timers no pueden ser programados.\n\n</p>\n<p>Ejemplo escuchando a <code>exit</code>:\n\n</p>\n<pre><code>process.on(&apos;exit&apos;, function () {\n  process.nextTick(function () {\n   console.log(&apos;Esto no se ejecutará&apos;);\n  });\n  console.log(&apos;Apunto de salir.&apos;);\n});</code></pre>\n",
          "type": "module",
          "displayName": "Evento: 'exit'"
        },
        {
          "textRaw": "Evento: 'uncaughtException'",
          "name": "evento:_'uncaughtexception'",
          "desc": "<p><code>function (err) { }</code>\n\n</p>\n<p>Emitido cuando una excepción es devuelta hacia el bucle de evento. Si se\nha añadido un listener a esta excepción, no se producirá la acción por defecto \n(imprimir una traza del stack y salir).\n\n</p>\n<p>Ejemplo escuchando a <code>uncaughtException</code>:\n\n</p>\n<pre><code>process.on(&apos;uncaughtException&apos;, function (err) {\n  console.log(&apos;Excepción recogida: &apos; + err);\n});\n\nsetTimeout(function () {\n  console.log(&apos;Esto seguirá ejecutándose.&apos;);\n}, 500);\n\n// Se fuerza una excepción, pero no se recoge.\nnonexistentFunc();\nconsole.log(&apos;Esto no se ejecutará.&apos;);</code></pre>\n<p>Nótese que <code>uncaughtException</code> es un mecanismo muy básico para \nmanejar excepciones.  Usando try / catch en tu programa te dará más control sobre\nel flujo de tu programa. Especialmente para aplicaciones de servidor que están diseñados para\nejecutarse eternamente, <code>uncaughtException</code> puede ser un mecanismo muy útil de seguridad.\n\n\n</p>\n",
          "type": "module",
          "displayName": "Evento: 'uncaughtException'"
        },
        {
          "textRaw": "Eventos de señal",
          "name": "eventos_de_señal",
          "desc": "<p><code>function () {}</code>\n\n</p>\n<p>Emitido cuando los procesos reciben una señal. Mirar sigaction(2) para una lista de \nnombres de señal estándard POSIX como SIGINT, SIGUSR1, etc.\n\n</p>\n<p>Ejemplo escuchando a <code>SIGINT</code>:\n\n</p>\n<pre><code>// Empieza leyendo de stdin para evitar salir.\nprocess.stdin.resume();\n\nprocess.on(&apos;SIGINT&apos;, function () {\n  console.log(&apos;Recibido SIGINT.  Haz Control-D para salir.&apos;);\n});</code></pre>\n<p>Una manera sencilla de enviar la señal <code>SIGINT</code> es con <code>Control-C</code> en la mayoria \nde aplicaciones de terminal.\n\n\n</p>\n",
          "type": "module",
          "displayName": "Eventos de señal"
        }
      ],
      "properties": [
        {
          "textRaw": "process.stdout",
          "name": "stdout",
          "desc": "<p>Un <code>Stream de Escritura</code> para <code>stdout</code>.\n\n</p>\n<p>Ejemplo: la definición de <code>console.log</code>\n\n</p>\n<pre><code>console.log = function (d) {\n  process.stdout.write(d + &apos;\\n&apos;);\n};</code></pre>\n",
          "properties": [
            {
              "textRaw": "process.stderr",
              "name": "stderr",
              "desc": "<p>Un stream de escritura para stderr. Las escrituras en este stream son bloqueantes.\n\n\n</p>\n"
            },
            {
              "textRaw": "process.stdin",
              "name": "stdin",
              "desc": "<p>Un <code>Stream de Lectura</code> para stdin. El stream stdin se detiene por defecto, así que \nse tiene que llamar a <code>process.stdin.resume()</code> para leer de él.\n\n</p>\n<p>Ejemplo de como abir la entrada estándard (stdin) y escuchar a ambos eventos:\n\n</p>\n<pre><code>process.stdin.resume();\nprocess.stdin.setEncoding(&apos;utf8&apos;);\n\nprocess.stdin.on(&apos;data&apos;, function (chunk) {\n  process.stdout.write(&apos;data: &apos; + chunk);\n});\n\nprocess.stdin.on(&apos;end&apos;, function () {\n  process.stdout.write(&apos;end&apos;);\n});</code></pre>\n"
            },
            {
              "textRaw": "process.argv",
              "name": "argv",
              "desc": "<p>Un array que contiene los argumentos de la línea de comandos. El primer elemento será\n&apos;node&apos;, el segundo elemento será el nombre del fichero JavaScript. Los\nsiguientes elementos serán argumentos adicionales de la línea de comandos.\n\n</p>\n<pre><code>// imprimir process.argv\nprocess.argv.forEach(function (val, index, array) {\n  console.log(index + &apos;: &apos; + val);\n});</code></pre>\n<p>Generará:\n\n</p>\n<pre><code>$ node process-2.js one two=three four\n0: node\n1: /Users/mjr/work/node/process-2.js\n2: one\n3: two=three\n4: four</code></pre>\n"
            },
            {
              "textRaw": "process.execPath",
              "name": "execPath",
              "desc": "<p>Es la ruta absoluta del ejecutable que inició el proceso.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>/usr/local/bin/node</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "process.version",
          "name": "version",
          "desc": "<p>Una propiedad dentro del compilado que expone <code>NODE_VERSION</code>.\n\n</p>\n<pre><code>console.log(&apos;Versión: &apos; + process.version);</code></pre>\n"
        },
        {
          "textRaw": "process.installPrefix",
          "name": "installPrefix",
          "desc": "<p>Una propiedad dentro del compilado que expone <code>NODE_PREFIX</code>.\n\n</p>\n<pre><code>console.log(&apos;Prefijo: &apos; + process.installPrefix);</code></pre>\n"
        },
        {
          "textRaw": "process.pid",
          "name": "pid",
          "desc": "<p>El PID del proceso.\n\n</p>\n<pre><code>console.log(&apos;El pid de este proceso es  &apos; + process.pid);</code></pre>\n",
          "properties": [
            {
              "textRaw": "process.title",
              "name": "title",
              "desc": "<p>Getter/setter para establecer lo que mostrará &apos;ps&apos;.\n\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "process.platform",
          "name": "platform",
          "desc": "<p>En que plataforma se está ejecutando. <code>&apos;linux2&apos;</code>, <code>&apos;darwin&apos;</code>, etc.\n\n</p>\n<pre><code>console.log(&apos;La plataforma es &apos; + process.platform);</code></pre>\n",
          "methods": [
            {
              "textRaw": "process.memoryUsage()",
              "type": "method",
              "name": "memoryUsage",
              "desc": "<p>Devuelve un objeto describiendo el uso de la memoria del proceso Node.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nconsole.log(util.inspect(process.memoryUsage()));</code></pre>\n<p>Generará:\n\n</p>\n<pre><code>{ rss: 4935680,\n  vsize: 41893888,\n  heapTotal: 1826816,\n  heapUsed: 650472 }</code></pre>\n<p><code>heapTotal</code> y <code>heapUsed</code> se refieren al uso de la memoria de V8.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.nextTick(callback)",
              "type": "method",
              "name": "nextTick",
              "desc": "<p>En la siguiente iteración del bucle del evento se llama a callback.\nNo es simplemente un alias para <code>setTimeout(fn, 0)</code> , es mucho\nmás eficiente.\n\n</p>\n<pre><code>process.nextTick(function () {\n  console.log(&apos;nextTick callback&apos;);\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.umask([mask])",
              "type": "method",
              "name": "umask",
              "desc": "<p>Establece o lee la máscara del modo de creación del fichero del proceso. Los procesos \nhijos heredan la máscara del proceso padre. Devuelve la antigua máscara si se pasa el argumento \n<code>mask</code>, si no devuelve la máscara actual. \n\n</p>\n<pre><code>var oldmask, newmask = 0644;\n\noldmask = process.umask(newmask);\nconsole.log(&apos;Cambiada umask de: &apos; + oldmask.toString(8) +\n            &apos; a &apos; + newmask.toString(8));</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "mask",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "process.chdir(directory)",
          "type": "method",
          "name": "chdir",
          "desc": "<p>Cambia el directorio actual de trabajo del proceso o lanza una excepción si falla.\n\n</p>\n<pre><code>console.log(&apos;Directorio inicial: &apos; + process.cwd());\ntry {\n  process.chdir(&apos;/tmp&apos;);\n  console.log(&apos;Directorio nuevo: &apos; + process.cwd());\n}\ncatch (err) {\n  console.log(&apos;chdir: &apos; + err);\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "directory"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.cwd()",
          "type": "method",
          "name": "cwd",
          "desc": "<p>Devuelve el directorio actual de trabajo del proceso.\n\n</p>\n<pre><code>console.log(&apos;Directorio actual: &apos; + process.cwd());</code></pre>\n",
          "properties": [
            {
              "textRaw": "process.env",
              "name": "env",
              "desc": "<p>Un objeto que contiene el entorno del usuario. Mirar environ(7).\n\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "process.exit(code=0)",
              "type": "method",
              "name": "exit",
              "desc": "<p>Termina el proceso con el <code>code</code> especificado.  Si se omite, <code>exit</code> usa el código \nde &apos;éxito&apos; <code>0</code>.\n\n</p>\n<p>Para salir con un código de &apos;fallo&apos;:\n\n</p>\n<pre><code>process.exit(1);</code></pre>\n<p>El shell que ha ejecutado node debería ver 1 como código de salida.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "code",
                      "default": "0"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.getgid()",
          "type": "method",
          "name": "getgid",
          "desc": "<p>Obtiene la identidad de grupo del proceso.  (Mirar getgid(2).)\nEs el id de grupo numérico, no el nombre del grupo.\n\n</p>\n<pre><code>console.log(&apos;Actual gid: &apos; + process.getgid());</code></pre>\n",
          "methods": [
            {
              "textRaw": "process.setgid(id)",
              "type": "method",
              "name": "setgid",
              "desc": "<p>Establece la identidad de grupo del proceso. (Mirar setgid(2).)  Acepta tanto \nun ID numérico como una cadena de texto con el nombre del grupo. \nSi se especifica el nombre del grupo, el método se bloquea mientras lo \nresuelve a un ID numérico.\n\n</p>\n<pre><code>console.log(&apos;Actual gid: &apos; + process.getgid());\ntry {\n  process.setgid(501);\n  console.log(&apos;Nuevo gid: &apos; + process.getgid());\n}\ncatch (err) {\n  console.log(&apos;Fallo al cambiar el gid: &apos; + err);\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.getuid()",
          "type": "method",
          "name": "getuid",
          "desc": "<p>Obtiene la identidad de usuario del proceso. (Mirar getuid(2).)\nEs la id de usuario númerica, no el nombre de usuario.\n\n</p>\n<pre><code>console.log(&apos;Actual uid: &apos; + process.getuid());</code></pre>\n",
          "methods": [
            {
              "textRaw": "process.setuid(id)",
              "type": "method",
              "name": "setuid",
              "desc": "<p>Establece la identidad de usuario del proceso. (Mirar setuid(2).)  Acepta tanto \nun ID numérico como una cadena de texto con el nombre de usuario.  Si se especifica \nel nombre de usuario, el método se bloquea mientras lo resuelve a un ID numérico.\n\n</p>\n<pre><code>console.log(&apos;Actual uid: &apos; + process.getuid());\ntry {\n  process.setuid(501);\n  console.log(&apos;Nuevo uid: &apos; + process.getuid());\n}\ncatch (err) {\n  console.log(&apos;Fallo al establecer uid: &apos; + err);\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.kill(pid, signal='SIGTERM')",
          "type": "method",
          "name": "kill",
          "desc": "<p>Envia una señal a un proceso. <code>pid</code> es la id de proceso y <code>signal</code> es la cadena de \ntexto que describe la señal a enviar.  Los nombres de señales son cadenas de texto\n como &apos;SIGINT&apos; o &apos;SIGUSR1&apos;.  Si se omite, la señal será &apos;SIGTERM&apos;.\nMirar kill(2) para más información.\n\n</p>\n<p>Notar que ya que el nombre de la función es <code>process.kill</code>, se trata solo de \nun emisor de señales, como la llamada a sistema <code>kill</code>. La señal enviada\npuede hacer algo más que matar el proceso escogido.\n\n</p>\n<p>Ejemplo de como enviarse una señal a uno mismo:\n\n</p>\n<pre><code>process.on(&apos;SIGHUP&apos;, function () {\n  console.log(&apos;Recibida señal SIGHUP.&apos;);\n});\n\nsetTimeout(function () {\n  console.log(&apos;Saliendo.&apos;);\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, &apos;SIGHUP&apos;);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "pid"
                },
                {
                  "name": "signal",
                  "default": "'SIGTERM'"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "process"
    },
    {
      "textRaw": "util",
      "name": "util",
      "stability": 5,
      "stabilityText": "Locked",
      "desc": "<p>Estas funciones estan en el módulo <code>&apos;util&apos;</code>. Usa <code>require(&apos;util&apos;)</code> para acceder \na ellas.\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "util.format()",
          "type": "method",
          "name": "format",
          "desc": "<p>Returns a formatted string using the first argument as a <code>printf</code>-like format.\n\n</p>\n<p>The first argument is a string that contains zero or more <em>placeholders</em>.\nEach placeholder is replaced with the converted value from its corresponding\nargument. Supported placeholders are:\n\n</p>\n<ul>\n<li><code>%s</code> - String.</li>\n<li><code>%d</code> - Number (both integer and float).</li>\n<li><code>%j</code> - JSON.</li>\n<li><code>%%</code> - single percent sign (<code>&apos;%&apos;</code>). This does not consume an argument.</li>\n</ul>\n<p>If the placeholder does not have a corresponding argument, the placeholder is\nnot replaced.\n\n</p>\n<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;); // &apos;foo:%s&apos;</code></pre>\n<p>If there are more arguments than placeholders, the extra arguments are\nconverted to strings with <code>util.inspect()</code> and these strings are concatenated,\ndelimited by a space.\n\n</p>\n<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;); // &apos;foo:bar baz&apos;</code></pre>\n<p>If the first argument is not a format string then <code>util.format()</code> returns\na string that is the concatenation of all its arguments separated by spaces.\nEach argument is converted to a string with <code>util.inspect()</code>.\n\n</p>\n<pre><code>util.format(1, 2, 3); // &apos;1 2 3&apos;</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "util.debug(string)",
          "type": "method",
          "name": "debug",
          "desc": "<p>Una función de salida síncrona. Bloquerá el proceso y pondrá \n<code>string</code> inmediatamente en <code>stderr</code>.\n\n</p>\n<pre><code>require(&apos;util&apos;).debug(&apos;mensaje en stderr&apos;);</code></pre>\n",
          "methods": [
            {
              "textRaw": "util.log(string)",
              "type": "method",
              "name": "log",
              "desc": "<p>Salida con timestamp en <code>stdout</code>.\n\n</p>\n<pre><code>require(&apos;util&apos;).log(&apos;Mensaje con marca de tiempo.&apos;);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "string"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "util.inspect(object, showHidden=false, depth=2)",
              "type": "method",
              "name": "inspect",
              "desc": "<p>Devuelve la cadena que representa a <code>object</code>, lo cual es útil para corregir fallos.\n\n</p>\n<p>Si <code>showHidden</code> es <code>true</code>, entonces las propiedades no-enumerables del \nobjeto serán mostradas también. Por omisión es <code>false</code>.\n\n</p>\n<p>Si <code>depth</code> es proporcionado, le dice a <code>inspect</code> cuantas veces tiene que recurrir\nmientras formatea el objeto. Esto es útil para objetos muy largos y complejos.\n\n</p>\n<p>Por defecto solo se recurre un par de veces. Para hacer que recurra indefinidamente\npasa <code>null</code> a <code>depth</code>.\n\n</p>\n<p>Si <code>colors</code> es <code>true</code>, entonces la salida mostrará los estilos con los código de colores en ANSI.\nPor omisión es <code>false</code>.\n\n</p>\n<p>Ejemplo de inspeccionar todas las propiedades del objeto <code>util</code>:\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nconsole.log(util.inspect(util, true, null));</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "showHidden",
                      "default": "false"
                    },
                    {
                      "name": "depth",
                      "default": "2"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isArray(object)",
          "type": "method",
          "name": "isArray",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Array</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isRegExp(object)",
          "type": "method",
          "name": "isRegExp",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>RegExp</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isRegExp(/some regexp/)\n  // true\nutil.isRegExp(new RegExp(&apos;another regexp&apos;))\n  // true\nutil.isRegExp({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isDate(object)",
          "type": "method",
          "name": "isDate",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Date</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isDate(new Date())\n  // true\nutil.isDate(Date())\n  // false (without &apos;new&apos; returns a String)\nutil.isDate({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isError(object)",
          "type": "method",
          "name": "isError",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Error</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isError(new Error())\n  // true\nutil.isError(new TypeError())\n  // true\nutil.isError({ name: &apos;Error&apos;, message: &apos;an error occurred&apos; })\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.pump(readableStream, writableStream, [callback])",
          "type": "method",
          "name": "pump",
          "desc": "<p>Experimental\n\n</p>\n<p>Lee los datos desde <code>readableStream</code> y los envia al <code>writableStream</code>.\nCuando <code>writableStream.write(data)</code> devuelve <code>false</code> <code>readableStream</code> será\npausado hasta que ocurra el evento <code>drain</code> sobre <code>writableStream</code>. <code>callback</code>\ntiene un error como único argumento y es llamada cuando <code>writableStream</code> es\ncerrado o cuando ocurre un error.\n\n\n</p>\n",
          "methods": [
            {
              "textRaw": "util.inherits(constructor, superConstructor)",
              "type": "method",
              "name": "inherits",
              "desc": "<p>Hereda los métodos del prototype desde un \n<a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor\">constructor</a>\ndentro de otro. El prototype del <code>constructor</code> será configurado a un nuevo\nobjecto creado desde <code>superConstructor</code>.\n\n</p>\n<p>Como mejora adicional, <code>superConstructor</code>será accesible atravez de \nla propiedad <code>constructor.super_</code>.\n\n</p>\n<pre><code>var util = require(&quot;util&quot;);\nvar events = require(&quot;events&quot;);\n\nfunction MyStream() {\n    events.EventEmitter.call(this);\n}\n\nutil.inherits(MyStream, events.EventEmitter);\n\nMyStream.prototype.write = function(data) {\n    this.emit(&quot;data&quot;, data);\n}\n\nvar stream = new MyStream();\n\nconsole.log(stream instanceof events.EventEmitter); // true\nconsole.log(MyStream.super_ === events.EventEmitter); // true\n\nstream.on(&quot;data&quot;, function(data) {\n    console.log(&apos;Received data: &quot;&apos; + data + &apos;&quot;&apos;);\n})\nstream.write(&quot;It works!&quot;); // Received data: &quot;It works!&quot;</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "constructor"
                    },
                    {
                      "name": "superConstructor"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "readableStream"
                },
                {
                  "name": "writableStream"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "util"
    },
    {
      "textRaw": "Eventos",
      "name": "eventos",
      "desc": "<p>Muchos objetos en Node emiten eventos: un <code>net.Server</code> emite un evento cada vez que se establece una conexión, un <code>fs.readStream</code> emite un evento cuando se abre un fichero. Todos los objectos que emiten eventos son instancias de <code>events.EventEmitter</code>.\nPuedes usar este módulo haciendo <code>require(&quot;events&quot;);</code>\n\n</p>\n<p>Normalmente, los nombres de los eventos siguen la notacion camel-case, sin embargo, no hay ninguna restricción en este aspecto y cualquier cadena será aceptada.\n\n</p>\n<p>Se pueden adjuntar funciones a objetos, para que sean ejecutadas cuando se emita un evento. Estas funciones reciben el nombre de <em>listeners</em>. \n\n</p>\n",
      "properties": [
        {
          "textRaw": "events.EventEmitter",
          "name": "EventEmitter",
          "desc": "<p>Para usar la clase EventEmitter, haz de importarla\nhaciendo <code>require(&apos;events&apos;).EventEmiter</code>.\n\n</p>\n<p>Cuando una instancia de la clase EventEmitter se encuentra con un error, la acción típica\nes emitir un evento de error. Los eventos de error son tratados como un caso especial en node.\nSi no tiene un listener asociado la acción por defecto será imprimir la traza de la pila y salir\ndel programa\n\n</p>\n<p>Todos los EventEmitters emite el evento <code>&apos;newListener&apos;</code> cuando se añaden nuevos listeners.\n\n</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "emitter.addListener(event, listener)",
          "type": "method",
          "name": "addListener",
          "desc": "<p>Añade un listener al final del array de listeners para el evento espeficicado\n\n</p>\n<pre><code>server.on(&apos;connection&apos;, function (stream) {\n  console.log(&apos;someone connected!&apos;);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "event"
                },
                {
                  "name": "listener"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "event"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "emitter.on(event, listener)",
          "type": "method",
          "name": "on",
          "desc": "<p>Añade un listener al final del array de listeners para el evento espeficicado\n\n</p>\n<pre><code>server.on(&apos;connection&apos;, function (stream) {\n  console.log(&apos;someone connected!&apos;);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "event"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "emitter.once(event, listener)",
          "type": "method",
          "name": "once",
          "desc": "<p>Añade un listener al evento. El listener se invocará sólo la primera vez que se dispara el evento.\nluego se elimina. \n\n</p>\n<pre><code>server.once(&apos;connection&apos;, function (stream) {\n  console.log(&apos;Ah, we have our first user!&apos;);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "event"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "emitter.removeListener(event, listener)",
          "type": "method",
          "name": "removeListener",
          "desc": "<p>Elimina un listener del array de listeners asociado al evento especificado\n<strong>Atención</strong>: modifica el indice del array de listeners \n\n</p>\n<pre><code>var callback = function(stream) {\n  console.log(&apos;someone connected!&apos;);\n};\nserver.on(&apos;connection&apos;, callback);\n// ...\nserver.removeListener(&apos;connection&apos;, callback);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "event"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "emitter.removeAllListeners(event)",
          "type": "method",
          "name": "removeAllListeners",
          "desc": "<p>Elimina todos los listeners del array de listeners asociado al evento especificado\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "event"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "emitter.setMaxListeners(n)",
          "type": "method",
          "name": "setMaxListeners",
          "desc": "<p>Por defecto los EventEmitters imprimirán un warning si se le añaden más de 10 listeners.\nEste comportamiento por defecto ayuda a encontrar memory leaks. Obviamente no todos los EventEmitters\ndeberían limitarse a 10. Esta función permite incrementar este valor. Use cero para establecer un valor ilimitado.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "n"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "emitter.listeners(event)",
          "type": "method",
          "name": "listeners",
          "desc": "<p>Devuelve un array de listeners asociado al evento especificado. Este array puede ser manipulado, por ejemplo, eliminando un listener.\n\n</p>\n<pre><code>server.on(&apos;connection&apos;, function (stream) {\n  console.log(&apos;someone connected!&apos;);\n});\nconsole.log(util.inspect(server.listeners(&apos;connection&apos;)); // [ [Function] ]</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "event"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "emitter.emit(event, [arg1], [arg2], [...])",
          "type": "method",
          "name": "emit",
          "desc": "<p>Llama a cada uno de los listeners en el orden en el que fueron pasados por parámetros\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "event"
                },
                {
                  "name": "arg1",
                  "optional": true
                },
                {
                  "name": "arg2",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "events": [
        {
          "textRaw": "Event: 'newListener'",
          "type": "event",
          "name": "newListener",
          "desc": "<p><code>function (event, listener) { }</code>\n\n</p>\n<p>Este evento es emitido cada vez que se añade un nuevo listener.\n\n</p>\n",
          "params": []
        }
      ],
      "type": "module",
      "displayName": "Eventos"
    },
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>El puro Javascript es amigable con Unicode, pero no se lleva tan bien con \nlos datos binarios. Cuando tratamos con streams TCP o ficheros del sistema,\nes necesario manejar streams de octets. Node tiene algunas estrategias para\nmanipular, crear, y consumir streams de octets.\n\n</p>\n<p>Los datos en Raw son almacenados en instancias de la clase <code>Buffer</code>. Un \n<code>Buffer</code> es similar a un array de integers pero correspondiendo a una localización\nen raw de la memeria fuera del heap de V8. Un <code>Buffer</code> no puede ser redimencionado.\n\n</p>\n<p>La clase <code>Buffer</code> es global, dado que es muy raro hacer un\n<code>require(&apos;buffer&apos;)</code>.\n\n</p>\n<p>Convertir entre Buffers y objectos String de Javascript requiere de un método de \ncodificación explícito. Aquí están las diferentes cadenas de codificación.\n\n</p>\n<ul>\n<li><p><code>&apos;ascii&apos;</code> - solo para datos de 7 bit ASCII. Este método de codificación es muy rápido\ny dejará el bit alto si está configurado.\nNote that this encoding converts a null character (<code>&apos;\\0&apos;</code> or <code>&apos;\\u0000&apos;</code>) into\n<code>0x20</code> (character code of a space). If you want to convert a null character\ninto <code>0x00</code>, you should use <code>&apos;utf8&apos;</code>.</p>\n</li>\n<li><p><code>&apos;utf8&apos;</code> - Multiples bytes de caracteres con codificación Unicode. Muchas páginas webs y otros formatos de documentos usan UTF-8.</p>\n</li>\n<li><p><code>&apos;ucs2&apos;</code> - 2-bytes, de caracteres con codificación <code>little endian</code> Unicode. \nSólo pueden codificar BMP(Basic Multilingual Plane, U+0000 - U+FFFF).</p>\n</li>\n<li><p><code>&apos;base64&apos;</code> - String codificado a Base64.</p>\n</li>\n<li><p><code>&apos;binary&apos;</code> - Una forma de codificar datos binarios en Raw dentro de strings pero solo usando\nlos primeros 8 bits de cada caracter. Este método de codificación es obsoleto y\ndebe ser evitado en favor del objeto <code>Buffer</code> donde sea posible. Esta codificación\nserá eliminada en futuras versiones de Node.</p>\n</li>\n<li><p><code>&apos;hex&apos;</code> - Encode each byte as two hexidecimal characters.</p>\n</li>\n</ul>\n",
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<p>The Buffer class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "buf.write(string, [offset], [length], [encoding])",
              "type": "method",
              "name": "write",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` String - data to be written to buffer ",
                      "name": "string",
                      "desc": "String - data to be written to buffer"
                    },
                    {
                      "textRaw": "`offset` Number, Optional, Default: 0 ",
                      "name": "offset",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` Number, Optional ",
                      "name": "length",
                      "optional": true,
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Escribe <code>string</code> en el Buffer en <code>offset</code> usando el método dado.\n<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>. <code>length</code> is\nthe number of bytes to write. Devuelve el número de octets escritos. Si <code>Buffer</code> \nno contiene suficiente espacio para encajar en el string completo, escribirá una\ncantidad parcial de la cadena. <code>length</code> defaults to <code>buffer.length - offset</code>.\nThe method will not write partial characters.\n\n</p>\n<pre><code>buf = new Buffer(256);\nlen = buf.write(&apos;\\u00bd + \\u00bc = \\u00be&apos;, 0);\nconsole.log(len + &quot; bytes: &quot; + buf.toString(&apos;utf8&apos;, 0, len));</code></pre>\n<p>The number of characters written (which may be different than the number of\nbytes written) is set in <code>Buffer._charsWritten</code> and will be overwritten the\nnext time <code>buf.write()</code> is called.\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.toString([encoding], [start], [end])",
              "type": "method",
              "name": "toString",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` Number, Optional, Default: 0 ",
                      "name": "start",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` Number, Optional ",
                      "name": "end",
                      "optional": true,
                      "desc": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Decodifica y devuelve un string con los datos de un buffer codificado con <code>encoding</code>\n(por omisión en <code>&apos;utf8&apos;</code>) comenzando en <code>start</code> (por omisión <code>0</code>) y terminando en\n<code>end</code> (por omisión <code>buffer.length</code>).\n\n</p>\n<p>Observe el ejemplo de <code>buffer.write()</code>, encima.\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])",
              "type": "method",
              "name": "copy",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`targetBuffer` Buffer object - Buffer to copy into ",
                      "name": "targetBuffer",
                      "desc": "Buffer object - Buffer to copy into"
                    },
                    {
                      "textRaw": "`targetStart` Number, Optional, Default: 0 ",
                      "name": "targetStart",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` Number, Optional, Default: 0 ",
                      "name": "sourceStart",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` Number, Optional, Default: 0 ",
                      "name": "sourceEnd",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "targetBuffer"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Does copy between buffers. The source and target regions can be overlapped.\n<code>targetStart</code> and <code>sourceStart</code> default to <code>0</code>.\n<code>sourceEnd</code> defaults to <code>buffer.length</code>.\n\n</p>\n<p>Ejemplo: construye dos Buffers, entonces copia <code>buf1</code> desde el byte 16 hasta el byte 19\ndentro de <code>buf2</code>, comenzando en el octavo byte de <code>buf2</code>.\n\n</p>\n<pre><code>buf1 = new Buffer(26);\nbuf2 = new Buffer(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n  buf2[i] = 33; // ASCII !\n}\n\nbuf1.copy(buf2, 8, 16, 20);\nconsole.log(buf2.toString(&apos;ascii&apos;, 0, 25));\n\n// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>\n"
            },
            {
              "textRaw": "buf.slice([start], [end])",
              "type": "method",
              "name": "slice",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`start` Number, Optional, Default: 0 ",
                      "name": "start",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` Number, Optional, Default: 0 ",
                      "name": "end",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Devuelve un nuevo buffer el cual hace referencia a la misma memoria que el antíguo,\npero desplazado y cortado por los indices <code>start</code> (por omisión <code>0</code>) and \n<code>end</code> (por omisión <code>buffer.length</code>).\n\n\n</p>\n<p><strong>¡Al modificar el nuevo buffer, modificarás la memoria en el buffer original!</strong>\n\n</p>\n<p>Ejemplo: contruye un Buffer con el alfabeto ASCII, toma un fragmento, y \nentonces modifica un byte desde el Buffer original.\n\n</p>\n<pre><code>var buf1 = new Buffer(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n}\n\nvar buf2 = buf1.slice(0, 3);\nconsole.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));\nbuf1[0] = 33;\nconsole.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));\n\n// abc\n// !bc</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt8(offset, [noAssert])",
              "type": "method",
              "name": "readUInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nfor (ii = 0; ii &lt; buf.length; ii++) {\n  console.log(buf.readUInt8(ii));\n}\n\n// 0x3\n// 0x4\n// 0x23\n// 0x42</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16LE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt16BE(0));\nconsole.log(buf.readUInt16LE(0));\nconsole.log(buf.readUInt16BE(1));\nconsole.log(buf.readUInt16LE(1));\nconsole.log(buf.readUInt16BE(2));\nconsole.log(buf.readUInt16LE(2));\n\n// 0x0304\n// 0x0403\n// 0x0423\n// 0x2304\n// 0x2342\n// 0x4223</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16BE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt16BE(0));\nconsole.log(buf.readUInt16LE(0));\nconsole.log(buf.readUInt16BE(1));\nconsole.log(buf.readUInt16LE(1));\nconsole.log(buf.readUInt16BE(2));\nconsole.log(buf.readUInt16LE(2));\n\n// 0x0304\n// 0x0403\n// 0x0423\n// 0x2304\n// 0x2342\n// 0x4223</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32LE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt32BE(0));\nconsole.log(buf.readUInt32LE(0));\n\n// 0x03042342\n// 0x42230403</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32BE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt32BE(0));\nconsole.log(buf.readUInt32LE(0));\n\n// 0x03042342\n// 0x42230403</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt8(offset, [noAssert])",
              "type": "method",
              "name": "readInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 8 bit integer from the buffer at the specified offset.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&apos;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt16LE(offset, [noAssert])",
              "type": "method",
              "name": "readInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&apos;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt16BE(offset, [noAssert])",
              "type": "method",
              "name": "readInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&apos;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt32LE(offset, [noAssert])",
              "type": "method",
              "name": "readInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&apos;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt32BE(offset, [noAssert])",
              "type": "method",
              "name": "readInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&apos;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readFloatLE(offset, [noAssert])",
              "type": "method",
              "name": "readFloatLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32 bit float from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x00;\nbuf[1] = 0x00;\nbuf[2] = 0x80;\nbuf[3] = 0x3f;\n\nconsole.log(buf.readFloatLE(0));\n\n// 0x01</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatBE(offset, [noAssert])",
              "type": "method",
              "name": "readFloatBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32 bit float from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x00;\nbuf[1] = 0x00;\nbuf[2] = 0x80;\nbuf[3] = 0x3f;\n\nconsole.log(buf.readFloatLE(0));\n\n// 0x01</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleLE(offset, [noAssert])",
              "type": "method",
              "name": "readDoubleLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64 bit double from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\n\nbuf[0] = 0x55;\nbuf[1] = 0x55;\nbuf[2] = 0x55;\nbuf[3] = 0x55;\nbuf[4] = 0x55;\nbuf[5] = 0x55;\nbuf[6] = 0xd5;\nbuf[7] = 0x3f;\n\nconsole.log(buf.readDoubleLE(0));\n\n// 0.3333333333333333</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleBE(offset, [noAssert])",
              "type": "method",
              "name": "readDoubleBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64 bit double from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\n\nbuf[0] = 0x55;\nbuf[1] = 0x55;\nbuf[2] = 0x55;\nbuf[3] = 0x55;\nbuf[4] = 0x55;\nbuf[5] = 0x55;\nbuf[6] = 0xd5;\nbuf[7] = 0x3f;\n\nconsole.log(buf.readDoubleLE(0));\n\n// 0.3333333333333333</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt8",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a\nvalid unsigned 8 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n\n// &lt;Buffer 03 04 23 42&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt16LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n\n// &lt;Buffer de ad be ef&gt;\n// &lt;Buffer ad de ef be&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt16BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n\n// &lt;Buffer de ad be ef&gt;\n// &lt;Buffer ad de ef be&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt32LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer fe ed fa ce&gt;\n// &lt;Buffer ce fa ed fe&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt32BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer fe ed fa ce&gt;\n// &lt;Buffer ce fa ed fe&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt8(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt8",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a\nvalid signed 8 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&apos;s complement\nsigned integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt16LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&apos;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt16BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&apos;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt32LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&apos;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt32BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&apos;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeFloatLE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid 32 bit float.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 4f 4a fe bb&gt;\n// &lt;Buffer bb fe 4a 4f&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeFloatBE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid 32 bit float.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 4f 4a fe bb&gt;\n// &lt;Buffer bb fe 4a 4f&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeDoubleLE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid 64 bit double.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeDoubleBE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid 64 bit double.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.fill(value, [offset], [end])",
              "type": "method",
              "name": "fill",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` ",
                      "name": "value"
                    },
                    {
                      "textRaw": "`offset` Number, Optional ",
                      "name": "offset",
                      "optional": true,
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`end` Number, Optional ",
                      "name": "end",
                      "optional": true,
                      "desc": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)\nand <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire\nbuffer.\n\n</p>\n<pre><code>var b = new Buffer(50);\nb.fill(&quot;h&quot;);</code></pre>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "desc": "<p>Obtiene y configura el octet en <code>index</code>. Los valores se refieren a bytes individuales,\npor lo que el rango legal esta entre <code>0x00</code> and <code>0xFF</code> en hexadecimal o <code>0</code> y <code>255</code>.\n\n</p>\n<p>Ejemplo: Copiando un cadena ASCII dentro de un buffer, un byte cada vez:\n\n</p>\n<pre><code>str = &quot;node.js&quot;;\nbuf = new Buffer(str.length);\n\nfor (var i = 0; i &lt; str.length ; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf);\n\n// node.js</code></pre>\n"
            },
            {
              "textRaw": "`length` Number ",
              "name": "length",
              "desc": "<p>El tamaño del buffer en bytes. Vea que esto no es necesariamente al tamaño\ndel contenido. <code>length</code> se refiere a la cantidad de memoria asignada para el\nobjeto buffer. No cambia cuando el contenido del buffer cambia.\n\n</p>\n<pre><code>buf = new Buffer(1234);\n\nconsole.log(buf.length);\nbuf.write(&quot;some string&quot;, &quot;ascii&quot;, 0);\nconsole.log(buf.length);\n\n// 1234\n// 1234</code></pre>\n",
              "shortDesc": "Number"
            }
          ],
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Boolean ",
                    "name": "return",
                    "desc": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` Object ",
                      "name": "obj",
                      "desc": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ],
              "desc": "<p>Comprueba si <code>obj</code> es un <code>Buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string, [encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`string` String ",
                      "name": "string",
                      "desc": "String"
                    },
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Da la longitud de una cadena en bytes. <code>encoding</code> por omisión en <code>&apos;utf8&apos;</code>.\nEsto no es lo mismo como <code>String.prototype.length</code> puesto que devuelve el\nnúmero de <em>caracteres</em> en el string.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>str = &apos;\\u00bd + \\u00bc = \\u00be&apos;;\n\nconsole.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +\n  Buffer.byteLength(str, &apos;utf8&apos;) + &quot; bytes&quot;);\n\n// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` Number ",
                  "name": "size",
                  "desc": "Number"
                }
              ],
              "desc": "<p>Asigna un nuevo buffer de <code>size</code> octets.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Asigna un nuevo buffer de <code>size</code> octets.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`array` Array ",
                  "name": "array",
                  "desc": "Array"
                }
              ],
              "desc": "<p>Asigna un nuevo buffer usando un <code>array</code> de octets.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "array"
                }
              ],
              "desc": "<p>Asigna un nuevo buffer usando un <code>array</code> de octets.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`str` String - string to encode. ",
                  "name": "str",
                  "desc": "String - string to encode."
                },
                {
                  "textRaw": "`encoding` String - encoding to use, Optional. ",
                  "name": "encoding",
                  "desc": "String - encoding to use, Optional.",
                  "optional": true
                }
              ],
              "desc": "<p>Allocates a new buffer containing the given <code>str</code>.\n<code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ],
              "desc": "<p>Allocates a new buffer containing the given <code>str</code>.\n<code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "desc": "<p>This class is primarily for internal use.  JavaScript programs should\nuse Buffer instead of using SlowBuffer.\n\n</p>\n<p>In order to avoid the overhead of allocating many C++ Buffer objects for\nsmall blocks of memory in the lifetime of a server, Node allocates memory\nin 8Kb (8192 byte) chunks.  If a buffer is smaller than this size, then it\nwill be backed by a parent SlowBuffer object.  If it is larger than this,\nthen Node will allocate a SlowBuffer slab for it directly.\n</p>\n"
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` Number, Default: 50 ",
          "name": "INSPECT_MAX_BYTES",
          "desc": "<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can\nbe overridden by user modules.\n\n</p>\n<p>Note that this is a property on the buffer module returned by\n<code>require(&apos;buffer&apos;)</code>, not on the Buffer global, or a buffer instance.\n\n</p>\n",
          "shortDesc": "Number, Default: 50"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    },
    {
      "textRaw": "Streams",
      "name": "streams",
      "desc": "<p>Un Stream es un interfaz abstracto implementado por varios objetos en Node. Por ejemplo una petición a un servidor HTTP es un Stream, como un stdout. Los Streams son legibles, escribibles o ambos. Todos los stream son instancias de <code>EventEmitter</code>.\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Readable Stream",
          "name": "readable_stream",
          "desc": "<p>A <code>Readable Stream</code> has the following methods, members, and events.\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "desc": "<p><code>function (data) { }</code>\n\n</p>\n<p>The <code>&apos;data&apos;</code> event emits either a <code>Buffer</code> (by default) or a string if\n<code>setEncoding()</code> was used.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<p>Emitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more <code>&apos;data&apos;</code> events will happen. If the stream is also\nwritable, it may be possible to continue writing.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<p><code>function (exception) { }</code>\n\n</p>\n<p>Emitted if there was an error receiving data.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<p>Emitted when the underlying file descriptor has been closed. Not all streams\nwill emit this.  (For example, an incoming HTTP request will not emit\n<code>&apos;close&apos;</code>.)\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'fd'",
              "type": "event",
              "name": "fd",
              "desc": "<p><code>function (fd) { }</code>\n\n</p>\n<p>Emitted when a file descriptor is received on the stream. Only UNIX streams\nsupport this functionality; all others will simply never emit this event.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "stream.readable",
              "name": "readable",
              "desc": "<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>&apos;error&apos;</code>\noccurred, the stream came to an <code>&apos;end&apos;</code>, or <code>destroy()</code> was called.\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "stream.setEncoding(encoding)",
              "type": "method",
              "name": "setEncoding",
              "desc": "<p>Makes the data event emit a string instead of a <code>Buffer</code>. <code>encoding</code> can be\n<code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "stream.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<p>Pauses the incoming <code>&apos;data&apos;</code> events.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "stream.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<p>Resumes the incoming <code>&apos;data&apos;</code> events after a <code>pause()</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "stream.destroy()",
              "type": "method",
              "name": "destroy",
              "desc": "<p>Closes the underlying file descriptor. Stream will not emit any more events.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "stream.destroySoon()",
              "type": "method",
              "name": "destroySoon",
              "desc": "<p>After the write queue is drained, close the file descriptor.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "stream.pipe(destination, [options])",
              "type": "method",
              "name": "pipe",
              "desc": "<p>This is a <code>Stream.prototype</code> method available on all <code>Stream</code>s.\n\n</p>\n<p>Connects this read stream to <code>destination</code> WriteStream. Incoming\ndata on this stream gets written to <code>destination</code>. The destination and source\nstreams are kept in sync by pausing and resuming as necessary.\n\n</p>\n<p>Emulating the Unix <code>cat</code> command:\n\n</p>\n<pre><code>process.stdin.resume();\nprocess.stdin.pipe(process.stdout);</code></pre>\n<p>By default <code>end()</code> is called on the destination when the source stream emits\n<code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end: false }</code> as\n<code>options</code> to keep the destination stream open.\n\n</p>\n<p>This keeps <code>process.stdout</code> open so that &quot;Goodbye&quot; can be written at the end.\n\n</p>\n<pre><code>process.stdin.resume();\n\nprocess.stdin.pipe(process.stdout, { end: false });\n\nprocess.stdin.on(&quot;end&quot;, function() {\n  process.stdout.write(&quot;Goodbye\\n&quot;);\n});</code></pre>\n<p>NOTE: If the source stream does not support <code>pause()</code> and <code>resume()</code>, this function\nadds simple definitions which simply emit <code>&apos;pause&apos;</code> and <code>&apos;resume&apos;</code> events on\nthe source stream.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "destination"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "Readable Stream"
        },
        {
          "textRaw": "Writable Stream",
          "name": "writable_stream",
          "desc": "<p>A <code>Writable Stream</code> has the following methods, members, and events.\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<p>Emitted after a <code>write()</code> method was called that returned <code>false</code> to\nindicate that it is safe to write again.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<p><code>function (exception) { }</code>\n\n</p>\n<p>Emitted on error with the exception <code>exception</code>.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<p>Emitted when the underlying file descriptor has been closed.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'pipe'",
              "type": "event",
              "name": "pipe",
              "desc": "<p><code>function (src) { }</code>\n\n</p>\n<p>Emitted when the stream is passed to a readable stream&apos;s pipe method.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "stream.writable",
              "name": "writable",
              "desc": "<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>&apos;error&apos;</code>\noccurred or <code>end()</code> / <code>destroy()</code> was called.\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "stream.write(string, encoding='utf8', [fd])",
              "type": "method",
              "name": "write",
              "desc": "<p>Writes <code>string</code> with the given <code>encoding</code> to the stream.  Returns <code>true</code> if\nthe string has been flushed to the kernel buffer.  Returns <code>false</code> to\nindicate that the kernel buffer is full, and the data will be sent out in\nthe future. The <code>&apos;drain&apos;</code> event will indicate when the kernel buffer is\nempty again. The <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.\n\n</p>\n<p>If the optional <code>fd</code> parameter is specified, it is interpreted as an integral\nfile descriptor to be sent over the stream. This is only supported for UNIX\nstreams, and is silently ignored otherwise. When writing a file descriptor in\nthis manner, closing the descriptor before the stream drains risks sending an\ninvalid (closed) FD.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "default": "'utf8'"
                    },
                    {
                      "name": "fd",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "stream.write(buffer)",
              "type": "method",
              "name": "write",
              "desc": "<p>Same as the above except with a raw buffer.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "stream.end()",
              "type": "method",
              "name": "end",
              "desc": "<p>Terminates the stream with EOF or FIN.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "stream.end(string, encoding)",
              "type": "method",
              "name": "end",
              "desc": "<p>Sends <code>string</code> with the given <code>encoding</code> and terminates the stream with EOF\nor FIN. This is useful to reduce the number of packets sent.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "stream.end(buffer)",
              "type": "method",
              "name": "end",
              "desc": "<p>Same as above but with a <code>buffer</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "stream.destroy()",
              "type": "method",
              "name": "destroy",
              "desc": "<p>Closes the underlying file descriptor. Stream will not emit any more events.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "stream.destroySoon()",
              "type": "method",
              "name": "destroySoon",
              "desc": "<p>After the write queue is drained, close the file descriptor. <code>destroySoon()</code>\ncan still destroy straight away, as long as there is no data left in the queue\nfor writes.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "Writable Stream"
        }
      ],
      "type": "module",
      "displayName": "Streams"
    },
    {
      "textRaw": "Crypto",
      "name": "crypto",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>Usa <code>require(&apos;crypto&apos;)</code> para acceder a este módulo.\n\n</p>\n<p>El módulo crypto necesita que OpenSSL esté disponible en el sistema.\nOfrece una forma de encapsular credenciales seguras para ser usadas \ncomo parte de una red HTTPS segura o una conexión http.\n\n</p>\n<p>Además ofrece un conjunto de envoltorios para los métodos hash, hmac, cipher, decipher, sign y verify de OpenSSL.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "crypto.createCredentials(details)",
          "type": "method",
          "name": "createCredentials",
          "desc": "<p>Crea un objeto credenciales, con los detalles opcionales en forma de diccionario con las siguientes claves:\n\n</p>\n<ul>\n<li><code>key</code> : cadena que contiene la clave privada codificada en PEM.</li>\n<li><code>passphrase</code> : A string of passphrase for the private key</li>\n<li><code>cert</code> : cadena que contiene el certificado codificado en PEM.</li>\n<li><code>ca</code> : cadena o lista de cadenas de certificados de confianza codificados en PEM.</li>\n<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List)</li>\n<li><code>ciphers</code>: A string describing the ciphers to use or exclude. Consult\n<a href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a> for details\non the format.</li>\n</ul>\n<p>Si no se han dado ningún elemento en <code>ca</code>, node.js usará la lista de CAs de confianza publicadas como dice en\n</p>\n<p><a href=\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.\n\n\n</p>\n",
          "methods": [
            {
              "textRaw": "crypto.createHash(algorithm)",
              "type": "method",
              "name": "createHash",
              "desc": "<p>Crea y devuelve un nuevo objeto hash, un hash criptográfico con el algoritmo \ndado que puede ser usado para generar el hash digests.\n\n</p>\n<p><code>algorithm</code> depende de los algoritmos disponibles en la versión de OpenSSL en el sistema.\nAlgunos ejemplos son <code>&apos;sha1&apos;</code>, <code>&apos;md5&apos;</code>, <code>&apos;sha256&apos;</code>, <code>&apos;sha512&apos;</code>, etc. \nEn versiones recientes, <code>openssl list-message-digest-algorithms</code> mostrará los algoritmos digest disponibles.\n\n</p>\n<p>Example: this program that takes the sha1 sum of a file\n\n</p>\n<pre><code>var filename = process.argv[2];\nvar crypto = require(&apos;crypto&apos;);\nvar fs = require(&apos;fs&apos;);\n\nvar shasum = crypto.createHash(&apos;sha1&apos;);\n\nvar s = fs.ReadStream(filename);\ns.on(&apos;data&apos;, function(d) {\n  shasum.update(d);\n});\n\ns.on(&apos;end&apos;, function() {\n  var d = shasum.digest(&apos;hex&apos;);\n  console.log(d + &apos;  &apos; + filename);\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "details"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createCipheriv",
          "desc": "<p>Creates and returns a cipher object, with the given algorithm, key and iv.\n\n</p>\n<p><code>algorithm</code> is the same as the <code>createCipher()</code>. <code>key</code> is a raw key used in\nalgorithm. <code>iv</code> is an Initialization vector. <code>key</code> and <code>iv</code> must be <code>&apos;binary&apos;</code>\nencoded string (See the <a href=\"buffer.html\">Buffer section</a> for more information).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createSign(algorithm)",
          "type": "method",
          "name": "createSign",
          "desc": "<p>Crea y devuelve un objeto firma (signing) con el algoritmo dado.\nEn versiones recientes, <code>openssl list-public-key-algorithms</code> muestra\nlos algoritmos de firmado disponibles. Por ejemplo: `&apos;RSA-SHA256\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime_length)",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<p>Creates a Diffie-Hellman key exchange object and generates a prime of the\ngiven bit length. The generator used is <code>2</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime_length"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime, [encoding])",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<p>Creates a Diffie-Hellman key exchange object using the supplied prime. The\ngenerator used is <code>2</code>. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>.\nDefaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.getDiffieHellman(group_name)",
          "type": "method",
          "name": "getDiffieHellman",
          "desc": "<p>Creates a predefined Diffie-Hellman key exchange object.\nThe supported groups are: <code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code>\n(defined in <a href=\"http://www.rfc-editor.org/rfc/rfc2412.txt\">RFC 2412</a>)\nand <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>, <code>&apos;modp18&apos;</code>\n(defined in <a href=\"http://www.rfc-editor.org/rfc/rfc3526.txt\">RFC 3526</a>).\nThe returned object mimics the interface of objects created by\n<a href=\"#crypto.createDiffieHellman\">crypto.createDiffieHellman()</a> above, but\nwill not allow to change the keys (with\n<a href=\"#diffieHellman.setPublicKey\">diffieHellman.setPublicKey()</a> for example).\nThe advantage of using this routine is that the parties don&apos;t have to\ngenerate nor exchange group modulus beforehand, saving both processor and\ncommunication time.\n\n</p>\n<p>Example (obtaining a shared secret):\n\n</p>\n<pre><code>var crypto = require(&apos;crypto&apos;);\nvar alice = crypto.getDiffieHellman(&apos;modp5&apos;);\nvar bob = crypto.getDiffieHellman(&apos;modp5&apos;);\n\nalice.generateKeys();\nbob.generateKeys();\n\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), &apos;binary&apos;, &apos;hex&apos;);\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), &apos;binary&apos;, &apos;hex&apos;);\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "group_name"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2(password, salt, iterations, keylen, callback)",
          "type": "method",
          "name": "pbkdf2",
          "desc": "<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive\na key of given length from the given password, salt and iterations.\nThe callback gets two arguments <code>(err, derivedKey)</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.randomBytes(size, [callback])",
          "type": "method",
          "name": "randomBytes",
          "desc": "<p>Generates cryptographically strong pseudo-random data. Usage:\n\n</p>\n<pre><code>// async\ncrypto.randomBytes(256, function(ex, buf) {\n  if (ex) throw ex;\n  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);\n});\n\n// sync\ntry {\n  var buf = crypto.randomBytes(256);\n  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);\n} catch (ex) {\n  // handle error\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Hash",
          "type": "class",
          "name": "Hash",
          "desc": "<p>The class for creating hash digests of data.\n\n</p>\n<p>Returned by <code>crypto.createHash</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hash.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<p>Actualiza el contenido del hash con el <code>data</code> dado. the encoding of which is given\nin <code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code>.\nDefaults to <code>&apos;binary&apos;</code>.\nEsto puede ser invocado muchas veces con dato nuevo mientras estos van llegando.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hash.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<p>Calcula el digest todos los datos que van al hash.\nLa codificación (<code>encoding</code>) puede ser <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> o <code>&apos;base64&apos;</code>.\nPor omisíón es <code>&apos;binary&apos;</code>.\n\n</p>\n<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method been called.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createHmac(algorithm, key)",
              "type": "method",
              "name": "createHmac",
              "desc": "<p>Crea y devuelve un objeto hmac, un hmac criptográfico con el algoritmo y la clave dadas.\n\n</p>\n<p><code>algorithm</code> depende de los algoritmos disponibles en la versión de OpenSSL en el sistema -  ver createHash arriba.\n<code>key</code> es la clave hmac a usar.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hmac",
          "type": "class",
          "name": "Hmac",
          "desc": "<p>Class for creating cryptographic hmac content.\n\n</p>\n<p>Returned by <code>crypto.createHmac</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hmac.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<p>Actualiza el contenido del hmac con el <code>data</code> dado.\nEsto puede ser invocado muchas veces con dato nuevo mientras estos van llegando.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hmac.digest(encoding='binary')",
              "type": "method",
              "name": "digest",
              "desc": "<p>Calcula el digest (resumen) de todos los datos que van al hmac.\nLa codificación (<code>encoding</code>) puede ser <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> o <code>&apos;base64&apos;</code>.\nPor omisíón es <code>&apos;binary&apos;</code>.\n\n</p>\n<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method been called.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "default": "'binary'"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createCipher(algorithm, key)",
              "type": "method",
              "name": "createCipher",
              "desc": "<p>Crea y devuelve un objeto cipher (codificador), con el algoritmo y la clave dadas.\n\n</p>\n<p><code>algorithm</code> es dependiente de OpenSSL, por ejemplo <code>&apos;aes192&apos;</code>, etc.\nEn versiones recientes, <code>openssl list-cipher-algorithms</code> mostrará \nlos algoritmos cipher disponibles.\n<code>password</code> is used to derive key and IV, which must be <code>&apos;binary&apos;</code> encoded\nstring (See the <a href=\"buffer.html\">Buffer section</a> for more information).\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Cipher",
          "type": "class",
          "name": "Cipher",
          "desc": "<p>Class for encrypting data.\n\n</p>\n<p>Returned by <code>crypto.createCipher</code> and <code>crypto.createCipheriv</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "cipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Actualiza el cipher con <code>data</code>, la codificación viene dada en \n<code>input_encoding</code> y puede ser <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> o <code>&apos;binary&apos;</code>. \nPor omisión <code>&apos;binary&apos;</code>. \n\n</p>\n<p>El <code>output_encoding</code> especifica el formato de la salida del dato codificado,\ny puede ser <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> o <code>&apos;hex&apos;</code>. Por omisión <code>&apos;binary&apos;</code>.\n\n</p>\n<p>Devuelve el contenido codificado, y puede ser llamado muchas veces a medida que nuevos datos van llegando.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<p>Devuelve cualquier contenido codificado restante, donde <code>output_encoding</code> puede ser:\n<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> o <code>&apos;hex&apos;</code>. Por omisión <code>&apos;binary&apos;</code>.\n\n</p>\n<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method been called.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<p>You can disable automatic padding of the input data to block size. If <code>auto_padding</code> is false,\nthe length of the entire input data must be a multiple of the cipher&apos;s block size or <code>final</code> will fail.\nUseful for non-standard padding, e.g. using <code>0x0</code> instead of PKCS padding. You must call this before <code>cipher.final</code>.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDecipher(algorithm, key)",
              "type": "method",
              "name": "createDecipher",
              "desc": "<p>Crea y devuelve un objeto decipher (decodificación), con el algoritmo y clave dado.\nEste es el simétrico del objeto cipher (codificación) de arriba.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.update(data, input_encoding='binary', output_encoding='binary')",
              "type": "method",
              "name": "update",
              "desc": "<p>Actualiza el objeto decodificador con <code>data</code>, que puede estar codificado en <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> o <code>&apos;hex&apos;</code>.\nEl <code>output_decoding</code> especifica en qué formato devolver el texto plano decodificdo: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> o <code>&apos;utf8&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "default": "'binary'"
                    },
                    {
                      "name": "output_encoding",
                      "default": "'binary'"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Decipher",
          "type": "class",
          "name": "Decipher",
          "desc": "<p>Class for decrypting data.\n\n</p>\n<p>Returned by <code>crypto.createDecipher</code> and <code>crypto.createDecipheriv</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "decipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the decipher with <code>data</code>, which is encoded in <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code>\nor <code>&apos;hex&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n<p>The <code>output_decoding</code> specifies in what format to return the deciphered\nplaintext: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<p>Devuelve el texto plano decodificado restante, siendo\n<code>output_encoding</code> <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> o <code>&apos;utf8&apos;</code>.\nPor omisión <code>&apos;binary&apos;</code>.\n\n</p>\n<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method been called.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<p>You can disable auto padding if the data has been encrypted without standard block padding to prevent\n<code>decipher.final</code> from checking and removing it. Can only work if the input data&apos;s length is a multiple of the\nciphers block size. You must call this before streaming data to <code>decipher.update</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Signer",
          "type": "class",
          "name": "Signer",
          "desc": "<p>Class for generating signatures.\n\n</p>\n<p>Returned by <code>crypto.createSign</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "signer.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<p>Actualiza el objeto firma con los datos dados.\nPuede ser llamado muchas veces a medida que nuevos datos van llegando.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "signer.sign(private_key, output_format='binary')",
              "type": "method",
              "name": "sign",
              "desc": "<p>Calcula la firma en todos los datos actualizados pasados a través del objetvo firma.\n<code>private_key</code> es una cadena que contiene la clave privada para firmar codificada en PEM.\n\n</p>\n<p>Devuelve la firma en <code>output_format</code> que puede estar en <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> o \n<code>&apos;base64&apos;</code>. Por omisión <code>&apos;binary&apos;</code>.\n\n</p>\n<p>Note: <code>signer</code> object can not be used after <code>sign()</code> method been called.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "output_format",
                      "default": "'binary'"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createVerify(algorithm)",
              "type": "method",
              "name": "createVerify",
              "desc": "<p>Crea y devuelve un objeto verificación con el algoritmo dado.\nEste es el simétrico del objeto firma de arriba.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Verify",
          "type": "class",
          "name": "Verify",
          "desc": "<p>Class for verifying signatures.\n\n</p>\n<p>Returned by <code>crypto.createVerify</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "verifier.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<p>Actualiza el objeto verificador con los datos dados.\nPuede ser llamado muchas veces a medida que nuevos datos van llegando.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "verifier.verify(cert, signature, signature_format='binary')",
              "type": "method",
              "name": "verify",
              "desc": "<p>Verifica los datos firmados usando <code>cert</code>, que es una cadena que contiene la llave pública codificada en PEM; y <code>signature</code>, que es la firma del dato previamente calculada; <code>signature_format</code> puede ser <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> o <code>&apos;base64&apos;</code>.\n\n</p>\n<p>Devuelve true o false dependiendo en la validez de la firma para el dato y la clave pública dadas.\n\n</p>\n<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method been called.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "cert"
                    },
                    {
                      "name": "signature"
                    },
                    {
                      "name": "signature_format",
                      "default": "'binary'"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: DiffieHellman",
          "type": "class",
          "name": "DiffieHellman",
          "desc": "<p>The class for creating Diffie-Hellman key exchanges.\n\n</p>\n<p>Returned by <code>crypto.createDiffieHellman</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "diffieHellman.generateKeys([encoding])",
              "type": "method",
              "name": "generateKeys",
              "desc": "<p>Generates private and public Diffie-Hellman key values, and returns the\npublic key in the specified encoding. This key should be transferred to the\nother party. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>.\nDefaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "desc": "<p>Computes the shared secret using <code>other_public_key</code> as the other party&apos;s\npublic key and returns the computed shared secret. Supplied key is\ninterpreted using specified <code>input_encoding</code>, and secret is encoded using\nspecified <code>output_encoding</code>. Encodings can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or\n<code>&apos;base64&apos;</code>. The input encoding defaults to <code>&apos;binary&apos;</code>.\nIf no output encoding is given, the input encoding is used as output encoding.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrime([encoding])",
              "type": "method",
              "name": "getPrime",
              "desc": "<p>Returns the Diffie-Hellman prime in the specified encoding, which can be\n<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getGenerator([encoding])",
              "type": "method",
              "name": "getGenerator",
              "desc": "<p>Returns the Diffie-Hellman prime in the specified encoding, which can be\n<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPublicKey([encoding])",
              "type": "method",
              "name": "getPublicKey",
              "desc": "<p>Returns the Diffie-Hellman public key in the specified encoding, which can\nbe <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "desc": "<p>Returns the Diffie-Hellman private key in the specified encoding, which can\nbe <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPublicKey(public_key, [encoding])",
              "type": "method",
              "name": "setPublicKey",
              "desc": "<p>Sets the Diffie-Hellman public key. Key encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,\nor <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPrivateKey(public_key, [encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "desc": "<p>Sets the Diffie-Hellman private key. Key encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,\nor <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Crypto"
    },
    {
      "textRaw": "TLS (SSL)",
      "name": "tls_(ssl)",
      "desc": "<p>Usa <code>require(&apos;tls&apos;)</code> para acceder a este módulo.\n\n</p>\n<p>El módulo <code>tls</code> utiliza OpenSSL para proveer seguridad en la Transport Layer Security y/o Secure Socket Layer: encriptacion de flujo de comunicaciones.\n\n</p>\n<p>TLS/SSL es una infraestructura de clave publica/privada. Cada cliente y cada servidor deben tener una clave privada. Una clave privada se crea como sigue:\n\n</p>\n<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>\n<p>Todos los servidores y algunos clientes necesitan tener un certificado. Los certificados son claves públicas firmadas por una autoridad certificadora (CA) o por ellas mismas. El primer paso para obtener un certificado es crear un fichero de &quot;Petición de firma de Certificado&quot; (CSR). Esto se hace como sigue:\n\n</p>\n<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>\n<p>Para crear un certificado auto firmado con el CSR, hay que hacer:\n\n</p>\n<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>\n<p>De forma alternativa puedes enviar el CSR a la autoridad certificadora para firmarlo.\n\n</p>\n<p>(TODO: documentos sobre la creación de una CA, por ahora los usuarios interesados deberían echar un vistazo a <code>test/fixtures/keys/Makefile</code> en el código fuente de Node)\n\n</p>\n",
      "methods": [
        {
          "textRaw": "s = tls.connect(port, [host], [options], callback)",
          "type": "method",
          "name": "connect",
          "desc": "<p>Crea una nueva conexión cliente al <code>port</code> y al <code>host</code> dados. (<code>host</code> por defecto es <code>localhost</code>.) <code>options</code> debe ser un objeto que especifique:\n\n</p>\n<ul>\n<li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la llave privada del servidor en formato PEM. (Requerido)</p>\n</li>\n<li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene la clave del certificado del servidor en formato PEM.</p>\n</li>\n<li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs &quot;root&quot; bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p>\n</li>\n</ul>\n<p><code>tls.connect()</code> devuelve un objeto <code>CryptoStream</code> en texto plano.\n\n</p>\n<p>Después del TSL/SSL handshake el <code>callback</code> es invocado. El <code>callback</code> será invocado independientemente si el certificado del servidor fue autorizado o no. Es responsabilidad del usuario probar <code>s.authorized</code> para ver si el certificado del servidor estaba firmado por una de las CAs especificadas. Si <code>s.authorized === false</code> entonces el error puede encontrarse en <code>s.authorizationError</code>.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "STARTTLS",
          "name": "starttls",
          "desc": "<p>In the v0.4 branch no function exists for starting a TLS session on an\nalready existing TCP connection.  This is possible it just requires a bit of\nwork. The technique is to use <code>tls.createSecurePair()</code> which returns two\nstreams: an encrypted stream and a plaintext stream. The encrypted stream is then\npiped to the socket, the plaintext stream is what the user interacts with thereafter.\n\n</p>\n<p><a href=\"http://gist.github.com/848444\">Here is some code that does it.</a>\n\n\n\n\n</p>\n",
          "type": "module",
          "displayName": "STARTTLS"
        }
      ],
      "properties": [
        {
          "textRaw": "tls.Server",
          "name": "Server",
          "desc": "<p>Esta clase es una subclase de <code>net.Server</code> y tiene los mismos métodos.\nEn lugar de aceptar solo conexiones TCP en bruto, acepta conexiones encriptadas usando TLS o SSL.\n\n</p>\n<p>Aquí hay un ejemplo simple de un servidor eco:\n\n</p>\n<pre><code>var tls = require(&apos;tls&apos;);\nvar fs = require(&apos;fs&apos;);\n\nvar options = {\n  key: fs.readFileSync(&apos;server-key.pem&apos;),\n  cert: fs.readFileSync(&apos;server-cert.pem&apos;)\n};\n\ntls.createServer(options, function (s) {\n  s.write(&quot;welcome!\\n&quot;);\n  s.pipe(s);\n}).listen(8000);</code></pre>\n<p>Puedes probar este servidor conectándose a él con <code>openssl s_client</code>:\n\n</p>\n<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>\n",
          "methods": [
            {
              "textRaw": "tls.createServer(options, secureConnectionListener)",
              "type": "method",
              "name": "createServer",
              "desc": "<p>Este es un constructor para la clase <code>tls.Server</code>. El objeto options puede contener:\n\n</p>\n<ul>\n<li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la clave privada del servidor en formato PEM. (Requerido)</p>\n</li>\n<li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene el certificado del servidor en formato PEM. (Requerido)</p>\n</li>\n<li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs &quot;root&quot; bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p>\n</li>\n<li><p><code>requestCert</code>: Si es <code>true</code> el servidor solicitará un certificado de todos los clientes que se conecten e intenten verificar ese certificado. Por defecto: <code>false</code></p>\n</li>\n<li><p><code>rejectUnauthorized</code>: Si es <code>true</code> el servidor rechazará cualquier conexión no autorizada por la lista de CAs suministradas. Esta opción solo tiene efecto si <code>requestCert</code> es <code>true</code>. Por defecto: <code>false</code>.</p>\n</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "secureConnectionListener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(port, [host], [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<p>Empieza aceptando conexiones en el <code>port</code> y el <code>host</code> especificados. Si el <code>host</code> es omitido, el servidor aceptará conexiones dirigidas a cualquier dirección IPv4 (<code>INADDR_ANY</code>).\n\n</p>\n<p>Esta función es asíncrona. El último parámetro <code>callback</code> se invocará cuando el servidor esté saturado.\n\n</p>\n<p>Mirar <code>net.Server</code> para más información.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.close()",
              "type": "method",
              "name": "close",
              "desc": "<p>Detiene el servidor, dejando de aceptar conexiones. Esta función es asíncrona, el servidor finalmente se cierra cuando emite un evento <code>&apos;close&apos;</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'secureConnection'",
              "type": "event",
              "name": "secureConnection",
              "desc": "<p><code>function (cleartextStream) {}</code>\n\n</p>\n<p>Este evento es emitido después de que una nueva conexión haya realizado con éxito el handshake. El argumento es una instancia de <code>stream.Stream</code>. Tiene todos los métodos y eventos de stream.\n\n</p>\n<p><code>cleartextStream.authorized</code> es un valor boolean que indica si el cliente está verificado por una de las CA suministradas por el servidor. Si <code>cleartextStream.authorized</code> es false, entonces <code>cleartextStream.authorizationError</code> describe como falló la autorización. Relacionado pero merece mencionarse: dependiendo de la configuración del servidor TLS, tus autorizaciones de conexión pueden ser aceptadas.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "server.maxConnections",
              "name": "maxConnections",
              "desc": "<p>Establece esta propiedad para rechazar conexiones cuando el número de conexiones del servidor sea alta.\n\n</p>\n"
            },
            {
              "textRaw": "server.connections",
              "name": "connections",
              "desc": "<p>Número de conexiones concurrentes en el servidor.\n\n\n</p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "TLS (SSL)"
    },
    {
      "textRaw": "File System",
      "name": "file_system",
      "desc": "<p>File I/O is provided by simple wrappers around standard POSIX functions.  To\nuse this module do <code>require(&apos;fs&apos;)</code>. All the methods have asynchronous and\nsynchronous forms.\n\n</p>\n<p>The asynchronous form always take a completion callback as its last argument.\nThe arguments passed to the completion callback depend on the method, but the\nfirst argument is always reserved for an exception. If the operation was\ncompleted successfully, then the first argument will be <code>null</code> or <code>undefined</code>.\n\n</p>\n<p>Here is an example of the asynchronous version:\n\n</p>\n<pre><code>var fs = require(&apos;fs&apos;);\n\nfs.unlink(&apos;/tmp/hello&apos;, function (err) {\n  if (err) throw err;\n  console.log(&apos;successfully deleted /tmp/hello&apos;);\n});</code></pre>\n<p>Here is the synchronous version:\n\n</p>\n<pre><code>var fs = require(&apos;fs&apos;);\n\nfs.unlinkSync(&apos;/tmp/hello&apos;)\nconsole.log(&apos;successfully deleted /tmp/hello&apos;);</code></pre>\n<p>With the asynchronous methods there is no guaranteed ordering. So the\nfollowing is prone to error:\n\n</p>\n<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {\n  if (err) throw err;\n  console.log(&apos;renamed complete&apos;);\n});\nfs.stat(&apos;/tmp/world&apos;, function (err, stats) {\n  if (err) throw err;\n  console.log(&apos;stats: &apos; + JSON.stringify(stats));\n});</code></pre>\n<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.\nThe correct way to do this is to chain the callbacks.\n\n</p>\n<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {\n  if (err) throw err;\n  fs.stat(&apos;/tmp/world&apos;, function (err, stats) {\n    if (err) throw err;\n    console.log(&apos;stats: &apos; + JSON.stringify(stats));\n  });\n});</code></pre>\n<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the\nasynchronous versions of these calls. The synchronous versions will block\nthe entire process until they complete--halting all connections.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "fs.rename(path1, path2, [callback])",
          "type": "method",
          "name": "rename",
          "desc": "<p>Asynchronous rename(2). No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path1"
                },
                {
                  "name": "path2"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.renameSync(path1, path2)",
          "type": "method",
          "name": "renameSync",
          "desc": "<p>Synchronous rename(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path1"
                },
                {
                  "name": "path2"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.truncate(fd, len, [callback])",
          "type": "method",
          "name": "truncate",
          "desc": "<p>Asynchronous ftruncate(2). No arguments other than a possible exception are\ngiven to the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "len"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.truncateSync(fd, len)",
          "type": "method",
          "name": "truncateSync",
          "desc": "<p>Synchronous ftruncate(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "len"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chmod(path, mode, [callback])",
          "type": "method",
          "name": "chmod",
          "desc": "<p>Asynchronous chmod(2). No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chmodSync(path, mode)",
          "type": "method",
          "name": "chmodSync",
          "desc": "<p>Synchronous chmod(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.stat(path, [callback])",
          "type": "method",
          "name": "stat",
          "desc": "<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where\n<code>stats</code> is a <code>fs.Stats</code> object. It looks like this:\n\n</p>\n<pre><code>{ dev: 2049,\n  ino: 305352,\n  mode: 16877,\n  nlink: 12,\n  uid: 1000,\n  gid: 1000,\n  rdev: 0,\n  size: 4096,\n  blksize: 4096,\n  blocks: 8,\n  atime: &apos;2009-06-29T11:11:55Z&apos;,\n  mtime: &apos;2009-06-29T11:11:40Z&apos;,\n  ctime: &apos;2009-06-29T11:11:40Z&apos; }</code></pre>\n<p>See the <code>fs.Stats</code> section below for more information.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstat(path, [callback])",
          "type": "method",
          "name": "lstat",
          "desc": "<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where\n<code>stats</code> is a <code>fs.Stats</code> object. lstat() is identical to stat(), except that if\npath is a symbolic link, then the link itself is stat-ed, not the file that it\nrefers to.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstat(fd, [callback])",
          "type": "method",
          "name": "fstat",
          "desc": "<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where\n<code>stats</code> is a <code>fs.Stats</code> object.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.statSync(path)",
          "type": "method",
          "name": "statSync",
          "desc": "<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstatSync(path)",
          "type": "method",
          "name": "lstatSync",
          "desc": "<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstatSync(fd)",
          "type": "method",
          "name": "fstatSync",
          "desc": "<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.link(srcpath, dstpath, [callback])",
          "type": "method",
          "name": "link",
          "desc": "<p>Asynchronous link(2). No arguments other than a possible exception are given to\nthe completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.linkSync(srcpath, dstpath)",
          "type": "method",
          "name": "linkSync",
          "desc": "<p>Synchronous link(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symlink(linkdata, path, [callback])",
          "type": "method",
          "name": "symlink",
          "desc": "<p>Asynchronous symlink(2). No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "linkdata"
                },
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symlinkSync(linkdata, path)",
          "type": "method",
          "name": "symlinkSync",
          "desc": "<p>Synchronous symlink(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "linkdata"
                },
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlink(path, [callback])",
          "type": "method",
          "name": "readlink",
          "desc": "<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,\nresolvedPath)</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlinkSync(path)",
          "type": "method",
          "name": "readlinkSync",
          "desc": "<p>Synchronous readlink(2). Returns the resolved path.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.realpath(path, [callback])",
          "type": "method",
          "name": "realpath",
          "desc": "<p>Asynchronous realpath(2).  The callback gets two arguments <code>(err,\nresolvedPath)</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.realpathSync(path)",
          "type": "method",
          "name": "realpathSync",
          "desc": "<p>Synchronous realpath(2). Returns the resolved path.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlink(path, [callback])",
          "type": "method",
          "name": "unlink",
          "desc": "<p>Asynchronous unlink(2). No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlinkSync(path)",
          "type": "method",
          "name": "unlinkSync",
          "desc": "<p>Synchronous unlink(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdir(path, [callback])",
          "type": "method",
          "name": "rmdir",
          "desc": "<p>Asynchronous rmdir(2). No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdirSync(path)",
          "type": "method",
          "name": "rmdirSync",
          "desc": "<p>Synchronous rmdir(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdir(path, mode, [callback])",
          "type": "method",
          "name": "mkdir",
          "desc": "<p>Asynchronous mkdir(2). No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdirSync(path, mode)",
          "type": "method",
          "name": "mkdirSync",
          "desc": "<p>Synchronous mkdir(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdir(path, [callback])",
          "type": "method",
          "name": "readdir",
          "desc": "<p>Asynchronous readdir(3).  Reads the contents of a directory.\nThe callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of\nthe names of the files in the directory excluding <code>&apos;.&apos;</code> and <code>&apos;..&apos;</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdirSync(path)",
          "type": "method",
          "name": "readdirSync",
          "desc": "<p>Synchronous readdir(3). Returns an array of filenames excluding <code>&apos;.&apos;</code> and\n<code>&apos;..&apos;</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.close(fd, [callback])",
          "type": "method",
          "name": "close",
          "desc": "<p>Asynchronous close(2).  No arguments other than a possible exception are given\nto the completion callback.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.closeSync(fd)",
          "type": "method",
          "name": "closeSync",
          "desc": "<p>Synchronous close(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.open(path, flags, [mode], [callback])",
          "type": "method",
          "name": "open",
          "desc": "<p>Asynchronous file open. See open(2). Flags can be &apos;r&apos;, &apos;r+&apos;, &apos;w&apos;, &apos;w+&apos;, &apos;a&apos;,\nor &apos;a+&apos;. <code>mode</code> defaults to 0666. The callback gets two arguments <code>(err, fd)</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.openSync(path, flags, [mode])",
          "type": "method",
          "name": "openSync",
          "desc": "<p>Synchronous open(2).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.write(fd, buffer, offset, length, position, [callback])",
          "type": "method",
          "name": "write",
          "desc": "<p>Write <code>buffer</code> to the file specified by <code>fd</code>.\n\n</p>\n<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.\n\n</p>\n<p><code>position</code> refers to the offset from the beginning of the file where this data\nshould be written. If <code>position</code> is <code>null</code>, the data will be written at the\ncurrent position.\nSee pwrite(2).\n\n</p>\n<p>The callback will be given two arguments <code>(err, written)</code> where <code>written</code>\nspecifies how many <em>bytes</em> were written.\n\n</p>\n<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file\nwithout waiting for the callback. For this scenario,\n<code>fs.createWriteStream</code> is strongly recommended.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeSync(fd, buffer, offset, length, position)",
          "type": "method",
          "name": "writeSync",
          "desc": "<p>Synchronous version of buffer-based <code>fs.write()</code>. Returns the number of bytes\nwritten.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeSync(fd, str, position, encoding='utf8')",
          "type": "method",
          "name": "writeSync",
          "desc": "<p>Synchronous version of string-based <code>fs.write()</code>. Returns the number of bytes\nwritten.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "str"
                },
                {
                  "name": "position"
                },
                {
                  "name": "encoding",
                  "default": "'utf8'"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.read(fd, buffer, offset, length, position, [callback])",
          "type": "method",
          "name": "read",
          "desc": "<p>Read data from the file specified by <code>fd</code>.\n\n</p>\n<p><code>buffer</code> is the buffer that the data will be written to.\n\n</p>\n<p><code>offset</code> is offset within the buffer where writing will start.\n\n</p>\n<p><code>length</code> is an integer specifying the number of bytes to read.\n\n</p>\n<p><code>position</code> is an integer specifying where to begin reading from in the file.\nIf <code>position</code> is <code>null</code>, data will be read from the current file position.\n\n</p>\n<p>The callback is given the two arguments, <code>(err, bytesRead)</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readSync(fd, buffer, offset, length, position)",
          "type": "method",
          "name": "readSync",
          "desc": "<p>Synchronous version of buffer-based <code>fs.read</code>. Returns the number of\n<code>bytesRead</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readSync(fd, length, position, encoding)",
          "type": "method",
          "name": "readSync",
          "desc": "<p>Synchronous version of string-based <code>fs.read</code>. Returns the number of\n<code>bytesRead</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                },
                {
                  "name": "encoding"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readFile(filename, [encoding], [callback])",
          "type": "method",
          "name": "readFile",
          "desc": "<p>Asynchronously reads the entire contents of a file. Example:\n\n</p>\n<pre><code>fs.readFile(&apos;/etc/passwd&apos;, function (err, data) {\n  if (err) throw err;\n  console.log(data);\n});</code></pre>\n<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the\ncontents of the file.\n\n</p>\n<p>If no encoding is specified, then the raw buffer is returned.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "encoding",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readFileSync(filename, [encoding])",
          "type": "method",
          "name": "readFileSync",
          "desc": "<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.\n\n</p>\n<p>If <code>encoding</code> is specified then this function returns a string. Otherwise it\nreturns a buffer.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeFile(filename, data, encoding='utf8', [callback])",
          "type": "method",
          "name": "writeFile",
          "desc": "<p>Asynchronously writes data to a file, replacing the file if it already exists.\n<code>data</code> can be a string or a buffer.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node&apos;, function (err) {\n  if (err) throw err;\n  console.log(&apos;It\\&apos;s saved!&apos;);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "data"
                },
                {
                  "name": "encoding",
                  "default": "'utf8'"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeFileSync(filename, data, encoding='utf8')",
          "type": "method",
          "name": "writeFileSync",
          "desc": "<p>The synchronous version of <code>fs.writeFile</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "data"
                },
                {
                  "name": "encoding",
                  "default": "'utf8'"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.watchFile(filename, [options], listener)",
          "type": "method",
          "name": "watchFile",
          "desc": "<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each\ntime the file is accessed.\n\n</p>\n<p>The second argument is optional. The <code>options</code> if provided should be an object\ncontaining two members a boolean, <code>persistent</code>, and <code>interval</code>, a polling\nvalue in milliseconds. The default is <code>{ persistent: true, interval: 0 }</code>.\n\n</p>\n<p>The <code>listener</code> gets two arguments the current stat object and the previous\nstat object:\n\n</p>\n<pre><code>fs.watchFile(f, function (curr, prev) {\n  console.log(&apos;the current mtime is: &apos; + curr.mtime);\n  console.log(&apos;the previous mtime was: &apos; + prev.mtime);\n});</code></pre>\n<p>These stat objects are instances of <code>fs.Stat</code>.\n\n</p>\n<p>If you want to be notified when the file was modified, not just accessed\nyou need to compare <code>curr.mtime</code> and `prev.mtime.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "listener"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unwatchFile(filename)",
          "type": "method",
          "name": "unwatchFile",
          "desc": "<p>Stop watching for changes on <code>filename</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createReadStream(path, [options])",
          "type": "method",
          "name": "createReadStream",
          "desc": "<p>Returns a new ReadStream object (See <code>Readable Stream</code>).\n\n</p>\n<p><code>options</code> is an object with the following defaults:\n\n</p>\n<pre><code>{ flags: &apos;r&apos;,\n  encoding: null,\n  fd: null,\n  mode: 0666,\n  bufferSize: 64 * 1024\n}</code></pre>\n<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from\nthe file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and\nstart at 0.  When used, both the limits must be specified always.\n\n</p>\n<p>An example to read the last 10 bytes of a file which is 100 bytes long:\n\n</p>\n<pre><code>fs.createReadStream(&apos;sample.txt&apos;, {start: 90, end: 99});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createWriteStream(path, [options])",
          "type": "method",
          "name": "createWriteStream",
          "desc": "<p>Returns a new WriteStream object (See <code>Writable Stream</code>).\n\n</p>\n<p><code>options</code> is an object with the following defaults:\n\n</p>\n<pre><code>{ flags: &apos;w&apos;,\n  encoding: null,\n  mode: 0666 }</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "fs.Stats",
          "name": "Stats",
          "desc": "<p>Objects returned from <code>fs.stat()</code> and <code>fs.lstat()</code> are of this type.\n\n</p>\n<ul>\n<li><code>stats.isFile()</code></li>\n<li><code>stats.isDirectory()</code></li>\n<li><code>stats.isBlockDevice()</code></li>\n<li><code>stats.isCharacterDevice()</code></li>\n<li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li>\n<li><code>stats.isFIFO()</code></li>\n<li><code>stats.isSocket()</code></li>\n</ul>\n"
        },
        {
          "textRaw": "fs.ReadStream",
          "name": "ReadStream",
          "desc": "<p><code>ReadStream</code> is a <code>Readable Stream</code>.\n\n</p>\n"
        },
        {
          "textRaw": "fs.WriteStream",
          "name": "WriteStream",
          "desc": "<p><code>WriteStream</code> is a <code>Writable Stream</code>.\n\n</p>\n"
        }
      ],
      "events": [
        {
          "textRaw": "Event: 'open'",
          "type": "event",
          "name": "open",
          "desc": "<p><code>function (fd) { }</code>\n\n</p>\n<p> <code>fd</code> is the file descriptor used by the WriteStream.\n\n</p>\n",
          "params": []
        }
      ],
      "type": "module",
      "displayName": "File System"
    },
    {
      "textRaw": "Path",
      "name": "path",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>Este módulo contiene utilidades para trabajar con rutas de fichero.\nCasi todos los métodos llevan sólo una transformaciones en el string.\nEl sistema de archivos no es consulta para comprobar si las rutas son válidos.\n\n</p>\n<p>Utilice <code>require(&apos;path&apos;)</code> para utilizarlo.  Los siguientes métodos son provistos:\n\n</p>\n",
      "methods": [
        {
          "textRaw": "path.normalize(p)",
          "type": "method",
          "name": "normalize",
          "desc": "<p>Normaliza la cadena de texto de una ruta, se encarga de las partes <code>&apos;..&apos;</code> y <code>&apos;.&apos;</code>.\n\n</p>\n<p>Cuando se encuentra múltiples barras, se reemplazan por una sola;\ncuando la ruta acaba en barra, se conserva.\nEn windows se utilizan contrabarras.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;)\n// returns\n&apos;/foo/bar/baz/asdf&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.join([path1], [path2], [...])",
          "type": "method",
          "name": "join",
          "desc": "<p>Junta todos los argumentos y normaliza la ruta resultante.\nNon-string arguments are ignored.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;)\n// returns\n&apos;/foo/bar/baz/asdf&apos;\n\npath.join(&apos;foo&apos;, {}, &apos;bar&apos;)\n// returns\n&apos;foo/bar&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path1",
                  "optional": true
                },
                {
                  "name": "path2",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.resolve([from ...], to)",
          "type": "method",
          "name": "resolve",
          "desc": "<p>Resuelve <code>to</code> a una ruta absoluta.\n\n</p>\n<p>If <code>to</code> isn&apos;t already absolute <code>from</code> arguments are prepended in right to left\norder, until an absolute path is found. If after using all <code>from</code> paths still\nno absolute path is found, the current working directory is used as well. The\nresulting path is normalized, and trailing slashes are removed unless the path \ngets resolved to the root directory. Non-string arguments are ignored.\n\n</p>\n<p>Si <code>to</code> no es absoluta los argumentos <code>from</code> se anteponen ordenados de derecha a \nizquierda, hasta que se encuentra una ruta absoluta. Si después de usar todas las rutas de <code>from</code> \naún no se encuentra una ruta absoluta, también se utiliza el directorio actual de trabajo. La \nruta resultante se normaliza, y se eliminan las barras finales a no ser que \nse resuelva el directorio root.\n\n</p>\n<p>Otra manera de verlo es como una secuencia de comandos <code>cd</code> en un shell.\n\n</p>\n<pre><code>path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</code></pre>\n<p>Es como:\n\n</p>\n<pre><code>cd foo/bar\ncd /tmp/file/\ncd ..\ncd a/../subfile\npwd</code></pre>\n<p>La diferencia es que las distintas rutas no necesitan existir e incluso pueden \nser ficheros.\n\n</p>\n<p>Ejemplos:\n\n</p>\n<pre><code>path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)\n// returns\n&apos;/foo/bar/baz&apos;\n\npath.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)\n// returns\n&apos;/tmp/file&apos;\n\npath.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)\n// if currently in /home/myself/node, it returns\n&apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from ...",
                  "optional": true
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.relative(from, to)",
          "type": "method",
          "name": "relative",
          "desc": "<p>Solve the relative path from <code>from</code> to <code>to</code>.\n\n</p>\n<p>At times we have two absolute paths, and we need to derive the relative\npath from one to the other.  This is actually the reverse transform of\n<code>path.resolve</code>, which means we see that:\n\n</p>\n<pre><code>path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>\n<p>Ejemplos:\n\n</p>\n<pre><code>path.relative(&apos;C:\\\\orandea\\\\test\\\\aaa&apos;, &apos;C:\\\\orandea\\\\impl\\\\bbb&apos;)\n// returns\n&apos;..\\\\..\\\\impl\\\\bbb&apos;\n\npath.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;)\n// returns\n&apos;../../impl/bbb&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from"
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.dirname(p)",
          "type": "method",
          "name": "dirname",
          "desc": "<p>Devuelve el nombre de directorio de una ruta.  Semejante al comando de Unix <code>dirname</code>.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>path.dirname(&apos;/foo/bar/baz/asdf/quux&apos;)\n// returns\n&apos;/foo/bar/baz/asdf&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.basename(p, [ext])",
          "type": "method",
          "name": "basename",
          "desc": "<p>Devuelve la última parte de una ruta.  Semejante al comando de Unix <code>basename</code>.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;)\n// returns\n&apos;quux.html&apos;\n\npath.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;, &apos;.html&apos;)\n// returns\n&apos;quux&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                },
                {
                  "name": "ext",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.extname(p)",
          "type": "method",
          "name": "extname",
          "desc": "<p>Devuelve la extensión de la ruta.  Todo lo que hay después del último &apos;.&apos; \nen la última parte de la ruta. Si no hay &apos;.&apos; en la última parte de la ruta o el único \n&apos;.&apos; es el primer carácter, entonces devuelve un string vacío.  Ejemplos:\n\n</p>\n<pre><code>path.extname(&apos;index.html&apos;)\n// returns\n&apos;.html&apos;\n\npath.extname(&apos;index.&apos;)\n// returns\n&apos;.&apos;\n\npath.extname(&apos;index&apos;)\n// returns\n&apos;&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Path"
    },
    {
      "textRaw": "net",
      "name": "net",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains\nmethods for creating both servers and clients (called streams). You can include\nthis module with <code>require(&apos;net&apos;);</code>\n\n</p>\n",
      "methods": [
        {
          "textRaw": "net.createServer([options], [connectionListener])",
          "type": "method",
          "name": "createServer",
          "desc": "<p>Creates a new TCP server. The <code>connectionListener</code> argument is\nautomatically set as a listener for the <a href=\"#event_connection_\">&apos;connection&apos;</a>\nevent.\n\n</p>\n<p><code>options</code> is an object with the following defaults:\n\n</p>\n<pre><code>{ allowHalfOpen: false\n}</code></pre>\n<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won&apos;t automatically send a FIN\npacket when the other end of the socket sends a FIN packet. The socket becomes\nnon-readable, but still writable. You should call the <code>end()</code> method explicitly.\nSee <a href=\"#event_end_\">&apos;end&apos;</a> event for more information.\n\n</p>\n<p>Here is an example of a echo server which listens for connections\non port 8124:\n\n</p>\n<pre><code>var net = require(&apos;net&apos;);\nvar server = net.createServer(function(c) { //&apos;connection&apos; listener\n  console.log(&apos;server connected&apos;);\n  c.on(&apos;end&apos;, function() {\n    console.log(&apos;server disconnected&apos;);\n  });\n  c.write(&apos;hello\\r\\n&apos;);\n  c.pipe(c);\n});\nserver.listen(8124, function() { //&apos;listening&apos; listener\n  console.log(&apos;server bound&apos;);\n});</code></pre>\n<p>Test this by using <code>telnet</code>:\n\n</p>\n<pre><code>telnet localhost 8124</code></pre>\n<p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would\njust be changed to\n\n</p>\n<pre><code>server.listen(&apos;/tmp/echo.sock&apos;, function() { //&apos;listening&apos; listener</code></pre>\n<p>Use <code>nc</code> to connect to a UNIX domain socket server:\n\n</p>\n<pre><code>nc -U /tmp/echo.sock</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(options, [connectionListener])",
          "type": "method",
          "name": "connect",
          "desc": "<p>Constructs a new socket object and opens the socket to the given location.\nWhen the socket is established, the <a href=\"#event_connect_\">&apos;connect&apos;</a> event will be\nemitted.\n\n</p>\n<p>For TCP sockets, <code>options</code> argument should be an object which specifies:\n\n</p>\n<ul>\n<li><p><code>port</code>: Port the client should connect to (Required).</p>\n</li>\n<li><p><code>host</code>: Host the client should connect to. Defaults to <code>&apos;localhost&apos;</code>.</p>\n</li>\n</ul>\n<p>For UNIX domain sockets, <code>options</code> argument should be an object which specifies:\n\n</p>\n<ul>\n<li><code>path</code>: Path the client should connect to (Required).</li>\n</ul>\n<p>Common options are:\n\n</p>\n<ul>\n<li><code>allowHalfOpen</code>: if <code>true</code>, the socket won&apos;t automatically send\na FIN packet when the other end of the socket sends a FIN packet.\nDefaults to <code>false</code>.\nSee <a href=\"#event_end_\">&apos;end&apos;</a> event for more information.</li>\n</ul>\n<p>The <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n</p>\n<p>Here is an example of a client of echo server as described previously:\n\n</p>\n<pre><code>var net = require(&apos;net&apos;);\nvar client = net.connect({port: 8124},\n    function() { //&apos;connect&apos; listener\n  console.log(&apos;client connected&apos;);\n  client.write(&apos;world!\\r\\n&apos;);\n});\nclient.on(&apos;data&apos;, function(data) {\n  console.log(data.toString());\n  client.end();\n});\nclient.on(&apos;end&apos;, function() {\n  console.log(&apos;client disconnected&apos;);\n});</code></pre>\n<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be\nchanged to\n\n</p>\n<pre><code>var client = net.connect({path: &apos;/tmp/echo.sock&apos;},</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(options, [connectionListener])",
          "type": "method",
          "name": "createConnection",
          "desc": "<p>Constructs a new socket object and opens the socket to the given location.\nWhen the socket is established, the <a href=\"#event_connect_\">&apos;connect&apos;</a> event will be\nemitted.\n\n</p>\n<p>For TCP sockets, <code>options</code> argument should be an object which specifies:\n\n</p>\n<ul>\n<li><p><code>port</code>: Port the client should connect to (Required).</p>\n</li>\n<li><p><code>host</code>: Host the client should connect to. Defaults to <code>&apos;localhost&apos;</code>.</p>\n</li>\n</ul>\n<p>For UNIX domain sockets, <code>options</code> argument should be an object which specifies:\n\n</p>\n<ul>\n<li><code>path</code>: Path the client should connect to (Required).</li>\n</ul>\n<p>Common options are:\n\n</p>\n<ul>\n<li><code>allowHalfOpen</code>: if <code>true</code>, the socket won&apos;t automatically send\na FIN packet when the other end of the socket sends a FIN packet.\nDefaults to <code>false</code>.\nSee <a href=\"#event_end_\">&apos;end&apos;</a> event for more information.</li>\n</ul>\n<p>The <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n</p>\n<p>Here is an example of a client of echo server as described previously:\n\n</p>\n<pre><code>var net = require(&apos;net&apos;);\nvar client = net.connect({port: 8124},\n    function() { //&apos;connect&apos; listener\n  console.log(&apos;client connected&apos;);\n  client.write(&apos;world!\\r\\n&apos;);\n});\nclient.on(&apos;data&apos;, function(data) {\n  console.log(data.toString());\n  client.end();\n});\nclient.on(&apos;end&apos;, function() {\n  console.log(&apos;client disconnected&apos;);\n});</code></pre>\n<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be\nchanged to\n\n</p>\n<pre><code>var client = net.connect({path: &apos;/tmp/echo.sock&apos;},</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(port, [host], [connectListener])",
          "type": "method",
          "name": "connect",
          "desc": "<p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted,\n<code>&apos;localhost&apos;</code> will be assumed.\nThe <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(port, [host], [connectListener])",
          "type": "method",
          "name": "createConnection",
          "desc": "<p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted,\n<code>&apos;localhost&apos;</code> will be assumed.\nThe <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(path, [connectListener])",
          "type": "method",
          "name": "connect",
          "desc": "<p>Creates unix socket connection to <code>path</code>.\nThe <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(path, [connectListener])",
          "type": "method",
          "name": "createConnection",
          "desc": "<p>Creates unix socket connection to <code>path</code>.\nThe <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIP(input)",
          "type": "method",
          "name": "isIP",
          "desc": "<p>Tests if input is an IP address. Returns 0 for invalid strings,\nreturns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv4(input)",
          "type": "method",
          "name": "isIPv4",
          "desc": "<p>Returns true if input is a version 4 IP address, otherwise returns false.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv6(input)",
          "type": "method",
          "name": "isIPv6",
          "desc": "<p>Returns true if input is a version 6 IP address, otherwise returns false.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: net.Server",
          "type": "class",
          "name": "net.Server",
          "desc": "<p>This class is used to create a TCP or UNIX server.\nA server is a <code>net.Socket</code> that can listen for new incoming connections.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "server.listen(port, [host], [listeningListener])",
              "type": "method",
              "name": "listen",
              "desc": "<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the\n<code>host</code> is omitted, the server will accept connections directed to any\nIPv4 address (<code>INADDR_ANY</code>). A port value of zero will assign a random port.\n\n</p>\n<p>This function is asynchronous.  When the server has been bound,\n<a href=\"#event_listening_\">&apos;listening&apos;</a> event will be emitted.\nthe last parameter <code>listeningListener</code> will be added as an listener for the\n<a href=\"#event_listening_\">&apos;listening&apos;</a> event.\n\n</p>\n<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. This means that\nanother server is already running on the requested port. One way of handling this\nwould be to wait a second and then try again. This can be done with\n\n</p>\n<pre><code>server.on(&apos;error&apos;, function (e) {\n  if (e.code == &apos;EADDRINUSE&apos;) {\n    console.log(&apos;Address in use, retrying...&apos;);\n    setTimeout(function () {\n      server.close();\n      server.listen(PORT, HOST);\n    }, 1000);\n  }\n});</code></pre>\n<p>(Note: All sockets in Node set <code>SO_REUSEADDR</code> already)\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "listeningListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(path, [listeningListener])",
              "type": "method",
              "name": "listen",
              "desc": "<p>Start a UNIX socket server listening for connections on the given <code>path</code>.\n\n</p>\n<p>This function is asynchronous.  When the server has been bound,\n<a href=\"#event_listening_\">&apos;listening&apos;</a> event will be emitted.\nthe last parameter <code>listeningListener</code> will be added as an listener for the\n<a href=\"#event_listening_\">&apos;listening&apos;</a> event.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "listeningListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.close([cb])",
              "type": "method",
              "name": "close",
              "desc": "<p>Stops the server from accepting new connections. This function is\nasynchronous, the server is finally closed when the server emits a <code>&apos;close&apos;</code>\nevent. Optionally, you can pass a callback to listen for the <code>&apos;close&apos;</code> event.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "cb",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.address()",
              "type": "method",
              "name": "address",
              "desc": "<p>Returns the bound address and port of the server as reported by the operating system.\nUseful to find which port was assigned when giving getting an OS-assigned address.\nReturns an object with two properties, e.g. <code>{&quot;address&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:2121}</code>\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var server = net.createServer(function (socket) {\n  socket.end(&quot;goodbye\\n&quot;);\n});\n\n// grab a random port.\nserver.listen(function() {\n  address = server.address();\n  console.log(&quot;opened server on %j&quot;, address);\n});</code></pre>\n<p>Don&apos;t call <code>server.address()</code> until the <code>&apos;listening&apos;</code> event has been emitted.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "server.maxConnections",
              "name": "maxConnections",
              "desc": "<p>Set this property to reject connections when the server&apos;s connection count gets\nhigh.\n\n</p>\n"
            },
            {
              "textRaw": "server.connections",
              "name": "connections",
              "desc": "<p>The number of concurrent connections on the server.\n\n\n</p>\n<p><code>net.Server</code> is an <code>EventEmitter</code> with the following events:\n\n</p>\n"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "desc": "<p>Emitted when the server has been bound after calling <code>server.listen</code>.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connection'",
              "type": "event",
              "name": "connection",
              "params": [],
              "desc": "<p>Emitted when a new connection is made. <code>socket</code> is an instance of\n<code>net.Socket</code>.\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p>Emitted when the server closes.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly\nfollowing this event.  See example in discussion of <code>server.listen</code>.\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: net.Socket",
          "type": "class",
          "name": "net.Socket",
          "desc": "<p>This object is an abstraction of a TCP or UNIX socket.  <code>net.Socket</code>\ninstances implement a duplex Stream interface.  They can be created by the\nuser and used as a client (with <code>connect()</code>) or they can be created by Node\nand passed to the user through the <code>&apos;connection&apos;</code> event of a server.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "new net.Socket([options])",
              "type": "method",
              "name": "Socket",
              "desc": "<p>Construct a new socket object.\n\n</p>\n<p><code>options</code> is an object with the following defaults:\n\n</p>\n<pre><code>{ fd: null\n  type: null\n  allowHalfOpen: false\n}</code></pre>\n<p><code>fd</code> allows you to specify the existing file descriptor of socket. <code>type</code>\nspecified underlying protocol. It can be <code>&apos;tcp4&apos;</code>, <code>&apos;tcp6&apos;</code>, or <code>&apos;unix&apos;</code>.\nAbout <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>&apos;end&apos;</code> event.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.connect(port, [host], [connectListener])",
              "type": "method",
              "name": "connect",
              "desc": "<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,\nthen the socket will be opened as a TCP socket, if <code>host</code> is omitted,\n<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be\nopened as a unix socket to that path.\n\n</p>\n<p>Normally this method is not needed, as <code>net.createConnection</code> opens the\nsocket. Use this only if you are implementing a custom Socket or if a\nSocket is closed and you want to reuse it to connect to another server.\n\n</p>\n<p>This function is asynchronous. When the <a href=\"#event_connect_\">&apos;connect&apos;</a> event is\nemitted the socket is established. If there is a problem connecting, the\n<code>&apos;connect&apos;</code> event will not be emitted, the <code>&apos;error&apos;</code> event will be emitted with\nthe exception.\n\n</p>\n<p>The <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.connect(path, [connectListener])",
              "type": "method",
              "name": "connect",
              "desc": "<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,\nthen the socket will be opened as a TCP socket, if <code>host</code> is omitted,\n<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be\nopened as a unix socket to that path.\n\n</p>\n<p>Normally this method is not needed, as <code>net.createConnection</code> opens the\nsocket. Use this only if you are implementing a custom Socket or if a\nSocket is closed and you want to reuse it to connect to another server.\n\n</p>\n<p>This function is asynchronous. When the <a href=\"#event_connect_\">&apos;connect&apos;</a> event is\nemitted the socket is established. If there is a problem connecting, the\n<code>&apos;connect&apos;</code> event will not be emitted, the <code>&apos;error&apos;</code> event will be emitted with\nthe exception.\n\n</p>\n<p>The <code>connectListener</code> parameter will be added as an listener for the\n<a href=\"#event_connect_\">&apos;connect&apos;</a> event.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setEncoding([encoding])",
              "type": "method",
              "name": "setEncoding",
              "desc": "<p>Sets the encoding (either <code>&apos;ascii&apos;</code>, <code>&apos;utf8&apos;</code>, or <code>&apos;base64&apos;</code>) for data that is\nreceived. Defaults to <code>null</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.write(data, [encoding], [callback])",
              "type": "method",
              "name": "write",
              "desc": "<p>Sends data on the socket. The second parameter specifies the encoding in the\ncase of a string--it defaults to UTF8 encoding.\n\n</p>\n<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel\nbuffer. Returns <code>false</code> if all or part of the data was queued in user memory.\n<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.\n\n</p>\n<p>The optional <code>callback</code> parameter will be executed when the data is finally\nwritten out - this may not be immediately.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.end([data], [encoding])",
              "type": "method",
              "name": "end",
              "desc": "<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.\n\n</p>\n<p>If <code>data</code> is specified, it is equivalent to calling\n<code>socket.write(data, encoding)</code> followed by <code>socket.end()</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.destroy()",
              "type": "method",
              "name": "destroy",
              "desc": "<p>Ensures that no more I/O activity happens on this socket. Only necessary in\ncase of errors (parse error or so).\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<p>Pauses the reading of data. That is, <code>&apos;data&apos;</code> events will not be emitted.\nUseful to throttle back an upload.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<p>Resumes reading after a call to <code>pause()</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.setTimeout(timeout, [callback])",
              "type": "method",
              "name": "setTimeout",
              "desc": "<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on\nthe socket. By default <code>net.Socket</code> do not have a timeout.\n\n</p>\n<p>When an idle timeout is triggered the socket will receive a <code>&apos;timeout&apos;</code>\nevent but the connection will not be severed. The user must manually <code>end()</code>\nor <code>destroy()</code> the socket.\n\n</p>\n<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.\n\n</p>\n<p>The optional <code>callback</code> parameter will be added as a one time listener for the\n<code>&apos;timeout&apos;</code> event.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setNoDelay([noDelay])",
              "type": "method",
              "name": "setNoDelay",
              "desc": "<p>Disables the Nagle algorithm. By default TCP connections use the Nagle\nalgorithm, they buffer data before sending it off. Setting <code>true</code> for\n<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.\n<code>noDelay</code> defaults to <code>true</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setKeepAlive([enable], [initialDelay])",
              "type": "method",
              "name": "setKeepAlive",
              "desc": "<p>Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n<code>enable</code> defaults to <code>false</code>.\n\n</p>\n<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting 0 for\ninitialDelay will leave the value unchanged from the default\n(or previous) setting. Defaults to <code>0</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.address()",
              "type": "method",
              "name": "address",
              "desc": "<p>Returns the bound address and port of the socket as reported by the operating\nsystem. Returns an object with two properties, e.g.\n<code>{&quot;address&quot;:&quot;192.168.57.1&quot;, &quot;port&quot;:62053}</code>\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "socket.bufferSize",
              "name": "bufferSize",
              "desc": "<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket - the network connection\nsimply might be too slow. Node will internally queue up the data written to a\nsocket and send it out over the wire when it is possible. (Internally it is\npolling on the socket&apos;s file descriptor for being writable).\n\n</p>\n<p>The consequence of this internal buffering is that memory may grow. This\nproperty shows the number of characters currently buffered to be written.\n(Number of characters is approximately equal to the number of bytes to be\nwritten, but the buffer may contain strings, and the strings are lazily\nencoded, so the exact number of bytes is not known.)\n\n</p>\n<p>Users who experience large or growing <code>bufferSize</code> should attempt to\n&quot;throttle&quot; the data flows in their program with <code>pause()</code> and <code>resume()</code>.\n\n\n</p>\n"
            },
            {
              "textRaw": "socket.remoteAddress",
              "name": "remoteAddress",
              "desc": "<p>The string representation of the remote IP address. For example,\n<code>&apos;74.125.127.100&apos;</code> or <code>&apos;2001:4860:a005::68&apos;</code>.\n\n</p>\n"
            },
            {
              "textRaw": "socket.remotePort",
              "name": "remotePort",
              "desc": "<p>The numeric representation of the remote port. For example,\n<code>80</code> or <code>21</code>.\n\n</p>\n"
            },
            {
              "textRaw": "socket.bytesRead",
              "name": "bytesRead",
              "desc": "<p>The amount of received bytes.\n\n</p>\n"
            },
            {
              "textRaw": "socket.bytesWritten",
              "name": "bytesWritten",
              "desc": "<p>The amount of bytes sent.\n\n\n</p>\n<p><code>net.Socket</code> instances are EventEmitters with the following events:\n\n</p>\n"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "desc": "<p>Emitted when a socket connection is successfully established.\nSee <code>connect()</code>.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "params": [],
              "desc": "<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or\n<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.\n(See the <a href=\"stream.html#readable_stream\">Readable Stream</a> section for more\ninformation.)\n\n</p>\n<p>Note that the <strong>data will be lost</strong> if there is no listener when a <code>Socket</code>\nemits a <code>&apos;data&apos;</code> event.\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<p>Emitted when the other end of the socket sends a FIN packet.\n\n</p>\n<p>By default (<code>allowHalfOpen == false</code>) the socket will destroy its file\ndescriptor  once it has written out its pending write queue.  However, by\nsetting <code>allowHalfOpen == true</code> the socket will not automatically <code>end()</code>\nits side allowing the user to write arbitrary amounts of data, with the\ncaveat that the user is required to <code>end()</code> their side now.\n\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'timeout'",
              "type": "event",
              "name": "timeout",
              "desc": "<p>Emitted if the socket times out from inactivity. This is only to notify that\nthe socket has been idle. The user must manually close the connection.\n\n</p>\n<p>See also: <code>socket.setTimeout()</code>\n\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "desc": "<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.\n\n</p>\n<p>See also: the return values of <code>socket.write()</code>\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly\nfollowing this event.\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "params": [],
              "desc": "<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean\nwhich says if the socket was closed due to a transmission error.\n\n</p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "net"
    },
    {
      "textRaw": "UDP / Sockets de Datagrama",
      "name": "dgram",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>Los sockets de datagrama están disponibles a través de <code>require(&apos;dgram&apos;)</code>.  Normalmente los datagramas \nse manejan como mensajes IP/UDP pero también se pueden usar a través de sockets de dominio Unix.\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Evento: 'message'",
          "name": "evento:_'message'",
          "desc": "<p><code>function (msg, rinfo) { }</code>\n\n</p>\n<p>Emitido cuando está disponible un nuevo datagrama en el socket.  <code>msg es un </code>Buffer<code> y </code>rinfo` es \nun objeto con la dirección de quien lo envía y el número de bytes que contiene el datagrama.\n\n</p>\n",
          "modules": [
            {
              "textRaw": "Evento: 'listening'",
              "name": "evento:_'listening'",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<p>Emitido cuando un socket empieza a escuchar la llegada de datagramas.  Esto ocurre tan pronto como \nson creados los sockets UDP.  Los sockets de dominio Unix no empiezan a escuchar hasta que se llama \nimplícitamente a <code>bind()</code>.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'listening'"
            }
          ],
          "type": "module",
          "displayName": "Evento: 'message'"
        },
        {
          "textRaw": "Evento: 'close'",
          "name": "evento:_'close'",
          "desc": "<p><code>function () { }</code>\n\n</p>\n<p>Emitido cuando se cierra un socket con <code>close()</code>. No se emitirán nuevos <code>message</code>en este \nsocket.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "dgram.createSocket(type, [callback])",
              "type": "method",
              "name": "createSocket",
              "desc": "<p>Crea un socket de datagrama del tipo especificado.  Los tipos válidos son:\n<code>udp4</code>, <code>udp6</code> y <code>unix_dgram</code>.\n\n</p>\n<p>Recibe un callback opcional que se añade como listener de los eventos <code>message</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "type"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "dgram.send(buf, offset, length, path, [callback])",
              "type": "method",
              "name": "send",
              "desc": "<p>Para los sockets de datagrama del dominio Unix, la dirección de destion es un nombre de ruta \nen sistema de ficheros. Se puede pasar un callback opcional que se invoca cuando se completa la llamada \na <code>sendto</code> por parte del SO. No es seguro reutilizar <code>buf</code> hasta que se ha invocado el callback. Hay \nque tener en cuenta que a no ser que el socket este asociado a un nombre de ruta con <code>bind()</code> no hay manera \nde recibir mensajes en el socket.\n\n</p>\n<p>Ejemplo de envío de un mensaje al syslogd en OSX via un socket de dominio Unix <code>/var/run/syslog</code>:\n\n</p>\n<pre><code>var dgram = require(&apos;dgram&apos;);\nvar message = new Buffer(&quot;Un mensaje de log.&quot;);\nvar client = dgram.createSocket(&quot;unix_dgram&quot;);\nclient.send(message, 0, message.length, &quot;/var/run/syslog&quot;,\n  function (err, bytes) {\n    if (err) {\n      throw err;\n    }\n    console.log(&quot;Se han escrito &quot; + bytes + &quot; bytes en el socket.&quot;);\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "length"
                    },
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "Evento: 'close'"
        }
      ],
      "methods": [
        {
          "textRaw": "dgram.send(buf, offset, length, port, address, [callback])",
          "type": "method",
          "name": "send",
          "desc": "<p>Para los sockets UDP, el puerto y la dirección IP de destino tienen que especificarse.  Se \npuede pasar un string al parámetro <code>address</code>, y se podrá resolver por DNS.  Se puede especificar \nun callback opcional para detectar cualquier error de DNS y cuando puede volverse a usar <code>buf</code>.<br>Tener en cuenta que las búsquedas de DNS retrasarán el tiempo del envío, al menos hasta el siguiente \ntick.  La única manera de asegurarse de que se ha realizado un envío es mediante el callback.\n\n</p>\n<p>Ejemplo de enviar un paquete UDP a un puerto aleatorio de <code>localhost</code>;\n\n</p>\n<pre><code>var dgram = require(&apos;dgram&apos;);\nvar message = new Buffer(&quot;Algunos bytes&quot;);\nvar client = dgram.createSocket(&quot;udp4&quot;);\nclient.send(message, 0, message.length, 41234, &quot;localhost&quot;);\nclient.close();</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "port"
                },
                {
                  "name": "address"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dgram.bind(path)",
          "type": "method",
          "name": "bind",
          "desc": "<p>Para los sockets de datagrama de dominio Unix, empezar a escuchar datagramas entrantes en \nel socket especificado por <code>path</code>. Notar que los clientes pueden hacer <code>send()</code> sin haber hecho <code>bind()</code>, \npero no se recibirá ningún datagrama sin haber hecho un <code>bind()</code>.\n\n</p>\n<p>Ejemplo de un servidor de datagramas de dominio Unix, que devuelve el eco de los mensajes que recibe:\n\n</p>\n<pre><code>var dgram = require(&quot;dgram&quot;);\nvar serverPath = &quot;/tmp/dgram_server_sock&quot;;\nvar server = dgram.createSocket(&quot;unix_dgram&quot;);\n\nserver.on(&quot;message&quot;, function (msg, rinfo) {\n  console.log(&quot;recibido: &quot; + msg + &quot; de &quot; + rinfo.address);\n  server.send(msg, 0, msg.length, rinfo.address);\n});\n\nserver.on(&quot;listening&quot;, function () {\n  console.log(&quot;servidor escuchando &quot; + server.address().address);\n})\n\nserver.bind(serverPath);</code></pre>\n<p>Ejemplo de un cliente de datagramas de dominio Unix que habla con el servidor:\n\n</p>\n<pre><code>var dgram = require(&quot;dgram&quot;);\nvar serverPath = &quot;/tmp/dgram_server_sock&quot;;\nvar clientPath = &quot;/tmp/dgram_client_sock&quot;;\n\nvar message = new Buffer(&quot;Un mensaje el &quot; + (new Date()));\n\nvar client = dgram.createSocket(&quot;unix_dgram&quot;);\n\nclient.on(&quot;message&quot;, function (msg, rinfo) {\n  console.log(&quot;recibido: &quot; + msg + &quot; de &quot; + rinfo.address);\n});\n\nclient.on(&quot;listening&quot;, function () {\n  console.log(&quot;cliente escuchando &quot; + client.address().address);\n  client.send(message, 0, message.length, serverPath);\n});\n\nclient.bind(clientPath);</code></pre>\n",
          "methods": [
            {
              "textRaw": "dgram.bind(port, [address])",
              "type": "method",
              "name": "bind",
              "desc": "<p>Para los sockets UDP, hay que escuhar los datagramas en un <code>port</code> específico y en el <code>address</code> opcional.  Si \nno se especifica <code>address</code>, el SO intentará escuchar en todas las direcciones.\n\n</p>\n<p>Ejemplo de un servidor UDP escuchando en el puerto 41234:\n\n</p>\n<pre><code>var dgram = require(&quot;dgram&quot;);\n\nvar server = dgram.createSocket(&quot;udp4&quot;);\n\nserver.on(&quot;message&quot;, function (msg, rinfo) {\n  console.log(&quot;el servidor ha recibido: &quot; + msg + &quot; de &quot; +\n    rinfo.address + &quot;:&quot; + rinfo.port);\n});\n\nserver.on(&quot;listening&quot;, function () {\n  var address = server.address();\n  console.log(&quot;servidor escuchando &quot; +\n      address.address + &quot;:&quot; + address.port);\n});\n\nserver.bind(41234);\n// server listening 0.0.0.0:41234</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "address",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dgram.close()",
          "type": "method",
          "name": "close",
          "desc": "<p>Cierra el socket subyacente y para de escuchar datos en él.  Los sockets UDP \nautomáticamente se ponen a escuchar mensjaes, incluso si no han llamado a <code>bind()</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "dgram.address()",
              "type": "method",
              "name": "address",
              "desc": "<p>Devuelve un objeto que contiene la información de la dirección de un socket.  Para los sockets \nUDP, este objeto contendrá la <code>address</code> y el <code>port</code>.  Para los sockets de dominio Unix, solo contendrá \nla <code>address</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "dgram.setBroadcast(flag)",
              "type": "method",
              "name": "setBroadcast",
              "desc": "<p>Establece o borra la opción del socket <code>SO_BROADCAST</code>.  Cuando se activa esta opción, los \npaquetes UDP se pueden enviar una dirección de broadcast de un interfaz local.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "flag"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "dgram.setTTL(ttl)",
          "type": "method",
          "name": "setTTL",
          "desc": "<p>Establece la opción de socket <code>IP_TTL</code>.  TTL significa &quot;Time to Live&quot;, pero en este contexto \nespecifica el número de saltos IP que se permite hacer al paquete.  Cada router o gateway que \nreenvíe un paquete decrementa el TTL.  Si un router decrementa el TTL a 0, no se reenviará.<br>El cambio de los valores del TTL es un uso típico para probar la red o con multicasting.\n\n</p>\n<p>El argumento que se le pasa a <code>setTTL()</code>es el número de saltos entre 1 y 255.  Por defecto \nen la mayoría de sistemas es 64.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "dgram.setMulticastTTL(ttl)",
              "type": "method",
              "name": "setMulticastTTL",
              "desc": "<p>Establece la opción de socket <code>IP_MULTICAST_TTL</code>. TTL significa &quot;Time to Live&quot;, pero en este contexto \nespecifica el número de saltos IP que se permite hacer al paquete.  Cada router o gateway que \nreenvíe un paquete decrementa el TTL.  Si un router decrementa el TTL a 0, no se reenviará.  \n\n</p>\n<p>El argumento que se le pasa a <code>setMulticastTTL()</code> es el número de saltos entre 0 y 255.  Por defecto \nen la mayoría de sistemas es 64.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "ttl"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "dgram.setMulticastLoopback(flag)",
              "type": "method",
              "name": "setMulticastLoopback",
              "desc": "<p>Establece o borra la opción de socket <code>IP_MULTICAST_LOOP</code>.  Cuand esta opción está activa,<br>también se recibirán paquetes multicast en el interfaz local. \n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "flag"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "ttl"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dgram.addMembership(multicastAddress, [multicastInterface])",
          "type": "method",
          "name": "addMembership",
          "desc": "<p>Comunica al kernel la suscripción a un grupo multicast con la opción de socket <code>IP_ADD_MEMBERSHIP</code>. \n\n</p>\n<p>Si no se especifica <code>multicastAddress</code>, el SO intentará suscribir todos los interfaces válidos.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "multicastAddress"
                },
                {
                  "name": "multicastInterface",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dgram.dropMembership(multicastAddress, [multicastInterface])",
          "type": "method",
          "name": "dropMembership",
          "desc": "<p>El contrario de <code>addMembership</code> - comunica al kernel el abandono de un grupo multicast con \nla opción de socket <code>IP_DROP_MEMBERSHIP</code>. Este método se llama automáticamente por el kernel \ncuando se cierra el socket o el proceso termina, así que la mayoría de aplicaciones nunca tendrán \nque llamarlo. \n\n</p>\n<p>Si no se especifica <code>multicastAddress</code>, el SO intentará suscribir todos los interfaces válidos.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "multicastAddress"
                },
                {
                  "name": "multicastInterface",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "dgram"
    },
    {
      "textRaw": "DNS",
      "name": "dns",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>Use <code>require(&apos;dns&apos;)</code> to access this module. All methods in the dns module\nuse C-Ares except for <code>dns.lookup</code> which uses <code>getaddrinfo(3)</code> in a thread\npool. C-Ares is much faster than <code>getaddrinfo</code> but the system resolver is\nmore constant with how other programs operate. When a user does\n<code>net.connect(80, &apos;google.com&apos;)</code> or <code>http.get({ host: &apos;google.com&apos; })</code> the\n<code>dns.lookup</code> method is used. Users who need to do a large number of look ups\nquickly should use the methods that go through C-Ares.\n\n</p>\n<p>Here is an example which resolves <code>&apos;www.google.com&apos;</code> then reverse\nresolves the IP addresses which are returned.\n\n</p>\n<pre><code>var dns = require(&apos;dns&apos;);\n\ndns.resolve4(&apos;www.google.com&apos;, function (err, addresses) {\n  if (err) throw err;\n\n  console.log(&apos;addresses: &apos; + JSON.stringify(addresses));\n\n  addresses.forEach(function (a) {\n    dns.reverse(a, function (err, domains) {\n      if (err) {\n        console.log(&apos;reverse for &apos; + a + &apos; failed: &apos; +\n          err.message);\n      } else {\n        console.log(&apos;reverse for &apos; + a + &apos;: &apos; +\n          JSON.stringify(domains));\n      }\n    });\n  });\n});</code></pre>\n",
      "methods": [
        {
          "textRaw": "dns.lookup(domain, [family], callback)",
          "type": "method",
          "name": "lookup",
          "desc": "<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into the first found A (IPv4) or\nAAAA (IPv6) record.\nThe <code>family</code> can be the integer <code>4</code> or <code>6</code>. Defaults to <code>null</code> that indicates\nboth Ip v4 and v6 address family.\n\n</p>\n<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument\nis a string representation of a IP v4 or v6 address. The <code>family</code> argument\nis either the integer 4 or 6 and denotes the family of <code>address</code> (not\nnecessarily the value initially passed to <code>lookup</code>).\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "family",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve(domain, [rrtype], callback)",
          "type": "method",
          "name": "resolve",
          "desc": "<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into an array of the record types\nspecified by rrtype. Valid rrtypes are <code>&apos;A&apos;</code> (IPV4 addresses, default),\n<code>&apos;AAAA&apos;</code> (IPV6 addresses), <code>&apos;MX&apos;</code> (mail exchange records), <code>&apos;TXT&apos;</code> (text\nrecords), <code>&apos;SRV&apos;</code> (SRV records), <code>&apos;PTR&apos;</code> (used for reverse IP lookups),\n<code>&apos;NS&apos;</code> (name server records) and <code>&apos;CNAME&apos;</code> (canonical name records).\n\n</p>\n<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item\nin <code>addresses</code> is determined by the record type, and described in the\ndocumentation for the corresponding lookup methods below.\n\n</p>\n<p>On error, <code>err</code> would be an instanceof <code>Error</code> object, where <code>err.errno</code> is\none of the error codes listed below and <code>err.message</code> is a string describing\nthe error in English.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "rrtype",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve4(domain, callback)",
          "type": "method",
          "name": "resolve4",
          "desc": "<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).\n<code>addresses</code> is an array of IPv4 addresses (e.g.\n<code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve6(domain, callback)",
          "type": "method",
          "name": "resolve6",
          "desc": "<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveMx(domain, callback)",
          "type": "method",
          "name": "resolveMx",
          "desc": "<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).\n\n</p>\n<p><code>addresses</code> is an array of MX records, each with a priority and an exchange\nattribute (e.g. <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveTxt(domain, callback)",
          "type": "method",
          "name": "resolveTxt",
          "desc": "<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).\n<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,\n<code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveSrv(domain, callback)",
          "type": "method",
          "name": "resolveSrv",
          "desc": "<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).\n<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties\nof SRV records are priority, weight, port, and name (e.g.,\n<code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.reverse(ip, callback)",
          "type": "method",
          "name": "reverse",
          "desc": "<p>Reverse resolves an ip address to an array of domain names.\n\n</p>\n<p>The callback has arguments <code>(err, domains)</code>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "ip"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveNs(domain, callback)",
          "type": "method",
          "name": "resolveNs",
          "desc": "<p>The same as <code>dns.resolve()</code>, but only for name server records (<code>NS</code> records).\n<code>addresses</code> is an array of the name server records available for <code>domain</code>\n(e.g., <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveCname(domain, callback)",
          "type": "method",
          "name": "resolveCname",
          "desc": "<p>The same as <code>dns.resolve()</code>, but only for canonical name records (<code>CNAME</code>\nrecords). <code>addresses</code> is an array of the canonical name records available for\n<code>domain</code> (e.g., <code>[&apos;bar.example.com&apos;]</code>).\n\n</p>\n<p>If there an an error, <code>err</code> will be non-null and an instanceof the Error\nobject.\n\n</p>\n<p>Each DNS query can return an error code.\n\n</p>\n<ul>\n<li><code>dns.TEMPFAIL</code>: timeout, SERVFAIL or similar.</li>\n<li><code>dns.PROTOCOL</code>: got garbled reply.</li>\n<li><code>dns.NXDOMAIN</code>: domain does not exists.</li>\n<li><code>dns.NODATA</code>: domain exists but no data of reqd type.</li>\n<li><code>dns.NOMEM</code>: out of memory while processing.</li>\n<li><code>dns.BADQUERY</code>: the query is malformed.</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "DNS"
    },
    {
      "textRaw": "HTTP",
      "name": "http",
      "desc": "<p>Para usar el servidor y el cliente HTTP se debe añadir <code>require(&apos;http&apos;)</code>.\n\n</p>\n<p>Las interfaces HTTP en Node están diseñadas para soportar muchas de las características\ndel protocolo que tradicionalmente han sido difíciles de usar.\nEn particular, los mensajes grandes, seguramente fragmentado. La interfaz\nse asegura de que las peticiones o respuestas nunca se almacenen completamente en un búfer--se permite al \nusuario hacer stream de datos.\n\n</p>\n<p>Las cabeceras de los mensajes HTTP se representan por un objeto como este:\n    { &apos;content-length&apos;: &apos;123&apos;,\n      &apos;content-type&apos;: &apos;text/plain&apos;,\n      &apos;connection&apos;: &apos;keep-alive&apos;,\n      &apos;accept&apos;: &apos;<em>/</em>&apos; }\n\n</p>\n<p>Las claves se convierten a minúsculas. Los valores no se modifican.\n\n</p>\n<p>Para soportar el espectro completo de las posibles aplicaciones HTTP, la API \nHTTP de Node es de muy bajo nivel. Se encarga únicamente de manejar el stream y \ndel parsing del mensaje. Parsea el mensaje en sus cabeceras y body pero no parsea \nlas cabeceras o el body.\n\n\n</p>\n",
      "properties": [
        {
          "textRaw": "http.Server",
          "name": "Server",
          "desc": "<p>Es un <code>EventEmitter</code> con los siguientes eventos:\n\n</p>\n",
          "modules": [
            {
              "textRaw": "Evento: 'request'",
              "name": "evento:_'request'",
              "desc": "<p><code>function (request, response) { }</code>\n\n</p>\n<p> <code>request</code> es una instancia de <code>http.ServerRequest</code> y <code>response</code> es una\n instancia de <code>http.ServerResponse</code>\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'request'"
            },
            {
              "textRaw": "Evento: 'connection'",
              "name": "evento:_'connection'",
              "desc": "<p><code>function (stream) { }</code>\n\n</p>\n<p> Cuando se establece un nuevo stream TCP. <code>stream</code> es un objeto de tipo\n<code>net.Stream</code>. Generalmente los usuarios no querrán acceder a este evento. \nTambién se puede acceder el <code>stream</code> desde  <code>request.connection</code>.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'connection'"
            },
            {
              "textRaw": "Evento: 'close'",
              "name": "evento:_'close'",
              "desc": "<p><code>function (errno) { }</code>\n\n</p>\n<p> Emitido cuando se cierra el servidor.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'close'"
            },
            {
              "textRaw": "Evento: 'request'",
              "name": "evento:_'request'",
              "desc": "<p><code>function (request, response) {}</code>\n\n</p>\n<p>Emitido cada vez que se produce una petición. Nótese que pueden producirse múltiples peticiones\npara cada conexión (en el caso de las conexiones keep-alive).\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'request'"
            },
            {
              "textRaw": "Evento: 'checkContinue'",
              "name": "evento:_'checkcontinue'",
              "desc": "<p><code>function (request, response) {}</code>\n\n</p>\n<p>Emitido cada vez que se recibe una petición con un http Expect: 100-continue.\nSi no se está escuchando a este evento, el servidor responderá automáticamente \ncon un 100 Continue.\n\n</p>\n<p>Para tratar este evento se tiene que llamar a <code>response.writeContinue</code> si el cliente \nquisiera seguir con el envío la petición de body, o generar una respuesta HTTP adecuada \n(ej. 400 Bad Request) si el cliente no quisiera continuar con el envío de la petición \ndel body.\n\n</p>\n<p>Tener en cuenta que cuando se emite y se trata este evento, el evento <code>request</code> no se \nemitirá.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'checkContinue'"
            },
            {
              "textRaw": "Evento: 'upgrade'",
              "name": "evento:_'upgrade'",
              "desc": "<p><code>function (request, socket, head)</code>\n\n</p>\n<p>Se emite cada vez que un cliente pide una actualización http. Si este evento no \nse está escuchando, entonces se cerrarán las conexiones de los clientes que esten \npidiendo una actualización.\n\n</p>\n<ul>\n<li><code>request</code> es el argumento para la petición http, como en el evento request.</li>\n<li><code>socket</code> es el socket de red entre el servidor y el cliente.</li>\n<li><code>head</code> es una instancia de Buffer, el primer paquete del stream actualizado, puede estar vacío.</li>\n</ul>\n<p>Después de emitir este evento, el socket de la petición no tendrá un listener del \nevento <code>data</code>, esto significa que necesitarás asociarlo para tratar los datos \nenviados al servidor en ese socket.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'upgrade'"
            },
            {
              "textRaw": "Evento: 'clientError'",
              "name": "evento:_'clienterror'",
              "desc": "<p><code>function (exception) {}</code>\n\n</p>\n<p>Si la conexión de un cliente emite un evento de &apos;error&apos; - será tratado aquí.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento: 'clientError'"
            }
          ],
          "methods": [
            {
              "textRaw": "http.createServer(requestListener)",
              "type": "method",
              "name": "createServer",
              "desc": "<p>Devuelve un nuevo objeto de servidor web.\n\n</p>\n<p><code>requestListener</code> es una función que se añade automáticamente \nal evento <code>&apos;request&apos;</code>. \n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "requestListener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(port, [hostname], [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<p>Begin accepting connections on the specified port and hostname.  If the\nhostname is omitted, the server will accept connections directed to any\nIPv4 address (<code>INADDR_ANY</code>).\n\n</p>\n<p>To listen to a unix socket, supply a filename instead of port and hostname.\n\n</p>\n<p>This function is asynchronous. The last parameter <code>callback</code> will be called\nwhen the server has been bound to the port.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "hostname",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(path, [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<p>Start a UNIX socket server listening for connections on the given <code>path</code>.\n\n</p>\n<p>This function is asynchronous. The last parameter <code>callback</code> will be called\nwhen the server has been bound.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.close()",
              "type": "method",
              "name": "close",
              "desc": "<p>Stops the server from accepting new connections.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.ServerRequest",
          "name": "ServerRequest",
          "desc": "<p>This object is created internally by a HTTP server -- not by\nthe user -- and passed as the first argument to a <code>&apos;request&apos;</code> listener.\n\n</p>\n<p>This is an <code>EventEmitter</code> with the following events:\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "desc": "<p><code>function (chunk) { }</code>\n\n</p>\n<p>Emitted when a piece of the message body is received.\n\n</p>\n<p>Example: A chunk of the body is given as the single\nargument. The transfer-encoding has been decoded.  The\nbody chunk is a string.  The body encoding is set with\n<code>request.setBodyEncoding()</code>.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<p>Emitted exactly once for each message. No arguments.  After\nemitted no other events will be emitted on the request.\n\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "request.method",
              "name": "method",
              "desc": "<p>The request method as a string. Read only. Example:\n<code>&apos;GET&apos;</code>, <code>&apos;DELETE&apos;</code>.\n\n\n</p>\n"
            },
            {
              "textRaw": "request.url",
              "name": "url",
              "desc": "<p>Request URL string. This contains only the URL that is\npresent in the actual HTTP request. If the request is:\n\n</p>\n<pre><code>GET /status?name=ryan HTTP/1.1\\r\\n\nAccept: text/plain\\r\\n\n\\r\\n</code></pre>\n<p>Then <code>request.url</code> will be:\n\n</p>\n<pre><code>&apos;/status?name=ryan&apos;</code></pre>\n<p>If you would like to parse the URL into its parts, you can use\n<code>require(&apos;url&apos;).parse(request.url)</code>.  Example:\n\n</p>\n<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;)\n{ href: &apos;/status?name=ryan&apos;,\n  search: &apos;?name=ryan&apos;,\n  query: &apos;name=ryan&apos;,\n  pathname: &apos;/status&apos; }</code></pre>\n<p>If you would like to extract the params from the query string,\nyou can use the <code>require(&apos;querystring&apos;).parse</code> function, or pass\n<code>true</code> as the second argument to <code>require(&apos;url&apos;).parse</code>.  Example:\n\n</p>\n<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;, true)\n{ href: &apos;/status?name=ryan&apos;,\n  search: &apos;?name=ryan&apos;,\n  query: { name: &apos;ryan&apos; },\n  pathname: &apos;/status&apos; }</code></pre>\n"
            },
            {
              "textRaw": "request.headers",
              "name": "headers",
              "desc": "<p>Read only.\n\n</p>\n"
            },
            {
              "textRaw": "request.trailers",
              "name": "trailers",
              "desc": "<p>Read only; HTTP trailers (if present). Only populated after the &apos;end&apos; event.\n\n</p>\n"
            },
            {
              "textRaw": "request.httpVersion",
              "name": "httpVersion",
              "desc": "<p>The HTTP protocol version as a string. Read only. Examples:\n<code>&apos;1.1&apos;</code>, <code>&apos;1.0&apos;</code>.\nAlso <code>request.httpVersionMajor</code> is the first integer and\n<code>request.httpVersionMinor</code> is the second.\n\n\n</p>\n"
            },
            {
              "textRaw": "request.connection",
              "name": "connection",
              "desc": "<p>The <code>net.Stream</code> object associated with the connection.\n\n\n</p>\n<p>With HTTPS support, use request.connection.verifyPeer() and\nrequest.connection.getPeerCertificate() to obtain the client&apos;s\nauthentication details.\n\n\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "request.setEncoding(encoding=null)",
              "type": "method",
              "name": "setEncoding",
              "desc": "<p>Set the encoding for the request body. Either <code>&apos;utf8&apos;</code> or <code>&apos;binary&apos;</code>. Defaults\nto <code>null</code>, which means that the <code>&apos;data&apos;</code> event will emit a <code>Buffer</code> object..\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "default": "null"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<p>Pauses request from emitting events.  Useful to throttle back an upload.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "request.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<p>Resumes a paused request.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.ServerResponse",
          "name": "ServerResponse",
          "desc": "<p>This object is created internally by a HTTP server--not by the user. It is\npassed as the second parameter to the <code>&apos;request&apos;</code> event. It is a <code>Writable Stream</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "response.writeContinue()",
              "type": "method",
              "name": "writeContinue",
              "desc": "<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the the <code>checkContinue</code> event on\n<code>Server</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "response.writeHead(statusCode, [reasonPhrase], [headers])",
              "type": "method",
              "name": "writeHead",
              "desc": "<p>Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.\nOptionally one can give a human-readable <code>reasonPhrase</code> as the second\nargument.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var body = &apos;hello world&apos;;\nresponse.writeHead(200, {\n  &apos;Content-Length&apos;: body.length,\n  &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>\n<p>This method must only be called once on a message and it must\nbe called before <code>response.end()</code> is called.\n\n</p>\n<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the\nimplicit/mutable headers will be calculated and call this function for you.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "statusCode"
                    },
                    {
                      "name": "reasonPhrase",
                      "optional": true
                    },
                    {
                      "name": "headers",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.setHeader(name, value)",
              "type": "method",
              "name": "setHeader",
              "desc": "<p>Sets a single header value for implicit headers.  If this header already exists\nin the to-be-sent headers, it&apos;s value will be replaced.  Use an array of strings\nhere if you need to send multiple headers with the same name.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>\n<p>or\n\n</p>\n<pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    },
                    {
                      "name": "value"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.getHeader(name)",
              "type": "method",
              "name": "getHeader",
              "desc": "<p>Reads out a header that&apos;s already been queued but not sent to the client.  Note\nthat the name is case insensitive.  This can only be called before headers get\nimplicitly flushed.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.removeHeader(name)",
              "type": "method",
              "name": "removeHeader",
              "desc": "<p>Removes a header that&apos;s queued for implicit sending.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.write(chunk, encoding='utf8')",
              "type": "method",
              "name": "write",
              "desc": "<p>If this method is called and <code>response.writeHead()</code> has not been called, it will\nswitch to implicit header mode and flush the implicit headers.\n\n</p>\n<p>This sends a chunk of the response body. This method may\nbe called multiple times to provide successive parts of the body.\n\n</p>\n<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,\nthe second parameter specifies how to encode it into a byte stream.\nBy default the <code>encoding</code> is <code>&apos;utf8&apos;</code>.\n\n</p>\n<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with\nhigher-level multi-part body encodings that may be used.\n\n</p>\n<p>The first time <code>response.write()</code> is called, it will send the buffered\nheader information and the first body to the client. The second time\n<code>response.write()</code> is called, Node assumes you&apos;re going to be streaming\ndata, and sends that separately. That is, the response is buffered up to the\nfirst chunk of body.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "default": "'utf8'"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.addTrailers(headers)",
              "type": "method",
              "name": "addTrailers",
              "desc": "<p>This method adds HTTP trailing headers (a header but at the end of the\nmessage) to the response.\n\n</p>\n<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the\nresponse; if it is not (e.g., if the request was HTTP/1.0), they will\nbe silently discarded.\n\n</p>\n<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to\nemit trailers, with a list of the header fields in its value. E.g.,\n\n</p>\n<pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,\n                          &apos;Trailer&apos;: &apos;TraceInfo&apos; });\nresponse.write(fileData);\nresponse.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});\nresponse.end();</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "headers"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.end([data], [encoding])",
              "type": "method",
              "name": "end",
              "desc": "<p>This method signals to the server that all of the response headers and body\nhas been sent; that server should consider this message complete.\nThe method, <code>response.end()</code>, MUST be called on each\nresponse.\n\n</p>\n<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>\nfollowed by <code>response.end()</code>.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "response.statusCode",
              "name": "statusCode",
              "desc": "<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property\ncontrols the status code that will be send to the client when the headers get\nflushed.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>response.statusCode = 404;</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "http.Agent",
          "name": "Agent",
          "desc": "<p><code>http.request()</code> uses a special <code>Agent</code> for managing multiple connections to\nan HTTP server. Normally <code>Agent</code> instances should not be exposed to user\ncode, however in certain situations it&apos;s useful to check the status of the\nagent. The <code>http.getAgent()</code> function allows you to access the agents.\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "desc": "<p><code>function (request, socket, head)</code>\n\n</p>\n<p>Emitted each time a server responds to a request with an upgrade. If this event\nisn&apos;t being listened for, clients receiving an upgrade header will have their\nconnections closed.\n\n</p>\n<p>See the description of the <code>upgrade</code> event for <code>http.Server</code> for further details.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'continue'",
              "type": "event",
              "name": "continue",
              "desc": "<p><code>function ()</code>\n\n</p>\n<p>Emitted when the server sends a &apos;100 Continue&apos; HTTP response, usually because\nthe request contained &apos;Expect: 100-continue&apos;. This is an instruction that\nthe client should send the request body.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "agent.maxSockets",
              "name": "maxSockets",
              "desc": "<p>By default set to 5. Determines how many concurrent sockets the agent can have open.\n\n</p>\n"
            },
            {
              "textRaw": "agent.sockets",
              "name": "sockets",
              "desc": "<p>An array of sockets currently in use by the Agent. Do not modify.\n\n</p>\n"
            },
            {
              "textRaw": "agent.queue",
              "name": "queue",
              "desc": "<p>A queue of requests waiting to be sent to sockets.\n\n\n\n</p>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "host"
                },
                {
                  "name": "port"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.ClientRequest",
          "name": "ClientRequest",
          "desc": "<p>This object is created internally and returned from <code>http.request()</code>.  It\nrepresents an <em>in-progress</em> request whose header has already been queued.  The \nheader is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,\n<code>removeHeader(name)</code> API.  The actual header will be sent along with the first\ndata chunk or when closing the connection.\n\n</p>\n<p>To get the response, add a listener for <code>&apos;response&apos;</code> to the request object.\n<code>&apos;response&apos;</code> will be emitted from the request object when the response\nheaders have been received.  The <code>&apos;response&apos;</code> event is executed with one\nargument which is an instance of <code>http.ClientResponse</code>.\n\n</p>\n<p>During the <code>&apos;response&apos;</code> event, one can add listeners to the\nresponse object; particularly to listen for the <code>&apos;data&apos;</code> event. Note that\nthe <code>&apos;response&apos;</code> event is called before any part of the response body is received,\nso there is no need to worry about racing to catch the first part of the\nbody. As long as a listener for <code>&apos;data&apos;</code> is added during the <code>&apos;response&apos;</code>\nevent, the entire body will be caught.\n\n\n</p>\n<pre><code>// Good\nrequest.on(&apos;response&apos;, function (response) {\n  response.on(&apos;data&apos;, function (chunk) {\n    console.log(&apos;BODY: &apos; + chunk);\n  });\n});\n\n// Bad - misses all or part of the body\nrequest.on(&apos;response&apos;, function (response) {\n  setTimeout(function () {\n    response.on(&apos;data&apos;, function (chunk) {\n      console.log(&apos;BODY: &apos; + chunk);\n    });\n  }, 10);\n});</code></pre>\n<p>This is a <code>Writable Stream</code>.\n\n</p>\n<p>This is an <code>EventEmitter</code> with the following events:\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event 'response'",
              "type": "event",
              "name": "response",
              "desc": "<p><code>function (response) { }</code>\n\n</p>\n<p>Emitted when a response is received to this request. This event is emitted only once. The\n<code>response</code> argument will be an instance of <code>http.ClientResponse</code>.\n\n\n</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "request.write(chunk, encoding='utf8')",
              "type": "method",
              "name": "write",
              "desc": "<p>Sends a chunk of the body.  By calling this method\nmany times, the user can stream a request body to a\nserver--in that case it is suggested to use the\n<code>[&apos;Transfer-Encoding&apos;, &apos;chunked&apos;]</code> header line when\ncreating the request.\n\n</p>\n<p>The <code>chunk</code> argument should be an array of integers\nor a string.\n\n</p>\n<p>The <code>encoding</code> argument is optional and only\napplies when <code>chunk</code> is a string.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "default": "'utf8'"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.end([data], [encoding])",
              "type": "method",
              "name": "end",
              "desc": "<p>Finishes sending the request. If any parts of the body are\nunsent, it will flush them to the stream. If the request is\nchunked, this will send the terminating <code>&apos;0\\r\\n\\r\\n&apos;</code>.\n\n</p>\n<p>If <code>data</code> is specified, it is equivalent to calling <code>request.write(data, encoding)</code>\nfollowed by <code>request.end()</code>.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.abort()",
              "type": "method",
              "name": "abort",
              "desc": "<p>Aborts a request.  (New since v0.3.8.)\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.ClientResponse",
          "name": "ClientResponse",
          "desc": "<p>This object is created when making a request with <code>http.request()</code>. It is\npassed to the <code>&apos;response&apos;</code> event of the request object.\n\n</p>\n<p>The response implements the <code>Readable Stream</code> interface.\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "desc": "<p><code>function (chunk) {}</code>\n\n</p>\n<p>Emitted when a piece of the message body is received.\n\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<p>Emitted exactly once for each message. No arguments. After\nemitted no other events will be emitted on the response.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "response.statusCode",
              "name": "statusCode",
              "desc": "<p>The 3-digit HTTP response status code. E.G. <code>404</code>.\n\n</p>\n"
            },
            {
              "textRaw": "response.httpVersion",
              "name": "httpVersion",
              "desc": "<p>The HTTP version of the connected-to server. Probably either\n<code>&apos;1.1&apos;</code> or <code>&apos;1.0&apos;</code>.\nAlso <code>response.httpVersionMajor</code> is the first integer and\n<code>response.httpVersionMinor</code> is the second.\n\n</p>\n"
            },
            {
              "textRaw": "response.headers",
              "name": "headers",
              "desc": "<p>The response headers object.\n\n</p>\n"
            },
            {
              "textRaw": "response.trailers",
              "name": "trailers",
              "desc": "<p>The response trailers object. Only populated after the &apos;end&apos; event.\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "response.setEncoding(encoding=null)",
              "type": "method",
              "name": "setEncoding",
              "desc": "<p>Set the encoding for the response body. Either <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.\nDefaults to <code>null</code>, which means that the <code>&apos;data&apos;</code> event will emit a <code>Buffer</code> object..\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "default": "null"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<p>Pauses response from emitting events.  Useful to throttle back a download.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "response.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<p>Resumes a paused response.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "http.request(options, callback)",
          "type": "method",
          "name": "request",
          "desc": "<p>Node maintains several connections per server to make HTTP requests.\nThis function allows one to transparently issue requests.\n\n</p>\n<p>Options:\n\n</p>\n<ul>\n<li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>\n<li><code>port</code>: Port of remote server.</li>\n<li><code>method</code>: A string specifying the HTTP request method. Possible values:\n<code>&apos;GET&apos;</code> (default), <code>&apos;POST&apos;</code>, <code>&apos;PUT&apos;</code>, and <code>&apos;DELETE&apos;</code>.</li>\n<li><code>path</code>: Request path. Should include query string and fragments if any.\n E.G. <code>&apos;/index.html?page=12&apos;</code></li>\n<li><code>headers</code>: An object containing request headers.</li>\n</ul>\n<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code>\nclass. The <code>ClientRequest</code> instance is a writable stream. If one needs to\nupload a file with a POST request, then write to the <code>ClientRequest</code> object.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var options = {\n  host: &apos;www.google.com&apos;,\n  port: 80,\n  path: &apos;/upload&apos;,\n  method: &apos;POST&apos;\n};\n\nvar req = http.request(options, function(res) {\n  console.log(&apos;STATUS: &apos; + res.statusCode);\n  console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers));\n  res.setEncoding(&apos;utf8&apos;);\n  res.on(&apos;data&apos;, function (chunk) {\n    console.log(&apos;BODY: &apos; + chunk);\n  });\n});\n\n// write data to request body\nreq.write(&apos;data\\n&apos;);\nreq.write(&apos;data\\n&apos;);\nreq.end();</code></pre>\n<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one\nmust always call <code>req.end()</code> to signify that you&apos;re done with the request -\neven if there is no data being written to the request body.\n\n</p>\n<p>If any error is encountered during the request (be that with DNS resolution,\nTCP level errors, or actual HTTP parse errors) an <code>&apos;error&apos;</code> event is emitted\non the returned request object.\n\n</p>\n<p>There are a few special headers that should be noted.\n\n</p>\n<ul>\n<li><p>Sending a &apos;Connection: keep-alive&apos; will notify Node that the connection to\nthe server should be persisted until the next request.</p>\n</li>\n<li><p>Sending a &apos;Content-length&apos; header will disable the default chunked encoding.</p>\n</li>\n<li><p>Sending an &apos;Expect&apos; header will immediately send the request headers.\nUsually, when sending &apos;Expect: 100-continue&apos;, you should both set a timeout\nand listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more\ninformation.</p>\n</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.get(options, callback)",
          "type": "method",
          "name": "get",
          "desc": "<p>Since most requests are GET requests without bodies, Node provides this\nconvenience method. The only difference between this method and <code>http.request()</code> is\nthat it sets the method to GET and calls <code>req.end()</code> automatically.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var options = {\n  host: &apos;www.google.com&apos;,\n  port: 80,\n  path: &apos;/index.html&apos;\n};\n\nhttp.get(options, function(res) {\n  console.log(&quot;Got response: &quot; + res.statusCode);\n}).on(&apos;error&apos;, function(e) {\n  console.log(&quot;Got error: &quot; + e.message);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.getAgent(host, port)",
          "type": "method",
          "name": "getAgent",
          "desc": "<p><code>http.request()</code> uses a special <code>Agent</code> for managing multiple connections to\nan HTTP server. Normally <code>Agent</code> instances should not be exposed to user\ncode, however in certain situations it&apos;s useful to check the status of the\nagent. The <code>http.getAgent()</code> function allows you to access the agents.\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "desc": "<p><code>function (request, socket, head)</code>\n\n</p>\n<p>Emitted each time a server responds to a request with an upgrade. If this event\nisn&apos;t being listened for, clients receiving an upgrade header will have their\nconnections closed.\n\n</p>\n<p>See the description of the <code>upgrade</code> event for <code>http.Server</code> for further details.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'continue'",
              "type": "event",
              "name": "continue",
              "desc": "<p><code>function ()</code>\n\n</p>\n<p>Emitted when the server sends a &apos;100 Continue&apos; HTTP response, usually because\nthe request contained &apos;Expect: 100-continue&apos;. This is an instruction that\nthe client should send the request body.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "agent.maxSockets",
              "name": "maxSockets",
              "desc": "<p>By default set to 5. Determines how many concurrent sockets the agent can have open.\n\n</p>\n"
            },
            {
              "textRaw": "agent.sockets",
              "name": "sockets",
              "desc": "<p>An array of sockets currently in use by the Agent. Do not modify.\n\n</p>\n"
            },
            {
              "textRaw": "agent.queue",
              "name": "queue",
              "desc": "<p>A queue of requests waiting to be sent to sockets.\n\n\n\n</p>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "host"
                },
                {
                  "name": "port"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "HTTP"
    },
    {
      "textRaw": "HTTPS",
      "name": "https",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>HTTPS es el protocolo HTTP sobre TLS/SSL. En Node se implementa en un \nmódulo separado.\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: https.Server",
          "type": "class",
          "name": "https.Server",
          "desc": "<p>This class is a subclass of <code>tls.Server</code> and emits events same as\n<code>http.Server</code>. See <code>http.Server</code> for more information.\n\n</p>\n"
        },
        {
          "textRaw": "Class: https.Agent",
          "type": "class",
          "name": "https.Agent",
          "desc": "<p>An Agent object for HTTPS similar to <a href=\"http.html#http.Agent\">http.Agent</a>.\nSee <a href=\"#https.request\">https.request()</a> for more information.\n\n\n</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "https.createServer(options, [requestListener])",
          "type": "method",
          "name": "createServer",
          "desc": "<p>Returns a new HTTPS web server object. The <code>options</code> is similar to\n<a href=\"tls.html#tls.createServer\">tls.createServer()</a>.  The <code>requestListener</code> is\na function which is automatically added to the <code>&apos;request&apos;</code> event.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>// curl -k https://localhost:8000/\nvar https = require(&apos;https&apos;);\nvar fs = require(&apos;fs&apos;);\n\nvar options = {\n  key: fs.readFileSync(&apos;test/fixtures/keys/agent2-key.pem&apos;),\n  cert: fs.readFileSync(&apos;test/fixtures/keys/agent2-cert.pem&apos;)\n};\n\nhttps.createServer(options, function (req, res) {\n  res.writeHead(200);\n  res.end(&quot;hola mundo\\n&quot;);\n}).listen(8000);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "requestListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "https.request(options, callback)",
          "type": "method",
          "name": "request",
          "desc": "<p>Hace una petición a un servidor web seguro.\nOpciones similares a <code>http.request()</code>.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>var https = require(&apos;https&apos;);\n\nvar options = {\n  host: &apos;encrypted.google.com&apos;,\n  port: 443,\n  path: &apos;/&apos;,\n  method: &apos;GET&apos;\n};\n\nvar req = https.request(options, function(res) {\n  console.log(&quot;statusCode: &quot;, res.statusCode);\n  console.log(&quot;headers: &quot;, res.headers);\n\n  res.on(&apos;data&apos;, function(d) {\n    process.stdout.write(d);\n  });\n});\nreq.end();\n\nreq.on(&apos;error&apos;, function(e) {\n  console.error(e);\n});</code></pre>\n<p>El argumento options tiene las siguientes opciones\n\n</p>\n<ul>\n<li>host: IP o dominio del host al que hacer la petición. Por defecto <code>&apos;localhost&apos;</code>.</li>\n<li>port: puerto del host al que hacer la petición. Por defecto 443.</li>\n<li>path: Ruta de la petición. Por defecto <code>&apos;/&apos;</code>.</li>\n<li><p>method: Método de la petición HTTP. Per defecto <code>&apos;GET&apos;</code>.</p>\n</li>\n<li><p><code>host</code>: A domain name or IP address of the server to issue the request to.\nDefaults to <code>&apos;localhost&apos;</code>.</p>\n</li>\n<li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li>\n<li><code>port</code>: Port of remote server. Defaults to 443.</li>\n<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&apos;GET&apos;</code>.</li>\n<li><code>path</code>: Request path. Defaults to <code>&apos;/&apos;</code>. Should include query string if any.\nE.G. <code>&apos;/index.html?page=12&apos;</code></li>\n<li><code>headers</code>: An object containing request headers.</li>\n<li><code>auth</code>: Basic authentication i.e. <code>&apos;user:password&apos;</code> to compute an\nAuthorization header.</li>\n<li><code>agent</code>: Controls <a href=\"#https.Agent\">Agent</a> behavior. When an Agent is\nused request will default to <code>Connection: keep-alive</code>. Possible values:<ul>\n<li><code>undefined</code> (default): use <a href=\"#https.globalAgent\">globalAgent</a> for this\nhost and port.</li>\n<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>\n<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to\n<code>Connection: close</code>.</li>\n</ul>\n</li>\n</ul>\n<p>The following options from <a href=\"tls.html#tls.connect\">tls.connect()</a> can also be\nspecified. However, a <a href=\"#https.globalAgent\">globalAgent</a> silently ignores these.\n\n</p>\n<ul>\n<li>key: Clave privada a usar para SSL. Por defecto <code>null</code>.</li>\n<li><code>passphrase</code>: A string of passphrase for the private key. Default <code>null</code>.</li>\n<li>cert: Certificado público x509 a usar. Por defecto <code>null</code>.</li>\n<li>ca: Un certificado de autoridad o un array de certificados de autoridad para comprobar\ncontra el host remoto.</li>\n<li><code>ciphers</code>: A string describing the ciphers to use or exclude. Consult\n<a href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a> for\ndetails on the format.</li>\n<li><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against\nthe list of supplied CAs. An <code>&apos;error&apos;</code> event is emitted if verification\nfails. Verification happens at the connection level, <em>before</em> the HTTP\nrequest is sent. Default <code>false</code>. </li>\n</ul>\n<p>.\n\n</p>\n<p>In order to specify these options, use a custom <code>Agent</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var options = {\n  host: &apos;encrypted.google.com&apos;,\n  port: 443,\n  path: &apos;/&apos;,\n  method: &apos;GET&apos;,\n  key: fs.readFileSync(&apos;test/fixtures/keys/agent2-key.pem&apos;),\n  cert: fs.readFileSync(&apos;test/fixtures/keys/agent2-cert.pem&apos;)\n};\noptions.agent = new https.Agent(options);\n\nvar req = https.request(options, function(res) {\n  ...\n}</code></pre>\n<p>Or does not use an <code>Agent</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var options = {\n  host: &apos;encrypted.google.com&apos;,\n  port: 443,\n  path: &apos;/&apos;,\n  method: &apos;GET&apos;,\n  key: fs.readFileSync(&apos;test/fixtures/keys/agent2-key.pem&apos;),\n  cert: fs.readFileSync(&apos;test/fixtures/keys/agent2-cert.pem&apos;),\n  agent: false\n};\n\nvar req = https.request(options, function(res) {\n  ...\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "https.get(options, callback)",
          "type": "method",
          "name": "get",
          "desc": "<p>Con <code>http.get()</code> pero para HTTPS.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>var https = require(&apos;https&apos;);\n\nhttps.get({ host: &apos;encrypted.google.com&apos;, path: &apos;/&apos; }, function(res) {\n  console.log(&quot;statusCode: &quot;, res.statusCode);\n  console.log(&quot;headers: &quot;, res.headers);\n\n  res.on(&apos;data&apos;, function(d) {\n    process.stdout.write(d);\n  });\n\n}).on(&apos;error&apos;, function(e) {\n  console.error(e);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "https.globalAgent",
          "name": "globalAgent",
          "desc": "<p>Global instance of <a href=\"#https.Agent\">https.Agent</a> which is used as the default\nfor all HTTPS client requests.\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "HTTPS"
    },
    {
      "textRaw": "URL",
      "name": "url",
      "desc": "<p>Este módulo posee utilidades para la resolución y análisis de URL.\nPara usarlo utilice <code>require(&apos;url&apos;)</code>.\n\n</p>\n<p>Analizar objetos URL tiene algo o mucho de los siguientes campos, dependiendo de\nque exista o no en la cadena de URL. Las partes que no están en la cadena de URL\nno se analizarán y no estarán presente en el objeto. Un ejemplo para la siguiente URL\n\n</p>\n<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>\n\n</p>\n<ul>\n<li><p><code>href</code>: La dirección URL ha sido analizada desde un principio.</p>\n<p>Ejemplo: <code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code></p>\n</li>\n<li><p><code>protocol</code>: El protocolo de petición (request).</p>\n<p>Ejemplo: <code>&apos;http:&apos;</code></p>\n</li>\n<li><p><code>host</code>: Una parte del host de la URL completa, incluyendo la información del puerto y autentificación.</p>\n<p>Ejemplo: <code>&apos;user:pass@host.com:8080&apos;</code></p>\n</li>\n<li><p><code>auth</code>: Parte de la información de autentificación de la URL.</p>\n<p>Ejemplo: <code>&apos;user:pass&apos;</code></p>\n</li>\n<li><p><code>hostname</code>: Sólo la parte del nombre del host.</p>\n<p>Ejemplo: <code>&apos;host.com&apos;</code></p>\n</li>\n<li><p><code>port</code>: El número de puerto del host.</p>\n<p>Ejemplo: <code>&apos;8080&apos;</code></p>\n</li>\n<li><p><code>pathname</code>: La sección de la ruta de la URL, que viene después del host y antes de la consulta, incluyendo la barra inicial si está presente.</p>\n<p>Ejemplo: <code>&apos;/p/a/t/h&apos;</code></p>\n</li>\n<li><p><code>search</code>: La parte de &apos;cadena de consulta&apos; de la URL, incluyendo el signo de interrogación principal.</p>\n<p>Ejemplo: <code>&apos;?query=string&apos;</code></p>\n</li>\n<li><p><code>query</code>: La parte de cualquier &apos;parámetro&apos; de la cadena de consulta, o un parser de un objeto de cadena de consulta.</p>\n<p>Ejemplo: <code>&apos;query=string&apos;</code> o <code>{&apos;query&apos;:&apos;string&apos;}</code></p>\n</li>\n<li><p><code>hash</code>: La parte del &apos;fragmento&apos; de la  URL incluyendo el símbolo de la libra.</p>\n<p>Ejemplo: <code>&apos;#hash&apos;</code></p>\n</li>\n</ul>\n<p>Los siguientes métodos son proporcionados por el módulo URL:\n\n</p>\n",
      "methods": [
        {
          "textRaw": "url.parse(urlStr, [parseQueryString], [slashesDenoteHost])",
          "type": "method",
          "name": "parse",
          "desc": "<p>Toma una cadena de la URL, y la devuelve como un objeto.  Devuelve <code>true</code> como el segundo argumento  a\nla cadena de consulta usando el módulo <code>querystring</code>.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "url.format(urlObj)",
              "type": "method",
              "name": "format",
              "desc": "<p>Toma un parser de un objeto URL, y devuelve una cadena de URL.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "urlObj"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "urlStr"
                },
                {
                  "name": "parseQueryString",
                  "optional": true
                },
                {
                  "name": "slashesDenoteHost",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "url.resolve(from, to)",
          "type": "method",
          "name": "resolve",
          "desc": "<p>Toma una URL base, y el atributo href de la URL, y lo determina como un navegador sería la etiqueta anchor (enlace).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from"
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "URL"
    },
    {
      "textRaw": "Cadena de consulta",
      "name": "cadena_de_consulta",
      "desc": "<p>Este módulo provee de utilidades para el tratamiento de cadenas de consultas.\nSe ofrece los siguientes métodos:\n\n</p>\n",
      "methods": [
        {
          "textRaw": "querystring.stringify(obj, sep='&', eq='=')",
          "type": "method",
          "name": "stringify",
          "desc": "<p>Serializa un objeto a una cadena de consulta.\nOpcionalmente reemplaza el separador por omisión y la asignación de caracteres.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>querystring.stringify({foo: &apos;bar&apos;})\n// devuelve\n&apos;foo=bar&apos;\n\nquerystring.stringify({foo: &apos;bar&apos;, baz: &apos;bob&apos;}, &apos;;&apos;, &apos;:&apos;)\n// devuelve\n&apos;foo:bar;baz:bob&apos;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "obj"
                },
                {
                  "name": "sep",
                  "default": "'&'"
                },
                {
                  "name": "eq",
                  "default": "'='"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "querystring.parse(str, sep='&', eq='=')",
          "type": "method",
          "name": "parse",
          "desc": "<p>Deserializa una cadena de consulta a un objeto.\nOpcionamente puede reemplazar el separador por omisión y asignar caracteres.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>querystring.parse(&apos;a=b&amp;b=c&apos;)\n// returns\n{ a: &apos;b&apos;, b: &apos;c&apos; }</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "sep",
                  "default": "'&'"
                },
                {
                  "name": "eq",
                  "default": "'='"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "querystring.escape",
          "name": "escape",
          "desc": "<p>La función escape es usada por <code>querystring.stringify</code>,\npara proporcionar reemplazos si es necesario.\n\n</p>\n"
        },
        {
          "textRaw": "querystring.unescape",
          "name": "unescape",
          "desc": "<p>La función unescape es usada por <code>querystring.parse</code>,\npara proporcionar reemplazos  si es necesario.\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Cadena de consulta"
    },
    {
      "textRaw": "Readline",
      "name": "readline",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>This module allows reading of a stream (such as STDIN) on a line-by-line basis.\n\n</p>\n<p>Note that once you&apos;ve invoked this module, your node program will not terminate\nuntil you&apos;ve closed the interface, and the STDIN stream. Here&apos;s how to allow\nyour program to gracefully terminate:\n\n</p>\n<pre>\nvar readline = require(&apos;readline&apos;);\n\nvar i = readline.createInterface(process.sdtin, process.stdout, null);\ni.question(&quot;What do you think of node.js?&quot;, function(answer) {\n  //TODO: Log the answer in a database\n  console.log(&quot;Thank you for your valuable feedback.&quot;);\n  i.close();                //These two lines together allow the program to\n  process.stdin.destroy();  //terminate. Without them, it would run forever.\n});\n</pre>\n\n",
      "methods": [
        {
          "textRaw": "createInterface(input, output, completer)",
          "type": "method",
          "name": "createInterface",
          "desc": "<p>Returns an interface object, which reads from input, and writes to output.\nTODO: I think &quot;completer&quot; is used for tab-completion, but not sure.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                },
                {
                  "name": "output"
                },
                {
                  "name": "completer"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "interface.setPrompt(prompt, length)",
          "type": "method",
          "name": "setPrompt",
          "desc": "<p>TODO\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prompt"
                },
                {
                  "name": "length"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "interface.prompt()",
          "type": "method",
          "name": "prompt",
          "desc": "<p>TODO: Appears to trigger showing the prompt.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "interface.question(query, cb)",
          "type": "method",
          "name": "question",
          "desc": "<p>Displays the query to the user, and then calls the callback after the user\nhas typed in their response.\n\n</p>\n<p>Example usage:\n\n</p>\n<pre>\ninterface.question(&quot;What is your favorite food?&quot;, function(answer) {\n  console.log(&quot;Oh, so your favorite food is &quot; + answer);\n});\n</pre>\n\n",
          "methods": [
            {
              "textRaw": "interface.close()",
              "type": "method",
              "name": "close",
              "desc": "<p>TODO\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "query"
                },
                {
                  "name": "cb"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "interface.pause()",
          "type": "method",
          "name": "pause",
          "desc": "<p>TODO\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "interface.resume()",
          "type": "method",
          "name": "resume",
          "desc": "<p>TODO\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "interface.write()",
          "type": "method",
          "name": "write",
          "desc": "<p>TODO\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Readline"
    },
    {
      "textRaw": "REPL",
      "name": "repl",
      "desc": "<p>Read-Eval-Print-Loop (REPL) está disponible como un programa independiente y fácilmente\npuede incluirse en otros programas.  REPL proporciona una forma interactiva de ejecutar\nJavaScript y ver los resultados.  Puede ser utilizado para la depuración, pruebas, o\nsimplemente para probar cosas.\n\n</p>\n<p>Debe ejectuarlo en <code>node</code> sin singún argumento desde la línea de comandos, debe posicionarse \ndentro de REPL. Posee la edición simple de líneas de emacs.\n\n</p>\n<pre><code>mjr:~$ node\nType &apos;.help&apos; for options.\n&gt; a = [ 1, 2, 3];\n[ 1, 2, 3 ]\n&gt; a.forEach(function (v) {\n...   console.log(v);\n...   });\n1\n2\n3</code></pre>\n<p>Para editores avanzados, inice node con la variable de entorno <code>NODE_NO_READLINE=1</code>.\nSe iniciará la configuración de REPL en la terminal y l permite utilizarlo con <code>rlwrap</code>.\n\n</p>\n<p>Por ejemplo, puede añadir lo siguiente al fichero bashrc:\n\n</p>\n<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>\n",
      "methods": [
        {
          "textRaw": "repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined])",
          "type": "method",
          "name": "start",
          "desc": "<p>Inicia REPL con el <code>prompt</code> como el prompt y  el <code>stream</code> para todo los procesos de I/O (Entrada/Salida). \n<code>prompt</code> es opcional y por omisión es <code>&gt; </code>.  <code>stream</code> es opcional y por omisión es \n<code>process.stdin</code>. <code>eval</code> is optional too and defaults to async wrapper for\n<code>eval()</code>.\n\n</p>\n<p>If <code>useGlobal</code> is set to true, then the repl will use the global object,\ninstead of running scripts in a separate context. Defaults to <code>false</code>.\n\n</p>\n<p>If <code>ignoreUndefined</code> is set to true, then the repl will not output return value\nof command if it&apos;s <code>undefined</code>. Defaults to <code>false</code>.\n\n</p>\n<p>You can use your own <code>eval</code> function if it has following signature:\n\n</p>\n<pre><code>function eval(cmd, callback) {\n  callback(null, result);\n}</code></pre>\n<p>Multiples REPLs pueden iniciar con una misma instancia de node.  Cada\nuno de ellos comparten el objeto global, pero tendrán un único proceso de I/O.\n\n</p>\n<p>Acontinuación un ejemplo que inicia REPL en stdin, un socket en Unix, y un socket en TCP:\n\n</p>\n<pre><code>var net = require(&quot;net&quot;),\n    repl = require(&quot;repl&quot;);\n\nconnections = 0;\n\nrepl.start(&quot;node via stdin&gt; &quot;);\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start(&quot;node via Unix socket&gt; &quot;, socket);\n}).listen(&quot;/tmp/node-repl-sock&quot;);\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start(&quot;node via TCP socket&gt; &quot;, socket);\n}).listen(5001);</code></pre>\n<p>Ejecutando el programa desde la línea de comando iniciará REPL en stdin.  Otros\nclientes REPL pueden conectarse a través de un socket Unix o TCP. <code>telnet</code> es útil\npara la conexión de sockets TCP, y <code>socat</code> puede ser conectar ambos sockets Unix y\nTCP.\n\n</p>\n<p>Al iniciar REPL desde un socket Unix basado en una instancia de stdin, puede \nconectarse a un  proceso en ejecución de node sin reiniciar el mismo.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prompt",
                  "optional": true
                },
                {
                  "name": "stream",
                  "optional": true
                },
                {
                  "name": "eval",
                  "optional": true
                },
                {
                  "name": "useGlobal",
                  "optional": true
                },
                {
                  "name": "ignoreUndefined",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "miscs": [
        {
          "textRaw": "Características de REPL",
          "name": "Características de REPL",
          "type": "misc",
          "desc": "<p>Dentro de REPL, presione Control+D para salir.  Expresiones de varias líneas pueden ser\ningresadas.\n\n</p>\n<p>La variable especial <code>_</code> (underscore) contiene el resultado de la última expresión.\n\n</p>\n<pre><code>&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\n[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]\n&gt; _.length\n3\n&gt; _ += 1\n4</code></pre>\n<p>REPL proporciona acceso a cualquier variable de ámbito global. Puede exponer \nuna variable a REPL explícitamente y asignarle a un contexto de objeto asociado \ncon cada <code>REPLServer</code>.  Por ejemplo:\n\n</p>\n<pre><code>// repl_test.js\nvar repl = require(&quot;repl&quot;),\n    msg = &quot;message&quot;;\n\nrepl.start().context.m = msg;</code></pre>\n<p>Los sucesos en el objeto <code>context</code> aparecen como local en REPL:\n\n</p>\n<pre><code>mjr:~$ node repl_test.js\n&gt; m\n&apos;message&apos;</code></pre>\n<p>Hay algunos comandos especiales de REPL:\n\n</p>\n<ul>\n<li><code>.break</code> - Si  bien ingresar expresiones en varias líneas, a veces, pueden perderse\no simplemente no son tomados en cuenta. <code>.break</code> comenzará de nuevo.</li>\n<li><code>.clear</code> - Restablece el objeto <code>context</code> a un objeto vacío y borra cualquier\nexpresión de varias líneas.</li>\n<li><code>.exit</code> - Cierra los stream de I/O, que hará que REPL termine.</li>\n<li><code>.help</code> - Muestra la lista de comandos especiales.</li>\n<li><code>.save</code> - Guarda la sesión actual de REPL en un fichero<blockquote>\n<p>.save ./file/to/save.js</p>\n</blockquote>\n</li>\n<li><code>.load</code> - Carga un fichero en la sesión actual de REPL.<blockquote>\n<p>.load ./file/to/load.js  </p>\n</blockquote>\n</li>\n</ul>\n<p>Lo siguiente son combinaciones del teclado para el uso especial de REPL:\n\n</p>\n<ul>\n<li><code>&lt;ctrl&gt;C</code> - Similar a la tecla <code>break</code>. Termina el comando\nactual. Presione dos veces en la línea para forzar la salida.</li>\n<li><code>&lt;ctrl&gt;D</code> - Similar a la tecla <code>.exit</code>.</li>\n</ul>\n"
        }
      ],
      "type": "module",
      "displayName": "REPL"
    },
    {
      "textRaw": "Executing JavaScript",
      "name": "vm",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>You can access this module with:\n\n</p>\n<pre><code>var vm = require(&apos;vm&apos;);</code></pre>\n<p>JavaScript code can be compiled and run immediately or compiled, saved, and run later.\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "vm.runInThisContext(code, [filename])",
          "type": "method",
          "name": "runInThisContext",
          "desc": "<p><code>vm.runInThisContext()</code> compiles <code>code</code>, runs it and returns the result. Running\ncode does not have access to local scope. <code>filename</code> is optional, it&apos;s used only\nin stack traces.\n\n</p>\n<p>Example of using <code>vm.runInThisContext</code> and <code>eval</code> to run the same code:\n\n</p>\n<pre><code>var localVar = 123,\n    usingscript, evaled,\n    vm = require(&apos;vm&apos;);\n\nusingscript = vm.runInThisContext(&apos;localVar = 1;&apos;,\n  &apos;myfile.vm&apos;);\nconsole.log(&apos;localVar: &apos; + localVar + &apos;, usingscript: &apos; +\n  usingscript);\nevaled = eval(&apos;localVar = 1;&apos;);\nconsole.log(&apos;localVar: &apos; + localVar + &apos;, evaled: &apos; +\n  evaled);\n\n// localVar: 123, usingscript: 1\n// localVar: 1, evaled: 1</code></pre>\n<p><code>vm.runInThisContext</code> does not have access to the local scope, so <code>localVar</code> is unchanged.\n<code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.\n\n</p>\n<p>In case of syntax error in <code>code</code>, <code>vm.runInThisContext</code> emits the syntax error to stderr\nand throws an exception.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInNewContext(code, [sandbox], [filename])",
          "type": "method",
          "name": "runInNewContext",
          "desc": "<p><code>vm.runInNewContext</code> compiles <code>code</code>, then runs it in <code>sandbox</code> and returns the\nresult. Running code does not have access to local scope. The object <code>sandbox</code>\nwill be used as the global object for <code>code</code>.\n<code>sandbox</code> and <code>filename</code> are optional, <code>filename</code> is only used in stack traces.\n\n</p>\n<p>Example: compile and execute code that increments a global variable and sets a new one.\nThese globals are contained in the sandbox.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;),\n    vm = require(&apos;vm&apos;),\n    sandbox = {\n      animal: &apos;cat&apos;,\n      count: 2\n    };\n\nvm.runInNewContext(&apos;count += 1; name = &quot;kitty&quot;&apos;, sandbox, &apos;myfile.vm&apos;);\nconsole.log(util.inspect(sandbox));\n\n// { animal: &apos;cat&apos;, count: 3, name: &apos;kitty&apos; }</code></pre>\n<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, <code>vm.runInNewContext</code> is quite useful, but safely running untrusted code\nrequires a separate process.\n\n</p>\n<p>In case of syntax error in <code>code</code>, <code>vm.runInNewContext</code> emits the syntax error to stderr\nand throws an exception.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "sandbox",
                  "optional": true
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInContext(code, context, [filename])",
          "type": "method",
          "name": "runInContext",
          "desc": "<p><code>vm.runInContext</code> compiles <code>code</code>, then runs it in <code>context</code> and returns the\nresult. A (V8) context comprises a global object, together with a set of\nbuilt-in objects and functions. Running code does not have access to local scope\nand the global object held within <code>context</code> will be used as the global object\nfor <code>code</code>.\n<code>filename</code> is optional, it&apos;s used only in stack traces.\n\n</p>\n<p>Example: compile and execute code in a existing context.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;),\n    vm = require(&apos;vm&apos;),\n    initSandbox = {\n      animal: &apos;cat&apos;,\n      count: 2\n    },\n    context = vm.createContext(initSandbox);\n\nvm.runInContext(&apos;count += 1; name = &quot;CATT&quot;&apos;, context, &apos;myfile.vm&apos;);\nconsole.log(util.inspect(context));\n\n// { animal: &apos;cat&apos;, count: 3, name: &apos;CATT&apos; }</code></pre>\n<p>Note that <code>createContext</code> will perform a shallow clone of the supplied sandbox object in order to\ninitialise the global object of the freshly constructed context.\n\n</p>\n<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, <code>vm.runInContext</code> is quite useful, but safely running untrusted code\nrequires a separate process.\n\n</p>\n<p>In case of syntax error in <code>code</code>, <code>vm.runInContext</code> emits the syntax error to stderr\nand throws an exception.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "context"
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.createContext([initSandbox])",
          "type": "method",
          "name": "createContext",
          "desc": "<p><code>vm.createContext</code> creates a new context which is suitable for use as the 2nd argument of a subsequent\ncall to <code>vm.runInContext</code>. A (V8) context comprises a global object together with a set of\nbuild-in objects and functions. The optional argument <code>initSandbox</code> will be shallow-copied\nto seed the initial contents of the global object used by the context.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "initSandbox",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.createScript(code, [filename])",
          "type": "method",
          "name": "createScript",
          "desc": "<p><code>createScript</code> compiles <code>code</code> but does not run it. Instead, it returns a\n<code>vm.Script</code> object representing this compiled code. This script can be run\nlater many times using methods below. The returned script is not bound to any\nglobal object. It is bound before each run, just for that run. <code>filename</code> is\noptional, it&apos;s only used in stack traces.\n\n</p>\n<p>In case of syntax error in <code>code</code>, <code>createScript</code> prints the syntax error to stderr\nand throws an exception.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Script",
          "type": "class",
          "name": "Script",
          "desc": "<p>A class for running scripts.  Returned by vm.createScript.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "script.runInThisContext()",
              "type": "method",
              "name": "runInThisContext",
              "desc": "<p>Similar to <code>vm.runInThisContext</code> but a method of a precompiled <code>Script</code> object.\n<code>script.runInThisContext</code> runs the code of <code>script</code> and returns the result.\nRunning code does not have access to local scope, but does have access to the <code>global</code> object\n(v8: in actual context).\n\n</p>\n<p>Example of using <code>script.runInThisContext</code> to compile code once and run it multiple times:\n\n</p>\n<pre><code>var vm = require(&apos;vm&apos;);\n\nglobalVar = 0;\n\nvar script = vm.createScript(&apos;globalVar += 1&apos;, &apos;myfile.vm&apos;);\n\nfor (var i = 0; i &lt; 1000 ; i += 1) {\n  script.runInThisContext();\n}\n\nconsole.log(globalVar);\n\n// 1000</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "script.runInNewContext([sandbox])",
              "type": "method",
              "name": "runInNewContext",
              "desc": "<p>Similar to <code>vm.runInNewContext</code> a method of a precompiled <code>Script</code> object.\n<code>script.runInNewContext</code> runs the code of <code>script</code> with <code>sandbox</code> as the global object and returns the result.\nRunning code does not have access to local scope. <code>sandbox</code> is optional.\n\n</p>\n<p>Example: compile code that increments a global variable and sets one, then execute this code multiple times.\nThese globals are contained in the sandbox.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;),\n    vm = require(&apos;vm&apos;),\n    sandbox = {\n      animal: &apos;cat&apos;,\n      count: 2\n    };\n\nvar script = vm.createScript(&apos;count += 1; name = &quot;kitty&quot;&apos;, &apos;myfile.vm&apos;);\n\nfor (var i = 0; i &lt; 10 ; i += 1) {\n  script.runInNewContext(sandbox);\n}\n\nconsole.log(util.inspect(sandbox));\n\n// { animal: &apos;cat&apos;, count: 12, name: &apos;kitty&apos; }</code></pre>\n<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, <code>script.runInNewContext</code> is quite useful, but safely running untrusted code\nrequires a separate process.\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "sandbox",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "vm"
    },
    {
      "textRaw": "Child Process",
      "name": "child_process",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>Node proporciona un <code>popen(3)</code> tri-direccional a través del\nmódulo <code>ChildProcess</code>.\n\n</p>\n<p>Es posible pasar un stream de datos a través del <code>stdin</code>, <code>stdout</code>, y\n<code>stderr</code> del proceso hijo (child) de manera totalmente sin bloqueo.\n\n</p>\n<p>Para crear un proceso hijo utilice <code>require(&apos;child_process&apos;).spawn()</code> o\n<code>require(&apos;child_process&apos;).fork()</code>.  La semántica de cada uno son un poco\ndiferente, y se explica a continuación.\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: ChildProcess",
          "type": "class",
          "name": "ChildProcess",
          "desc": "<p><code>ChildProcess</code> es <code>EventEmitter</code>.\n\n</p>\n<p>Los procesos hijo siempre tienen tres streams asociados a ellos. <code>child.stdin</code>,\n<code>child.stdout</code>, y <code>child.stderr</code>.  These may be shared with the stdio\nstreams of the parent process, or they may be separate stream objects\nwhich can be piped to and from.\n\n</p>\n<p>The ChildProcess class is not intended to be used directly.  Use the\n<code>spawn()</code> or <code>fork()</code> methods to create a Child Process instance.\n\n</p>\n",
          "modules": [
            {
              "textRaw": "Evento:  'exit'",
              "name": "evento:_'exit'",
              "desc": "<p>Este evento es emitido después de termine el proceso hijo. Si el proceso terminó\nde manera normal, <code>code</code> es el código de salida final, en caso contrario <code>null</code>. Si\nel proceso terminó debido al recibo de una señal, <code>signal</code> es el nombre string de\nla señal, en caso contrario <code>null</code>.\n\n</p>\n<p>Véase <code>waitpid(2)</code>.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento:  'exit'"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'disconnect'",
              "type": "event",
              "name": "disconnect",
              "desc": "<p>This event is emitted after using the <code>.disconnect()</code> method in the parent or\nin the child. After disconnecting it is no longer possible to send messages.\nAn alternative way to check if you can send messages is to see if the\n<code>child.connected</code> property is <code>true</code>.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "`stdin` {Stream object} ",
              "name": "stdin",
              "desc": "<p>Un <code>Stream de Escritura</code> que representa el <code>stdin</code> del proceso hijo.\nCerrar este stream vía <code>end()</code> a menudo causa que termine el proceso hijo.\n\n</p>\n<p>If the child stdio streams are shared with the parent, then this will\nnot be set.\n\n</p>\n"
            },
            {
              "textRaw": "`stdout` {Stream object} ",
              "name": "stdout",
              "desc": "<p>Un <code>Stream de Lectura</code> que representa el <code>stdout</code> del proceso hijo.\n\n</p>\n<p>If the child stdio streams are shared with the parent, then this will\nnot be set.\n\n</p>\n"
            },
            {
              "textRaw": "`stderr` {Stream object} ",
              "name": "stderr",
              "desc": "<p>Un <code>Stream de Lectura</code> que representa el <code>stderr</code> del proceso hijo.\n\n</p>\n<p>If the child stdio streams are shared with the parent, then this will\nnot be set.\n\n</p>\n"
            },
            {
              "textRaw": "`pid` {Integer} ",
              "name": "pid",
              "desc": "<p>El PID del proceso hijo.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>var spawn = require(&apos;child_process&apos;).spawn,\n    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);\n\nconsole.log(&apos;Spawned child pid: &apos; + grep.pid);\ngrep.stdin.end();</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "child.kill([signal])",
              "type": "method",
              "name": "kill",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`signal` {String} ",
                      "name": "signal",
                      "type": "String",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "signal",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Manda una señal al proceso hijo. Si ningún argumento es dado, el proceso \nenviará <code>&apos;SIGTERM&apos;</code>. Véase <code>signal(7)</code> para una lista de señales disponibles.\n\n</p>\n<pre><code>var spawn = require(&apos;child_process&apos;).spawn,\n    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);\n\ngrep.on(&apos;exit&apos;, function (code, signal) {\n  console.log(&apos;child process terminated due to receipt of signal &apos;+signal);\n});\n\n// send SIGHUP to process\ngrep.kill(&apos;SIGHUP&apos;);</code></pre>\n<p>Observa que mientras la función se llama <code>kill</code>, la señal entregada al proceso hijo\npuede o no terminarlo.  <code>kill</code> realmente solo manda una señal a un proceso.\n\n</p>\n<p>Véase <code>kill(2)</code>\n\n\n</p>\n"
            },
            {
              "textRaw": "child.send(message, [sendHandle])",
              "type": "method",
              "name": "send",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle object} ",
                      "name": "sendHandle",
                      "type": "Handle object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Send a message (and, optionally, a handle object) to a child process.\n\n</p>\n<p>See <code>child_process.fork()</code> for details.\n\n</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "child_process.spawn(command, [args], [options])",
          "type": "method",
          "name": "spawn",
          "signatures": [
            {
              "return": {
                "textRaw": "return: {ChildProcess object} ",
                "name": "return",
                "type": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`command` {String} The command to run ",
                  "name": "command",
                  "type": "String",
                  "desc": "The command to run"
                },
                {
                  "textRaw": "`args` {Array} List of string arguments ",
                  "name": "args",
                  "type": "Array",
                  "desc": "List of string arguments",
                  "optional": true
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "command"
                },
                {
                  "name": "args",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Inicia un nuevo proceso con el <code>command</code> proporcionado, con argumentos de linea de comandos <code>args</code>.\nSi es omitido, <code>args</code> por defecto sera un Array vacío.\n\n</p>\n<p>El tercer argumento es usado para especificar opciones adicionales, que por defecto serán:\n\n</p>\n<pre><code>{ cwd: undefined,\n  env: process.env\n}</code></pre>\n<p><code>cwd</code> te deja especificar el directorio actual de trabajo del cual es iniciado el proceso.\nUsa <code>env</code> para especificar variables de entorno que serán visibles al nuevo proceso.\n\n</p>\n<p>Ejemplo ejecutando <code>ls -lh /usr</code>, capturando <code>stdout</code>, <code>stderr</code>, y el codigo de salida:\n\n</p>\n<pre><code>var util  = require(&apos;util&apos;),\n    spawn = require(&apos;child_process&apos;).spawn,\n    ls    = spawn(&apos;ls&apos;, [&apos;-lh&apos;, &apos;/usr&apos;]);\n\nls.stdout.on(&apos;data&apos;, function (data) {\n  console.log(&apos;stdout: &apos; + data);\n});\n\nls.stderr.on(&apos;data&apos;, function (data) {\n  console.log(&apos;stderr: &apos; + data);\n});\n\nls.on(&apos;exit&apos;, function (code) {\n  console.log(&apos;child process exited with code &apos; + code);\n});</code></pre>\n<p>Ejemplo: Una manera muy elaborada de ejecutar &apos;ps ax | grep ssh&apos;\n\n</p>\n<pre><code>var util  = require(&apos;util&apos;),\n    spawn = require(&apos;child_process&apos;).spawn,\n    ps    = spawn(&apos;ps&apos;, [&apos;ax&apos;]),\n    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);\n\nps.stdout.on(&apos;data&apos;, function (data) {\n  grep.stdin.write(data);\n});\n\nps.stderr.on(&apos;data&apos;, function (data) {\n  console.log(&apos;ps stderr: &apos; + data);\n});\n\nps.on(&apos;exit&apos;, function (code) {\n  if (code !== 0) {\n    console.log(&apos;ps process exited with code &apos; + code);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.on(&apos;data&apos;, function (data) {\n  console.log(data);\n});\n\ngrep.stderr.on(&apos;data&apos;, function (data) {\n  console.log(&apos;grep stderr: &apos; + data);\n});\n\ngrep.on(&apos;exit&apos;, function (code) {\n  if (code !== 0) {\n    console.log(&apos;grep process exited with code &apos; + code);\n  }\n});</code></pre>\n<p>Ejemplo de comprobar por ejecución fallida:\n\n</p>\n<pre><code>var spawn = require(&apos;child_process&apos;).spawn,\n    child = spawn(&apos;bad_command&apos;);\n\nchild.stderr.setEncoding(&apos;utf8&apos;);\nchild.stderr.on(&apos;data&apos;, function (data) {\n  if (/^execvp\\(\\)/.test(data)) {\n    console.log(&apos;Failed to start child process.&apos;);\n  }\n});</code></pre>\n<p>Note that if spawn receives an empty options object, it will result in\nspawning the process with an empty environment rather than using\n<code>process.env</code>. This due to backwards compatibility issues with a deprecated\nAPI.\n\n</p>\n<p>There is a deprecated option called <code>customFds</code> which allows one to specify\nspecific file descriptors for the stdio of the child process. This API was\nnot portable to all platforms and therefore removed.\nWith <code>customFds</code> it was possible to hook up the new process&apos; <code>[stdin, stdout,\nstderr]</code> to existing streams; <code>-1</code> meant that a new stream should be created.\nUse at your own risk.\n\n</p>\n<p>There are several internal options. In particular <code>stdinStream</code>,\n<code>stdoutStream</code>, <code>stderrStream</code>. They are for INTERNAL USE ONLY. As with all\nundocumented APIs in Node, they should not be used.\n\n</p>\n<p>Véase tambien: <code>child_process.exec()</code> y <code>child_process.fork()</code>\n\n</p>\n"
        },
        {
          "textRaw": "child_process.exec(command, [options], callback)",
          "type": "method",
          "name": "exec",
          "signatures": [
            {
              "return": {
                "textRaw": "Return: ChildProcess object ",
                "name": "return",
                "desc": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`command` {String} The command to run, with space-separated arguments ",
                  "name": "command",
                  "type": "String",
                  "desc": "The command to run, with space-separated arguments"
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    },
                    {
                      "textRaw": "`encoding` {String} (Default: 'utf8') ",
                      "name": "encoding",
                      "default": "utf8",
                      "type": "String"
                    },
                    {
                      "textRaw": "`timeout` {Number} (Default: 0) ",
                      "name": "timeout",
                      "default": "0",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`maxBuffer` {Number} (Default: 200*1024) ",
                      "name": "maxBuffer",
                      "default": "200*1024",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`killSignal` {String} (Default: 'SIGTERM') ",
                      "name": "killSignal",
                      "default": "SIGTERM",
                      "type": "String"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} called with the output when process terminates ",
                  "options": [
                    {
                      "textRaw": "`code` {Integer} Exit code ",
                      "name": "code",
                      "type": "Integer",
                      "desc": "Exit code"
                    },
                    {
                      "textRaw": "`stdout` {Buffer} ",
                      "name": "stdout",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`stderr` {Buffer} ",
                      "name": "stderr",
                      "type": "Buffer"
                    }
                  ],
                  "name": "callback",
                  "type": "Function",
                  "desc": "called with the output when process terminates"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "command"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Runs a command in a shell and buffers the output.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;),\n    exec = require(&apos;child_process&apos;).exec,\n    child;\n\nchild = exec(&apos;cat *.js bad_file | wc -l&apos;,\n  function (error, stdout, stderr) {\n    console.log(&apos;stdout: &apos; + stdout);\n    console.log(&apos;stderr: &apos; + stderr);\n    if (error !== null) {\n      console.log(&apos;exec error: &apos; + error);\n    }\n});</code></pre>\n<p>El callback recibe los argumentos <code>(error, stdout, stderr)</code>. Cuando termina\ncon éxito, <code>error</code> sera <code>null</code>.  Cuando termina con error, <code>error</code> sera una \ninstancia de <code>Error</code> y <code>err.code</code> sera el código de salida del proceso hijo,\ny <code>err.signal</code> sera la señal que terminó el proceso.\n\n</p>\n<p>Hay un segundo argumento opcional para especificar varias opciones. Las \nopciones predeterminadas son\n\n</p>\n<pre><code>{ encoding: &apos;utf8&apos;,\n  timeout: 0,\n  maxBuffer: 200*1024,\n  killSignal: &apos;SIGTERM&apos;,\n  cwd: null,\n  env: null }</code></pre>\n<p>Si <code>timeout</code> es mayor que 0, entonces detendrá el proceso hijo \nsi este se ejecuta mas de <code>timeout</code> milisegundos. El proceso hijo se detiene con\n<code>killSignal</code> (por defecto: <code>&apos;SIGTERM&apos;</code>). <code>maxBuffer</code> especifica la mayor cantidad\nde datos permitidos en stdout o stderr - si este valor se excede el proceso hijo\nsera terminado.\n\n\n</p>\n"
        },
        {
          "textRaw": "child_process.execFile(file, args, options, callback)",
          "type": "method",
          "name": "execFile",
          "signatures": [
            {
              "return": {
                "textRaw": "Return: ChildProcess object ",
                "name": "return",
                "desc": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`file` {String} The filename of the program to run ",
                  "name": "file",
                  "type": "String",
                  "desc": "The filename of the program to run"
                },
                {
                  "textRaw": "`args` {Array} List of string arguments ",
                  "name": "args",
                  "type": "Array",
                  "desc": "List of string arguments"
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    },
                    {
                      "textRaw": "`encoding` {String} (Default: 'utf8') ",
                      "name": "encoding",
                      "default": "utf8",
                      "type": "String"
                    },
                    {
                      "textRaw": "`timeout` {Number} (Default: 0) ",
                      "name": "timeout",
                      "default": "0",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`maxBuffer` {Number} (Default: 200*1024) ",
                      "name": "maxBuffer",
                      "default": "200*1024",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`killSignal` {String} (Default: 'SIGTERM') ",
                      "name": "killSignal",
                      "default": "SIGTERM",
                      "type": "String"
                    }
                  ],
                  "name": "options",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} called with the output when process terminates ",
                  "options": [
                    {
                      "textRaw": "`code` {Integer} Exit code ",
                      "name": "code",
                      "type": "Integer",
                      "desc": "Exit code"
                    },
                    {
                      "textRaw": "`stdout` {Buffer} ",
                      "name": "stdout",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`stderr` {Buffer} ",
                      "name": "stderr",
                      "type": "Buffer"
                    }
                  ],
                  "name": "callback",
                  "type": "Function",
                  "desc": "called with the output when process terminates"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "args"
                },
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>This is similar to <code>child_process.exec()</code> except it does not execute a\nsubshell but rather the specified file directly. This makes it slightly\nleaner than <code>child_process.exec</code>. It has the same options.\n\n\n</p>\n"
        },
        {
          "textRaw": "child_process.fork(modulePath, [args], [options])",
          "type": "method",
          "name": "fork",
          "signatures": [
            {
              "return": {
                "textRaw": "Return: ChildProcess object ",
                "name": "return",
                "desc": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`modulePath` {String} The module to run in the child ",
                  "name": "modulePath",
                  "type": "String",
                  "desc": "The module to run in the child"
                },
                {
                  "textRaw": "`args` {Array} List of string arguments ",
                  "name": "args",
                  "type": "Array",
                  "desc": "List of string arguments",
                  "optional": true
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    },
                    {
                      "textRaw": "`encoding` {String} (Default: 'utf8') ",
                      "name": "encoding",
                      "default": "utf8",
                      "type": "String"
                    },
                    {
                      "textRaw": "`timeout` {Number} (Default: 0) ",
                      "name": "timeout",
                      "default": "0",
                      "type": "Number"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} called with the output when process terminates ",
                  "options": [
                    {
                      "textRaw": "`code` {Integer} Exit code ",
                      "name": "code",
                      "type": "Integer",
                      "desc": "Exit code"
                    },
                    {
                      "textRaw": "`stdout` {Buffer} ",
                      "name": "stdout",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`stderr` {Buffer} ",
                      "name": "stderr",
                      "type": "Buffer"
                    }
                  ],
                  "name": "callback",
                  "type": "Function",
                  "desc": "called with the output when process terminates"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "modulePath"
                },
                {
                  "name": "args",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>This is a special case of the <code>spawn()</code> functionality for spawning Node\nprocesses. In addition to having all the methods in a normal ChildProcess\ninstance, the returned object has a communication channel built-in. The\nchannel is written to with <code>child.send(message, [sendHandle])</code> and messages\nare received by a <code>&apos;message&apos;</code> event on the child.\n\n</p>\n<p>For example:\n\n</p>\n<pre><code>var cp = require(&apos;child_process&apos;);\n\nvar n = cp.fork(__dirname + &apos;/sub.js&apos;);\n\nn.on(&apos;message&apos;, function(m) {\n  console.log(&apos;PARENT got message:&apos;, m);\n});\n\nn.send({ hello: &apos;world&apos; });</code></pre>\n<p>And then the child script, <code>&apos;sub.js&apos;</code> might look like this:\n\n</p>\n<pre><code>process.on(&apos;message&apos;, function(m) {\n  console.log(&apos;CHILD got message:&apos;, m);\n});\n\nprocess.send({ foo: &apos;bar&apos; });</code></pre>\n<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>\nwill emit objects each time it receives a message on its channel.\n\n</p>\n<p>There is a special case when sending a <code>{cmd: &apos;NODE_foo&apos;}</code> message. All messages\ncontaining a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in\nthe <code>message</code> event, since they are internal messages used by node core.\nMessages containing the prefix are emitted in the <code>internalMessage</code> event, you\nshould by all means avoid using this feature, it may change without warranty.\n\n</p>\n<p>By default the spawned Node process will have the stdout, stderr associated\nwith the parent&apos;s. To change this behavior set the <code>silent</code> property in the\n<code>options</code> object to <code>true</code>.\n\n</p>\n<p>These child Nodes are still whole new instances of V8. Assume at least 30ms\nstartup and 10mb memory for each new Node. That is, you cannot create many\nthousands of them.\n\n</p>\n<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a handle object to\nanother process. Child will receive the handle as as second argument to the\n<code>message</code> event. Here is an example of sending a handle:\n\n</p>\n<pre><code>var server = require(&apos;net&apos;).createServer();\nvar child = require(&apos;child_process&apos;).fork(__dirname + &apos;/child.js&apos;);\n// Open up the server object and send the handle.\nserver.listen(1337, function() {\n  child.send({ server: true }, server._handle);\n});</code></pre>\n<p>Here is an example of receiving the server handle and sharing it between\nprocesses:\n\n</p>\n<pre><code>process.on(&apos;message&apos;, function(m, serverHandle) {\n  if (serverHandle) {\n    var server = require(&apos;net&apos;).createServer();\n    server.listen(serverHandle);\n  }\n});</code></pre>\n<p>To close the IPC connection between parent and child use the\n<code>child.disconnect()</code> method. This allows the child to exit gracefully since\nthere is no IPC channel keeping it alive. When calling this method the\n<code>disconnect</code> event will be emitted in both parent and child, and the\n<code>connected</code> flag will be set to <code>false</code>. Please note that you can also call\n<code>process.disconnect()</code> in the child process.\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Child Process"
    },
    {
      "textRaw": "Assert",
      "name": "assert",
      "desc": "<p>Este módulo es usado para escribir pruebas unitarias de sus aplicaciones, puede\nacceder con <code>require(&apos;assert&apos;)</code>.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "assert.fail(actual, expected, message, operator)",
          "type": "method",
          "name": "fail",
          "desc": "<p>Evalua si <code>actual</code> es igual a <code>expected</code> usando el operador provisto.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message"
                },
                {
                  "name": "operator"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.ok(value, [message])",
          "type": "method",
          "name": "ok",
          "desc": "<p>Evalua si el valor es <code>true</code>, si es equivalente a <code>assert.equal(true, value, message);</code>\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.equal(actual, expected, [message])",
          "type": "method",
          "name": "equal",
          "desc": "<p>Evalua la igualdad con el operador de comparación ( <code>==</code> ).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notEqual(actual, expected, [message])",
          "type": "method",
          "name": "notEqual",
          "desc": "<p>Evalua la no igualdad con el operador de comparación en negación ( <code>!=</code> ).\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.deepEqual(actual, expected, [message])",
          "type": "method",
          "name": "deepEqual",
          "desc": "<p>Pruebas para las pruebas de afirmación de desigualdad profunda.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notDeepEqual(actual, expected, [message])",
          "type": "method",
          "name": "notDeepEqual",
          "desc": "<p>Pruebas para cualquier desigualdad profunda.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.strictEqual(actual, expected, [message])",
          "type": "method",
          "name": "strictEqual",
          "desc": "<p>Pruebas de igualdad estrictas, según lo determinado por el operador de igualdad estricto ( <code>===</code> )\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notStrictEqual(actual, expected, [message])",
          "type": "method",
          "name": "notStrictEqual",
          "desc": "<p>Pruebas de no igualdad estrictas, según lo determinado por el operador de no igualdad estricto ( <code>!==</code> )\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.throws(block, [error], [message])",
          "type": "method",
          "name": "throws",
          "desc": "<p>Se espera lanzar un <code>bloque</code>(block) de error. El <code>error</code> puede ser un constructor, expresión regular (regexp) o \nuna función de validación.\n\n</p>\n<p>Validar instanceof usando el constructor:\n\n</p>\n<pre><code>assert.throws(\n  function() {\n    throw new Error(&quot;Wrong value&quot;);\n  },\n  Error\n);</code></pre>\n<p>Validar un mensaje de error usando RegExp:\n\n</p>\n<pre><code>assert.throws(\n  function() {\n    throw new Error(&quot;Wrong value&quot;);\n  },\n  /value/\n);</code></pre>\n<p>Error de validación personalizado:\n\n</p>\n<pre><code>assert.throws(\n  function() {\n    throw new Error(&quot;Wrong value&quot;);\n  },\n  function(err) {\n    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {\n      return true;\n    }\n  },\n  &quot;unexpected error&quot;\n);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "block"
                },
                {
                  "name": "error",
                  "optional": true
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.doesNotThrow(block, [error], [message])",
          "type": "method",
          "name": "doesNotThrow",
          "desc": "<p>Se espera un <code>bloque</code> (block) y no produzca un error, vea assert.throws para más detalles.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "block"
                },
                {
                  "name": "error",
                  "optional": true
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.ifError(value)",
          "type": "method",
          "name": "ifError",
          "desc": "<p>Comprueba si el valor no es falso, se produce un lanzamiento si el valor es verdadero. Muy útil\ncuando se prueba el primer argumento, <code>error</code> en los callbacks.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Assert"
    },
    {
      "textRaw": "TTY (Terminal)",
      "name": "tty_(terminal)",
      "desc": "<p>Utilice <code>require(&apos;tty&apos;)</code> para acceder al módulo.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>var tty = require(&apos;tty&apos;);\ntty.setRawMode(true);\nprocess.stdin.resume();\nprocess.stdin.on(&apos;keypress&apos;, function(char, key) {\n  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == &apos;c&apos;) {\n    console.log(&apos;salida airosa&apos;);\n    process.exit()\n  }\n});</code></pre>\n",
      "methods": [
        {
          "textRaw": "tty.open(path, args=[])",
          "type": "method",
          "name": "open",
          "desc": "<p>Genera un nuevo proceso con el fichero ejecutable en la <code>ruta</code> como la sesión\nactual a una nueva pseudo terminal.\n\n</p>\n<p>Devuelve un array <code>[slaveFD, childProcess]</code>. <code>slaveFD</code> es el descriptor de fichero\nesclavo de la pseudo terminal. <code>childProcess</code> es un proceso hijo de un \nobjeto.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "args",
                  "default": "["
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tty.isatty(fd)",
          "type": "method",
          "name": "isatty",
          "desc": "<p>Devuelve <code>true</code> o <code>false</code> dependiendo si el <code>fd</code> es asociado con el\nterminal.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tty.setRawMode(mode)",
          "type": "method",
          "name": "setRawMode",
          "desc": "<p><code>mode</code> debe ser <code>true</code> o <code>false</code>. Se establece las propiedades al proceso actual\nde stdin fd para actuar ya sea como un dispositivo de modo sin formato o por omisión.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tty.setWindowSize(fd, row, col)",
          "type": "method",
          "name": "setWindowSize",
          "desc": "<p><code>ioctl</code> ajusta la configuración de la ventana del descriptor de fichero.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "row"
                },
                {
                  "name": "col"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tty.getWindowSize(fd)",
          "type": "method",
          "name": "getWindowSize",
          "desc": "<p>Devuelve <code>[row, col]</code> associado a la TTY con el descriptor de fichero.\n\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "TTY (Terminal)"
    },
    {
      "textRaw": "Zlib",
      "name": "zlib",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>You can access this module with:\n\n</p>\n<pre><code>var zlib = require(&apos;zlib&apos;);</code></pre>\n<p>This provides bindings to Gzip/Gunzip, Deflate/Inflate, and\nDeflateRaw/InflateRaw classes.  Each class takes the same options, and\nis a readable/writable Stream.\n\n</p>\n<h2>Examples</h2>\n<p>Compressing or decompressing a file can be done by piping an\nfs.ReadStream into a zlib stream, then into an fs.WriteStream.\n\n</p>\n<pre><code>var gzip = zlib.createGzip();\nvar fs = require(&apos;fs&apos;);\nvar inp = fs.createReadStream(&apos;input.txt&apos;);\nvar out = fs.createWriteStream(&apos;input.txt.gz&apos;);\n\ninp.pipe(gzip).pipe(out);</code></pre>\n<p>Compressing or decompressing data in one step can be done by using\nthe convenience methods.\n\n</p>\n<pre><code>var input = &apos;.................................&apos;;\nzlib.deflate(input, function(err, buffer) {\n  if (!err) {\n    console.log(buffer.toString(&apos;base64&apos;));\n  }\n});\n\nvar buffer = new Buffer(&apos;eJzT0yMAAGTvBe8=&apos;, &apos;base64&apos;);\nzlib.unzip(buffer, function(err, buffer) {\n  if (!err) {\n    console.log(buffer.toString());\n  }\n});</code></pre>\n<p>To use this module in an HTTP client or server, use the\n<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\">accept-encoding</a>\non requests, and the\n<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11\">content-encoding</a>\nheader on responses.\n\n</p>\n<p><strong>Note: these examples are drastically simplified to show\nthe basic concept.</strong>  Zlib encoding can be expensive, and the results\nought to be cached.  See <a href=\"#memory_Usage_Tuning\">Memory Usage Tuning</a>\nbelow for more information on the speed/memory/compression\ntradeoffs involved in zlib usage.\n\n</p>\n<pre><code>// client request example\nvar zlib = require(&apos;zlib&apos;);\nvar http = require(&apos;http&apos;);\nvar fs = require(&apos;fs&apos;);\nvar request = http.get({ host: &apos;izs.me&apos;,\n                         path: &apos;/&apos;,\n                         port: 80,\n                         headers: { &apos;accept-encoding&apos;: &apos;gzip,deflate&apos; } });\nrequest.on(&apos;response&apos;, function(response) {\n  var output = fs.createWriteStream(&apos;izs.me_index.html&apos;);\n\n  switch (response.headers[&apos;content-encoding&apos;]) {\n    // or, just use zlib.createUnzip() to handle both cases\n    case &apos;gzip&apos;:\n      response.pipe(zlib.createGunzip()).pipe(output);\n      break;\n    case &apos;deflate&apos;:\n      response.pipe(zlib.createInflate()).pipe(output);\n      break;\n    default:\n      response.pipe(output);\n      break;\n  }\n});\n\n// server example\n// Running a gzip operation on every request is quite expensive.\n// It would be much more efficient to cache the compressed buffer.\nvar zlib = require(&apos;zlib&apos;);\nvar http = require(&apos;http&apos;);\nvar fs = require(&apos;fs&apos;);\nhttp.createServer(function(request, response) {\n  var raw = fs.createReadStream(&apos;index.html&apos;);\n  var acceptEncoding = request.headers[&apos;accept-encoding&apos;];\n  if (!acceptEncoding) {\n    acceptEncoding = &apos;&apos;;\n  }\n\n  // Note: this is not a conformant accept-encoding parser.\n  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n  if (acceptEncoding.match(/\\bdeflate\\b/)) {\n    response.writeHead(200, { &apos;content-encoding&apos;: &apos;deflate&apos; });\n    raw.pipe(zlib.createDeflate()).pipe(response);\n  } else if (acceptEncoding.match(/\\bgzip\\b/)) {\n    response.writeHead(200, { &apos;content-encoding&apos;: &apos;gzip&apos; });\n    raw.pipe(zlib.createGzip()).pipe(response);\n  } else {\n    response.writeHead(200, {});\n    raw.pipe(response);\n  }\n}).listen(1337);</code></pre>\n",
      "miscs": [
        {
          "textRaw": "Constants",
          "name": "Constants",
          "type": "misc",
          "desc": "<p>All of the constants defined in zlib.h are also defined on\n<code>require(&apos;zlib&apos;)</code>.  They are described in more detail in the zlib\ndocumentation.  See <a href=\"http://zlib.net/manual.html#Constants\">http://zlib.net/manual.html#Constants</a>\nfor more details.\n\n</p>\n"
        },
        {
          "textRaw": "Convenience Methods",
          "name": "Convenience Methods",
          "type": "misc",
          "desc": "<p>All of these take a string or buffer as the first argument, and call the\nsupplied callback with <code>callback(error, result)</code>.  The\ncompression/decompression engine is created using the default settings\nin all convenience methods.  To supply different options, use the\nzlib classes directly.\n\n</p>\n"
        },
        {
          "textRaw": "Options",
          "name": "Options",
          "type": "misc",
          "desc": "<p>Each class takes an options object.  All options are optional.  (The\nconvenience methods use the default settings for all options.)\n\n</p>\n<p>Note that some options are only\nrelevant when compressing, and are ignored by the decompression classes.\n\n</p>\n<ul>\n<li>chunkSize (default: 16*1024)</li>\n<li>windowBits</li>\n<li>level (compression only)</li>\n<li>memLevel (compression only)</li>\n<li>strategy (compression only)</li>\n<li>dictionary (deflate/inflate only, empty dictionary by default)</li>\n</ul>\n<p>See the description of <code>deflateInit2</code> and <code>inflateInit2</code> at\n</p>\n<p><a href=\"http://zlib.net/manual.html#Advanced\">http://zlib.net/manual.html#Advanced</a> for more information on these.\n\n</p>\n"
        },
        {
          "textRaw": "Memory Usage Tuning",
          "name": "Memory Usage Tuning",
          "type": "misc",
          "desc": "<p>From <code>zlib/zconf.h</code>, modified to node&apos;s usage:\n\n</p>\n<p>The memory requirements for deflate are (in bytes):\n\n</p>\n<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>\n<p>that is: 128K for windowBits=15  +  128K for memLevel = 8\n(default values) plus a few kilobytes for small objects.\n\n</p>\n<p>For example, if you want to reduce\nthe default memory requirements from 256K to 128K, set the options to:\n\n</p>\n<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>\n<p>Of course this will generally degrade compression (there&apos;s no free lunch).\n\n</p>\n<p>The memory requirements for inflate are (in bytes)\n\n</p>\n<pre><code>1 &lt;&lt; windowBits</code></pre>\n<p>that is, 32K for windowBits=15 (default value) plus a few kilobytes\nfor small objects.\n\n</p>\n<p>This is in addition to a single internal output slab buffer of size\n<code>chunkSize</code>, which defaults to 16K.\n\n</p>\n<p>The speed of zlib compression is affected most dramatically by the\n<code>level</code> setting.  A higher level will result in better compression, but\nwill take longer to complete.  A lower level will result in less\ncompression, but will be much faster.\n\n</p>\n<p>In general, greater memory usage options will mean that node has to make\nfewer calls to zlib, since it&apos;ll be able to process more data in a\nsingle <code>write</code> operation.  So, this is another factor that affects the\nspeed, at the cost of memory usage.\n\n</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "zlib.createGzip([options])",
          "type": "method",
          "name": "createGzip",
          "desc": "<p>Returns a new <a href=\"#zlib.Gzip\">Gzip</a> object with an <a href=\"#options\">options</a>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createGunzip([options])",
          "type": "method",
          "name": "createGunzip",
          "desc": "<p>Returns a new <a href=\"#zlib.Gunzip\">Gunzip</a> object with an <a href=\"#options\">options</a>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createDeflate([options])",
          "type": "method",
          "name": "createDeflate",
          "desc": "<p>Returns a new <a href=\"#zlib.Deflate\">Deflate</a> object with an <a href=\"#options\">options</a>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createInflate([options])",
          "type": "method",
          "name": "createInflate",
          "desc": "<p>Returns a new <a href=\"#zlib.Inflate\">Inflate</a> object with an <a href=\"#options\">options</a>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createDeflateRaw([options])",
          "type": "method",
          "name": "createDeflateRaw",
          "desc": "<p>Returns a new <a href=\"#zlib.DeflateRaw\">DeflateRaw</a> object with an <a href=\"#options\">options</a>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createInflateRaw([options])",
          "type": "method",
          "name": "createInflateRaw",
          "desc": "<p>Returns a new <a href=\"#zlib.InflateRaw\">InflateRaw</a> object with an <a href=\"#options\">options</a>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createUnzip([options])",
          "type": "method",
          "name": "createUnzip",
          "desc": "<p>Returns a new <a href=\"#zlib.Unzip\">Unzip</a> object with an <a href=\"#options\">options</a>.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.deflate(buf, callback)",
          "type": "method",
          "name": "deflate",
          "desc": "<p>Compress a string with Deflate.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.deflateRaw(buf, callback)",
          "type": "method",
          "name": "deflateRaw",
          "desc": "<p>Compress a string with DeflateRaw.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.gzip(buf, callback)",
          "type": "method",
          "name": "gzip",
          "desc": "<p>Compress a string with Gzip.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.gunzip(buf, callback)",
          "type": "method",
          "name": "gunzip",
          "desc": "<p>Decompress a raw Buffer with Gunzip.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.inflate(buf, callback)",
          "type": "method",
          "name": "inflate",
          "desc": "<p>Decompress a raw Buffer with Inflate.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.inflateRaw(buf, callback)",
          "type": "method",
          "name": "inflateRaw",
          "desc": "<p>Decompress a raw Buffer with InflateRaw.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.unzip(buf, callback)",
          "type": "method",
          "name": "unzip",
          "desc": "<p>Decompress a raw Buffer with Unzip.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: zlib.Gzip",
          "type": "class",
          "name": "zlib.Gzip",
          "desc": "<p>Compress data using gzip.\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Gunzip",
          "type": "class",
          "name": "zlib.Gunzip",
          "desc": "<p>Decompress a gzip stream.\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Deflate",
          "type": "class",
          "name": "zlib.Deflate",
          "desc": "<p>Compress data using deflate.\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Inflate",
          "type": "class",
          "name": "zlib.Inflate",
          "desc": "<p>Decompress a deflate stream.\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.DeflateRaw",
          "type": "class",
          "name": "zlib.DeflateRaw",
          "desc": "<p>Compress data using deflate, and do not append a zlib header.\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.InflateRaw",
          "type": "class",
          "name": "zlib.InflateRaw",
          "desc": "<p>Decompress a raw deflate stream.\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Unzip",
          "type": "class",
          "name": "zlib.Unzip",
          "desc": "<p>Decompress either a Gzip- or Deflate-compressed stream by auto-detecting\nthe header.\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Zlib"
    },
    {
      "textRaw": "Módulo os",
      "name": "módulo_os",
      "desc": "<p>Utilice <code>require(&apos;os&apos;)</code> para acceder al módulo.\n\n</p>\n",
      "methods": [
        {
          "textRaw": "os.hostname()",
          "type": "method",
          "name": "hostname",
          "desc": "<p>Devuelve el hostname del sistema operativo.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.type()",
          "type": "method",
          "name": "type",
          "desc": "<p>Devuelve el nombre del sistema operativo.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.release()",
          "type": "method",
          "name": "release",
          "desc": "<p>Devuelve la versión del sistema operativo.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.uptime()",
          "type": "method",
          "name": "uptime",
          "desc": "<p>Devuelve el uptime en segundos del sistema.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.loadavg()",
          "type": "method",
          "name": "loadavg",
          "desc": "<p>Devuelve un array conteniendo los promedios en 1, 5, y 15 minutos de carga.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.totalmem()",
          "type": "method",
          "name": "totalmem",
          "desc": "<p>Devuelve la cantidad total en memoria del sistema en bytes\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.freemem()",
          "type": "method",
          "name": "freemem",
          "desc": "<p>Devuelve la cantidad de memoria libre del sistema en bytes.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.cpus()",
          "type": "method",
          "name": "cpus",
          "desc": "<p>Devuelve un array de objetos que contiene información acerca de cada CPU/core instalado: modelo, velocidad (en MHz), y los tiempos (un objeto que contiene el número de CPU usado por: usuario, nice, sys, idle, e irq).\n\n</p>\n<p>Ejemplo de inspección de os.cpus:\n\n</p>\n<pre><code>[ { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 252020,\n       nice: 0,\n       sys: 30340,\n       idle: 1070356870,\n       irq: 0 } },\n  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 306960,\n       nice: 0,\n       sys: 26980,\n       idle: 1071569080,\n       irq: 0 } },\n  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 248450,\n       nice: 0,\n       sys: 21750,\n       idle: 1070919370,\n       irq: 0 } },\n  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 256880,\n       nice: 0,\n       sys: 19430,\n       idle: 1070905480,\n       irq: 20 } },\n  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 511580,\n       nice: 20,\n       sys: 40900,\n       idle: 1070842510,\n       irq: 0 } },\n  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 291660,\n       nice: 0,\n       sys: 34360,\n       idle: 1070888000,\n       irq: 10 } },\n  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 308260,\n       nice: 0,\n       sys: 55410,\n       idle: 1071129970,\n       irq: 880 } },\n  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,\n    speed: 2926,\n    times:\n     { user: 266450,\n       nice: 1480,\n       sys: 34920,\n       idle: 1072572010,\n       irq: 30 } } ]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Módulo os"
    },
    {
      "textRaw": "Cluster",
      "name": "cluster",
      "stability": 1,
      "stabilityText": "Experimental",
      "desc": "<p>A single instance of Node runs in a single thread. To take advantage of\nmulti-core systems the user will sometimes want to launch a cluster of Node\nprocesses to handle the load.\n\n</p>\n<p>The cluster module allows you to easily create a network of processes that\nall share server ports.\n\n</p>\n<pre><code>var cluster = require(&apos;cluster&apos;);\nvar http = require(&apos;http&apos;);\nvar numCPUs = require(&apos;os&apos;).cpus().length;\n\nif (cluster.isMaster) {\n  // Fork workers.\n  for (var i = 0; i &lt; numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on(&apos;death&apos;, function(worker) {\n    console.log(&apos;worker &apos; + worker.pid + &apos; died&apos;);\n  });\n} else {\n  // Workers can share any TCP connection\n  // In this case its a HTTP server\n  http.createServer(function(req, res) {\n    res.writeHead(200);\n    res.end(&quot;hello world\\n&quot;);\n  }).listen(8000);\n}</code></pre>\n<p>Running node will now share port 8000 between the workers:\n\n</p>\n<pre><code>% node server.js\nWorker 2438 online\nWorker 2437 online</code></pre>\n<p>This feature was introduced recently, and may change in future versions.\nPlease try it out and provide feedback.\n\n</p>\n",
      "properties": [
        {
          "textRaw": "`settings` {Object} ",
          "name": "settings",
          "options": [
            {
              "textRaw": "`exec` {String} file path to worker file.  (Default=`__filename`) ",
              "name": "exec",
              "default": "__filename",
              "type": "String",
              "desc": "file path to worker file."
            },
            {
              "textRaw": "`args` {Array} string arguments passed to worker. (Default=`process.argv.slice(2)`) ",
              "name": "args",
              "default": "process.argv.slice(2)",
              "type": "Array",
              "desc": "string arguments passed to worker."
            },
            {
              "textRaw": "`silent` {Boolean} whether or not to send output to parent's stdio. (Default=`false`) ",
              "name": "silent",
              "default": "false",
              "type": "Boolean",
              "desc": "whether or not to send output to parent's stdio."
            }
          ],
          "desc": "<p>All settings set by the <code>.setupMaster</code> is stored in this settings object.\nThis object is not supposed to be change or set manually, by you.\n\n</p>\n"
        },
        {
          "textRaw": "`isMaster` {Boolean} ",
          "name": "isMaster",
          "desc": "<p>True if the process is a master. This is determined\nby the <code>process.env.NODE_UNIQUE_ID</code>. If <code>process.env.NODE_UNIQUE_ID</code> is\nundefined, then <code>isMaster</code> is <code>true</code>.\n\n</p>\n"
        },
        {
          "textRaw": "`isWorker` {Boolean} ",
          "name": "isWorker",
          "desc": "<p>This boolean flag is true if the process is a worker forked from a master.\nIf the <code>process.env.NODE_UNIQUE_ID</code> is set to a value, then\n<code>isWorker</code> is <code>true</code>.\n\n</p>\n"
        },
        {
          "textRaw": "`settings` {Object} ",
          "name": "settings",
          "options": [
            {
              "textRaw": "`exec` {String} file path to worker file.  Default: `__filename` ",
              "name": "exec",
              "type": "String",
              "desc": "file path to worker file.  Default: `__filename`"
            },
            {
              "textRaw": "`args` {Array} string arguments passed to worker. (Default=`process.argv.slice(2)`) ",
              "name": "args",
              "default": "process.argv.slice(2)",
              "type": "Array",
              "desc": "string arguments passed to worker."
            },
            {
              "textRaw": "`silent` {Boolean} whether or not to send output to parent's stdio. (Default=`false`) ",
              "name": "silent",
              "default": "false",
              "type": "Boolean",
              "desc": "whether or not to send output to parent's stdio."
            }
          ],
          "desc": "<p>All settings set by the <code>.setupMaster</code> is stored in this settings object.\nThis object is not supposed to be change or set manually.\n\n</p>\n"
        },
        {
          "textRaw": "`workers` {Object} ",
          "name": "workers",
          "desc": "<p>In the cluster all living worker objects are stored in this object by there\n<code>uniqueID</code> as the key. This makes it easy to loop through all living workers.\n\n</p>\n<pre><code>// Go through all workers\nfunction eachWorker(callback) {\n  for (var uniqueID in cluster.workers) {\n    callback(cluster.workers[uniqueID]);\n  }\n}\neachWorker(function (worker) {\n  worker.send(&apos;big announcement to all workers&apos;);\n});</code></pre>\n<p>Should you wish to reference a worker over a communication channel, using\nthe worker&apos;s uniqueID is the easiest way to find the worker.\n\n</p>\n<pre><code>socket.on(&apos;data&apos;, function (uniqueID) {\n  var worker = cluster.workers[uniqueID];\n});</code></pre>\n"
        }
      ],
      "events": [
        {
          "textRaw": "Event: 'fork'",
          "type": "event",
          "name": "fork",
          "params": [],
          "desc": "<p>When a new worker is forked the cluster module will emit a &apos;fork&apos; event.\nThis can be used to log worker activity, and create you own timeout.\n\n</p>\n<pre><code>var timeouts = [];\nvar errorMsg = function () {\n  console.error(&quot;Something must be wrong with the connection ...&quot;);\n});\n\ncluster.on(&apos;fork&apos;, function (worker) {\n  timeouts[worker.uniqueID] = setTimeout(errorMsg, 2000);\n});\ncluster.on(&apos;listening&apos;, function (worker) {\n  clearTimeout(timeouts[worker.uniqueID]);\n});\ncluster.on(&apos;death&apos;, function (worker) {\n  clearTimeout(timeouts[worker.uniqueID]);\n  errorMsg();\n});</code></pre>\n"
        },
        {
          "textRaw": "Event: 'online'",
          "type": "event",
          "name": "online",
          "params": [],
          "desc": "<p>After forking a new worker, the worker should respond with a online message.\nWhen the master receives a online message it will emit such event.\nThe difference between &apos;fork&apos; and &apos;online&apos; is that fork is emitted when the\nmaster tries to fork a worker, and &apos;online&apos; is emitted when the worker is\nbeing executed.\n\n</p>\n<pre><code>cluster.on(&apos;online&apos;, function (worker) {\n  console.log(&quot;Yay, the worker responded after it was forked&quot;);\n});</code></pre>\n"
        },
        {
          "textRaw": "Event: 'listening'",
          "type": "event",
          "name": "listening",
          "params": [],
          "desc": "<p>When calling <code>listen()</code> from a worker, a &apos;listening&apos; event is automatically assigned\nto the server instance. When the server is listening a message is send to the master\nwhere the &apos;listening&apos; event is emitted.\n\n</p>\n<pre><code>cluster.on(&apos;listening&apos;, function (worker) {\n  console.log(&quot;We are now connected&quot;);\n});</code></pre>\n"
        },
        {
          "textRaw": "Event: 'death'",
          "type": "event",
          "name": "death",
          "params": [],
          "desc": "<p>When any of the workers die the cluster module will emit the &apos;death&apos; event.\nThis can be used to restart the worker by calling <code>fork()</code> again.\n\n</p>\n<pre><code>cluster.on(&apos;death&apos;, function(worker) {\n  console.log(&apos;worker &apos; + worker.pid + &apos; died. restart...&apos;);\n  cluster.fork();\n});</code></pre>\n"
        },
        {
          "textRaw": "Event: 'setup'",
          "type": "event",
          "name": "setup",
          "params": [],
          "desc": "<p>When the <code>.setupMaster()</code> function has been executed this event emits.\nIf <code>.setupMaster()</code> was not executed before <code>fork()</code> this function will\ncall <code>.setupMaster()</code> with no arguments.\n\n</p>\n"
        },
        {
          "textRaw": "Event: 'death'",
          "type": "event",
          "name": "death",
          "params": [],
          "desc": "<p>Same as the <code>cluster.on(&apos;death&apos;)</code> event, but emits only when the state change\non the specified worker.\n\n</p>\n<pre><code>cluster.fork().on(&apos;death&apos;, function (worker) {\n  // Worker has died\n};</code></pre>\n<p>@include appendix_1</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "cluster.setupMaster([settings])",
          "type": "method",
          "name": "setupMaster",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`settings` {Object} ",
                  "options": [
                    {
                      "textRaw": "`exec` {String} file path to worker file.  (Default=`__filename`) ",
                      "name": "exec",
                      "default": "__filename",
                      "type": "String",
                      "desc": "file path to worker file."
                    },
                    {
                      "textRaw": "`args` {Array} string arguments passed to worker. (Default=`process.argv.slice(2)`) ",
                      "name": "args",
                      "default": "process.argv.slice(2)",
                      "type": "Array",
                      "desc": "string arguments passed to worker."
                    },
                    {
                      "textRaw": "`silent` {Boolean} whether or not to send output to parent's stdio. (Default=`false`) ",
                      "name": "silent",
                      "default": "false",
                      "type": "Boolean",
                      "desc": "whether or not to send output to parent's stdio."
                    }
                  ],
                  "name": "settings",
                  "type": "Object",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "settings",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>The <code>setupMaster</code> is used to change the default &apos;fork&apos; behavior. It takes\none option object argument.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var cluster = require(&quot;cluster&quot;);\ncluster.setupMaster({\n  exec : &quot;worker.js&quot;,\n  args : [&quot;--use&quot;, &quot;https&quot;],\n  silent : true\n});\ncluster.autoFork();</code></pre>\n"
        },
        {
          "textRaw": "cluster.fork([env])",
          "type": "method",
          "name": "fork",
          "signatures": [
            {
              "return": {
                "textRaw": "return {Worker object} ",
                "name": "return",
                "type": "Worker object"
              },
              "params": [
                {
                  "textRaw": "`env` {Object} Key/value pairs to add to child process environment. ",
                  "name": "env",
                  "type": "Object",
                  "desc": "Key/value pairs to add to child process environment.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "env",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Spawn a new worker process. This can only be called from the master process.\n\n</p>\n"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Worker",
          "type": "class",
          "name": "Worker",
          "desc": "<p>A Worker object contains all public information and method about a worker.\nIn the master it can be obtained using <code>cluster.workers</code>. In a worker\nit can be obtained using <code>cluster.worker</code>.\n\n</p>\n",
          "properties": [
            {
              "textRaw": "`uniqueID` {String} ",
              "name": "uniqueID",
              "desc": "<p>Each new worker is given its own unique id, this id is stored in the\n<code>uniqueID</code>.\n\n</p>\n<p>While a worker is alive, this is the key that indexes it in\ncluster.workers\n\n</p>\n"
            },
            {
              "textRaw": "`process` {ChildProcess object} ",
              "name": "process",
              "desc": "<p>All workers are created using <code>child_process.fork()</code>, the returned object\nfrom this function is stored in process.\n\n</p>\n<p>See: <a href=\"child_process.html\">Child Process module</a>\n\n</p>\n"
            },
            {
              "textRaw": "`suicide` {Boolean} ",
              "name": "suicide",
              "desc": "<p>This property is a boolean. It is set when a worker dies, until then it is\n<code>undefined</code>.  It is true if the worker was killed using the <code>.destroy()</code>\nmethod, and false otherwise.\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "worker.send(message, [sendHandle])",
              "type": "method",
              "name": "send",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle object} ",
                      "name": "sendHandle",
                      "type": "Handle object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>This function is equal to the send methods provided by\n<code>child_process.fork()</code>.  In the master you should use this function to\nsend a message to a specific worker.  However in a worker you can also use\n<code>process.send(message)</code>, since this is the same function.\n\n</p>\n<p>This example will echo back all messages from the master:\n\n</p>\n<pre><code>if (cluster.isMaster) {\n  var worker = cluster.fork();\n  worker.send(&apos;hi there&apos;);\n\n} else if (cluster.isWorker) {\n  process.on(&apos;message&apos;, function (msg) {\n    process.send(msg);\n  });\n}</code></pre>\n"
            },
            {
              "textRaw": "worker.destroy()",
              "type": "method",
              "name": "destroy",
              "desc": "<p>This function will kill the worker, and inform the master to not spawn a\nnew worker.  To know the difference between suicide and accidentally death\na suicide boolean is set to true.\n\n</p>\n<pre><code>cluster.on(&apos;death&apos;, function (worker) {\n  if (worker.suicide === true) {\n    console.log(&apos;Oh, it was just suicide\\&apos; – no need to worry&apos;).\n  }\n});\n\n// destroy worker\nworker.destroy();</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "params": [],
              "desc": "<p>This event is the same as the one provided by <code>child_process.fork()</code>.\nIn the master you should use this event, however in a worker you can also use\n<code>process.on(&apos;message&apos;)</code>\n\n</p>\n<p>As an example, here is a cluster that keeps count of the number of requests\nin the master process using the message system:\n\n</p>\n<pre><code>var cluster = require(&apos;cluster&apos;);\nvar http = require(&apos;http&apos;);\n\nif (cluster.isMaster) {\n\n  // Keep track of http requests\n  var numReqs = 0;\n  setInterval(function() {\n    console.log(&quot;numReqs =&quot;, numReqs);\n  }, 1000);\n\n  // Count requestes\n  var messageHandler = function (msg) {\n    if (msg.cmd &amp;&amp; msg.cmd == &apos;notifyRequest&apos;) {\n      numReqs += 1;\n    }\n  };\n\n  // Start workers and listen for messages containing notifyRequest\n  cluster.autoFork();\n  Object.keys(cluster.workers).forEach(function (uniqueID) {\n    cluster.workers[uniqueID].on(&apos;message&apos;, messageHandler);\n  });\n\n} else {\n\n  // Worker processes have a http server.\n  http.Server(function(req, res) {\n    res.writeHead(200);\n    res.end(&quot;hello world\\n&quot;);\n\n    // notify master about the request\n    process.send({ cmd: &apos;notifyRequest&apos; });\n  }).listen(8000);\n}</code></pre>\n"
            },
            {
              "textRaw": "Event: 'online'",
              "type": "event",
              "name": "online",
              "params": [],
              "desc": "<p>Same as the <code>cluster.on(&apos;online&apos;)</code> event, but emits only when the state change\non the specified worker.\n\n</p>\n<pre><code>cluster.fork().on(&apos;online&apos;, function (worker) {\n  // Worker is online\n};</code></pre>\n"
            },
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "params": [],
              "desc": "<p>Same as the <code>cluster.on(&apos;listening&apos;)</code> event, but emits only when the state change\non the specified worker.\n\n</p>\n<pre><code>cluster.fork().on(&apos;listening&apos;, function (worker) {\n  // Worker is listening\n};</code></pre>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Cluster"
    }
  ],
  "stability": 3,
  "stabilityText": "Stable"
}
