{
  "source": "doc/api/child_process-es.markdown",
  "modules": [
    {
      "textRaw": "Child Process",
      "name": "child_process",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<p>Node proporciona un <code>popen(3)</code> tri-direccional a través del\nmódulo <code>ChildProcess</code>.\n\n</p>\n<p>Es posible pasar un stream de datos a través del <code>stdin</code>, <code>stdout</code>, y\n<code>stderr</code> del proceso hijo (child) de manera totalmente sin bloqueo.\n\n</p>\n<p>Para crear un proceso hijo utilice <code>require(&apos;child_process&apos;).spawn()</code> o\n<code>require(&apos;child_process&apos;).fork()</code>.  La semántica de cada uno son un poco\ndiferente, y se explica a continuación.\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: ChildProcess",
          "type": "class",
          "name": "ChildProcess",
          "desc": "<p><code>ChildProcess</code> es <code>EventEmitter</code>.\n\n</p>\n<p>Los procesos hijo siempre tienen tres streams asociados a ellos. <code>child.stdin</code>,\n<code>child.stdout</code>, y <code>child.stderr</code>.  These may be shared with the stdio\nstreams of the parent process, or they may be separate stream objects\nwhich can be piped to and from.\n\n</p>\n<p>The ChildProcess class is not intended to be used directly.  Use the\n<code>spawn()</code> or <code>fork()</code> methods to create a Child Process instance.\n\n</p>\n",
          "modules": [
            {
              "textRaw": "Evento:  'exit'",
              "name": "evento:_'exit'",
              "desc": "<p>Este evento es emitido después de termine el proceso hijo. Si el proceso terminó\nde manera normal, <code>code</code> es el código de salida final, en caso contrario <code>null</code>. Si\nel proceso terminó debido al recibo de una señal, <code>signal</code> es el nombre string de\nla señal, en caso contrario <code>null</code>.\n\n</p>\n<p>Véase <code>waitpid(2)</code>.\n\n</p>\n",
              "type": "module",
              "displayName": "Evento:  'exit'"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'disconnect'",
              "type": "event",
              "name": "disconnect",
              "desc": "<p>This event is emitted after using the <code>.disconnect()</code> method in the parent or\nin the child. After disconnecting it is no longer possible to send messages.\nAn alternative way to check if you can send messages is to see if the\n<code>child.connected</code> property is <code>true</code>.\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "`stdin` {Stream object} ",
              "name": "stdin",
              "desc": "<p>Un <code>Stream de Escritura</code> que representa el <code>stdin</code> del proceso hijo.\nCerrar este stream vía <code>end()</code> a menudo causa que termine el proceso hijo.\n\n</p>\n<p>If the child stdio streams are shared with the parent, then this will\nnot be set.\n\n</p>\n"
            },
            {
              "textRaw": "`stdout` {Stream object} ",
              "name": "stdout",
              "desc": "<p>Un <code>Stream de Lectura</code> que representa el <code>stdout</code> del proceso hijo.\n\n</p>\n<p>If the child stdio streams are shared with the parent, then this will\nnot be set.\n\n</p>\n"
            },
            {
              "textRaw": "`stderr` {Stream object} ",
              "name": "stderr",
              "desc": "<p>Un <code>Stream de Lectura</code> que representa el <code>stderr</code> del proceso hijo.\n\n</p>\n<p>If the child stdio streams are shared with the parent, then this will\nnot be set.\n\n</p>\n"
            },
            {
              "textRaw": "`pid` {Integer} ",
              "name": "pid",
              "desc": "<p>El PID del proceso hijo.\n\n</p>\n<p>Ejemplo:\n\n</p>\n<pre><code>var spawn = require(&apos;child_process&apos;).spawn,\n    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);\n\nconsole.log(&apos;Spawned child pid: &apos; + grep.pid);\ngrep.stdin.end();</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "child.kill([signal])",
              "type": "method",
              "name": "kill",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`signal` {String} ",
                      "name": "signal",
                      "type": "String",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "signal",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Manda una señal al proceso hijo. Si ningún argumento es dado, el proceso \nenviará <code>&apos;SIGTERM&apos;</code>. Véase <code>signal(7)</code> para una lista de señales disponibles.\n\n</p>\n<pre><code>var spawn = require(&apos;child_process&apos;).spawn,\n    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);\n\ngrep.on(&apos;exit&apos;, function (code, signal) {\n  console.log(&apos;child process terminated due to receipt of signal &apos;+signal);\n});\n\n// send SIGHUP to process\ngrep.kill(&apos;SIGHUP&apos;);</code></pre>\n<p>Observa que mientras la función se llama <code>kill</code>, la señal entregada al proceso hijo\npuede o no terminarlo.  <code>kill</code> realmente solo manda una señal a un proceso.\n\n</p>\n<p>Véase <code>kill(2)</code>\n\n\n</p>\n"
            },
            {
              "textRaw": "child.send(message, [sendHandle])",
              "type": "method",
              "name": "send",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle object} ",
                      "name": "sendHandle",
                      "type": "Handle object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Send a message (and, optionally, a handle object) to a child process.\n\n</p>\n<p>See <code>child_process.fork()</code> for details.\n\n</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "child_process.spawn(command, [args], [options])",
          "type": "method",
          "name": "spawn",
          "signatures": [
            {
              "return": {
                "textRaw": "return: {ChildProcess object} ",
                "name": "return",
                "type": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`command` {String} The command to run ",
                  "name": "command",
                  "type": "String",
                  "desc": "The command to run"
                },
                {
                  "textRaw": "`args` {Array} List of string arguments ",
                  "name": "args",
                  "type": "Array",
                  "desc": "List of string arguments",
                  "optional": true
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "command"
                },
                {
                  "name": "args",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Inicia un nuevo proceso con el <code>command</code> proporcionado, con argumentos de linea de comandos <code>args</code>.\nSi es omitido, <code>args</code> por defecto sera un Array vacío.\n\n</p>\n<p>El tercer argumento es usado para especificar opciones adicionales, que por defecto serán:\n\n</p>\n<pre><code>{ cwd: undefined,\n  env: process.env\n}</code></pre>\n<p><code>cwd</code> te deja especificar el directorio actual de trabajo del cual es iniciado el proceso.\nUsa <code>env</code> para especificar variables de entorno que serán visibles al nuevo proceso.\n\n</p>\n<p>Ejemplo ejecutando <code>ls -lh /usr</code>, capturando <code>stdout</code>, <code>stderr</code>, y el codigo de salida:\n\n</p>\n<pre><code>var util  = require(&apos;util&apos;),\n    spawn = require(&apos;child_process&apos;).spawn,\n    ls    = spawn(&apos;ls&apos;, [&apos;-lh&apos;, &apos;/usr&apos;]);\n\nls.stdout.on(&apos;data&apos;, function (data) {\n  console.log(&apos;stdout: &apos; + data);\n});\n\nls.stderr.on(&apos;data&apos;, function (data) {\n  console.log(&apos;stderr: &apos; + data);\n});\n\nls.on(&apos;exit&apos;, function (code) {\n  console.log(&apos;child process exited with code &apos; + code);\n});</code></pre>\n<p>Ejemplo: Una manera muy elaborada de ejecutar &apos;ps ax | grep ssh&apos;\n\n</p>\n<pre><code>var util  = require(&apos;util&apos;),\n    spawn = require(&apos;child_process&apos;).spawn,\n    ps    = spawn(&apos;ps&apos;, [&apos;ax&apos;]),\n    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);\n\nps.stdout.on(&apos;data&apos;, function (data) {\n  grep.stdin.write(data);\n});\n\nps.stderr.on(&apos;data&apos;, function (data) {\n  console.log(&apos;ps stderr: &apos; + data);\n});\n\nps.on(&apos;exit&apos;, function (code) {\n  if (code !== 0) {\n    console.log(&apos;ps process exited with code &apos; + code);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.on(&apos;data&apos;, function (data) {\n  console.log(data);\n});\n\ngrep.stderr.on(&apos;data&apos;, function (data) {\n  console.log(&apos;grep stderr: &apos; + data);\n});\n\ngrep.on(&apos;exit&apos;, function (code) {\n  if (code !== 0) {\n    console.log(&apos;grep process exited with code &apos; + code);\n  }\n});</code></pre>\n<p>Ejemplo de comprobar por ejecución fallida:\n\n</p>\n<pre><code>var spawn = require(&apos;child_process&apos;).spawn,\n    child = spawn(&apos;bad_command&apos;);\n\nchild.stderr.setEncoding(&apos;utf8&apos;);\nchild.stderr.on(&apos;data&apos;, function (data) {\n  if (/^execvp\\(\\)/.test(data)) {\n    console.log(&apos;Failed to start child process.&apos;);\n  }\n});</code></pre>\n<p>Note that if spawn receives an empty options object, it will result in\nspawning the process with an empty environment rather than using\n<code>process.env</code>. This due to backwards compatibility issues with a deprecated\nAPI.\n\n</p>\n<p>There is a deprecated option called <code>customFds</code> which allows one to specify\nspecific file descriptors for the stdio of the child process. This API was\nnot portable to all platforms and therefore removed.\nWith <code>customFds</code> it was possible to hook up the new process&apos; <code>[stdin, stdout,\nstderr]</code> to existing streams; <code>-1</code> meant that a new stream should be created.\nUse at your own risk.\n\n</p>\n<p>There are several internal options. In particular <code>stdinStream</code>,\n<code>stdoutStream</code>, <code>stderrStream</code>. They are for INTERNAL USE ONLY. As with all\nundocumented APIs in Node, they should not be used.\n\n</p>\n<p>Véase tambien: <code>child_process.exec()</code> y <code>child_process.fork()</code>\n\n</p>\n"
        },
        {
          "textRaw": "child_process.exec(command, [options], callback)",
          "type": "method",
          "name": "exec",
          "signatures": [
            {
              "return": {
                "textRaw": "Return: ChildProcess object ",
                "name": "return",
                "desc": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`command` {String} The command to run, with space-separated arguments ",
                  "name": "command",
                  "type": "String",
                  "desc": "The command to run, with space-separated arguments"
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    },
                    {
                      "textRaw": "`encoding` {String} (Default: 'utf8') ",
                      "name": "encoding",
                      "default": "utf8",
                      "type": "String"
                    },
                    {
                      "textRaw": "`timeout` {Number} (Default: 0) ",
                      "name": "timeout",
                      "default": "0",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`maxBuffer` {Number} (Default: 200*1024) ",
                      "name": "maxBuffer",
                      "default": "200*1024",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`killSignal` {String} (Default: 'SIGTERM') ",
                      "name": "killSignal",
                      "default": "SIGTERM",
                      "type": "String"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} called with the output when process terminates ",
                  "options": [
                    {
                      "textRaw": "`code` {Integer} Exit code ",
                      "name": "code",
                      "type": "Integer",
                      "desc": "Exit code"
                    },
                    {
                      "textRaw": "`stdout` {Buffer} ",
                      "name": "stdout",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`stderr` {Buffer} ",
                      "name": "stderr",
                      "type": "Buffer"
                    }
                  ],
                  "name": "callback",
                  "type": "Function",
                  "desc": "called with the output when process terminates"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "command"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Runs a command in a shell and buffers the output.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;),\n    exec = require(&apos;child_process&apos;).exec,\n    child;\n\nchild = exec(&apos;cat *.js bad_file | wc -l&apos;,\n  function (error, stdout, stderr) {\n    console.log(&apos;stdout: &apos; + stdout);\n    console.log(&apos;stderr: &apos; + stderr);\n    if (error !== null) {\n      console.log(&apos;exec error: &apos; + error);\n    }\n});</code></pre>\n<p>El callback recibe los argumentos <code>(error, stdout, stderr)</code>. Cuando termina\ncon éxito, <code>error</code> sera <code>null</code>.  Cuando termina con error, <code>error</code> sera una \ninstancia de <code>Error</code> y <code>err.code</code> sera el código de salida del proceso hijo,\ny <code>err.signal</code> sera la señal que terminó el proceso.\n\n</p>\n<p>Hay un segundo argumento opcional para especificar varias opciones. Las \nopciones predeterminadas son\n\n</p>\n<pre><code>{ encoding: &apos;utf8&apos;,\n  timeout: 0,\n  maxBuffer: 200*1024,\n  killSignal: &apos;SIGTERM&apos;,\n  cwd: null,\n  env: null }</code></pre>\n<p>Si <code>timeout</code> es mayor que 0, entonces detendrá el proceso hijo \nsi este se ejecuta mas de <code>timeout</code> milisegundos. El proceso hijo se detiene con\n<code>killSignal</code> (por defecto: <code>&apos;SIGTERM&apos;</code>). <code>maxBuffer</code> especifica la mayor cantidad\nde datos permitidos en stdout o stderr - si este valor se excede el proceso hijo\nsera terminado.\n\n\n</p>\n"
        },
        {
          "textRaw": "child_process.execFile(file, args, options, callback)",
          "type": "method",
          "name": "execFile",
          "signatures": [
            {
              "return": {
                "textRaw": "Return: ChildProcess object ",
                "name": "return",
                "desc": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`file` {String} The filename of the program to run ",
                  "name": "file",
                  "type": "String",
                  "desc": "The filename of the program to run"
                },
                {
                  "textRaw": "`args` {Array} List of string arguments ",
                  "name": "args",
                  "type": "Array",
                  "desc": "List of string arguments"
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    },
                    {
                      "textRaw": "`encoding` {String} (Default: 'utf8') ",
                      "name": "encoding",
                      "default": "utf8",
                      "type": "String"
                    },
                    {
                      "textRaw": "`timeout` {Number} (Default: 0) ",
                      "name": "timeout",
                      "default": "0",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`maxBuffer` {Number} (Default: 200*1024) ",
                      "name": "maxBuffer",
                      "default": "200*1024",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`killSignal` {String} (Default: 'SIGTERM') ",
                      "name": "killSignal",
                      "default": "SIGTERM",
                      "type": "String"
                    }
                  ],
                  "name": "options",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} called with the output when process terminates ",
                  "options": [
                    {
                      "textRaw": "`code` {Integer} Exit code ",
                      "name": "code",
                      "type": "Integer",
                      "desc": "Exit code"
                    },
                    {
                      "textRaw": "`stdout` {Buffer} ",
                      "name": "stdout",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`stderr` {Buffer} ",
                      "name": "stderr",
                      "type": "Buffer"
                    }
                  ],
                  "name": "callback",
                  "type": "Function",
                  "desc": "called with the output when process terminates"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "args"
                },
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>This is similar to <code>child_process.exec()</code> except it does not execute a\nsubshell but rather the specified file directly. This makes it slightly\nleaner than <code>child_process.exec</code>. It has the same options.\n\n\n</p>\n"
        },
        {
          "textRaw": "child_process.fork(modulePath, [args], [options])",
          "type": "method",
          "name": "fork",
          "signatures": [
            {
              "return": {
                "textRaw": "Return: ChildProcess object ",
                "name": "return",
                "desc": "ChildProcess object"
              },
              "params": [
                {
                  "textRaw": "`modulePath` {String} The module to run in the child ",
                  "name": "modulePath",
                  "type": "String",
                  "desc": "The module to run in the child"
                },
                {
                  "textRaw": "`args` {Array} List of string arguments ",
                  "name": "args",
                  "type": "Array",
                  "desc": "List of string arguments",
                  "optional": true
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`cwd` {String} Current working directory of the child process ",
                      "name": "cwd",
                      "type": "String",
                      "desc": "Current working directory of the child process"
                    },
                    {
                      "textRaw": "`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) ",
                      "name": "customFds",
                      "type": "Array",
                      "desc": "**Deprecated** File descriptors for the child to use for stdio.  (See below)"
                    },
                    {
                      "textRaw": "`env` {Object} Environment key-value pairs ",
                      "name": "env",
                      "type": "Object",
                      "desc": "Environment key-value pairs"
                    },
                    {
                      "textRaw": "`setsid` {Boolean} ",
                      "name": "setsid",
                      "type": "Boolean"
                    },
                    {
                      "textRaw": "`encoding` {String} (Default: 'utf8') ",
                      "name": "encoding",
                      "default": "utf8",
                      "type": "String"
                    },
                    {
                      "textRaw": "`timeout` {Number} (Default: 0) ",
                      "name": "timeout",
                      "default": "0",
                      "type": "Number"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} called with the output when process terminates ",
                  "options": [
                    {
                      "textRaw": "`code` {Integer} Exit code ",
                      "name": "code",
                      "type": "Integer",
                      "desc": "Exit code"
                    },
                    {
                      "textRaw": "`stdout` {Buffer} ",
                      "name": "stdout",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`stderr` {Buffer} ",
                      "name": "stderr",
                      "type": "Buffer"
                    }
                  ],
                  "name": "callback",
                  "type": "Function",
                  "desc": "called with the output when process terminates"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "modulePath"
                },
                {
                  "name": "args",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>This is a special case of the <code>spawn()</code> functionality for spawning Node\nprocesses. In addition to having all the methods in a normal ChildProcess\ninstance, the returned object has a communication channel built-in. The\nchannel is written to with <code>child.send(message, [sendHandle])</code> and messages\nare received by a <code>&apos;message&apos;</code> event on the child.\n\n</p>\n<p>For example:\n\n</p>\n<pre><code>var cp = require(&apos;child_process&apos;);\n\nvar n = cp.fork(__dirname + &apos;/sub.js&apos;);\n\nn.on(&apos;message&apos;, function(m) {\n  console.log(&apos;PARENT got message:&apos;, m);\n});\n\nn.send({ hello: &apos;world&apos; });</code></pre>\n<p>And then the child script, <code>&apos;sub.js&apos;</code> might look like this:\n\n</p>\n<pre><code>process.on(&apos;message&apos;, function(m) {\n  console.log(&apos;CHILD got message:&apos;, m);\n});\n\nprocess.send({ foo: &apos;bar&apos; });</code></pre>\n<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>\nwill emit objects each time it receives a message on its channel.\n\n</p>\n<p>There is a special case when sending a <code>{cmd: &apos;NODE_foo&apos;}</code> message. All messages\ncontaining a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in\nthe <code>message</code> event, since they are internal messages used by node core.\nMessages containing the prefix are emitted in the <code>internalMessage</code> event, you\nshould by all means avoid using this feature, it may change without warranty.\n\n</p>\n<p>By default the spawned Node process will have the stdout, stderr associated\nwith the parent&apos;s. To change this behavior set the <code>silent</code> property in the\n<code>options</code> object to <code>true</code>.\n\n</p>\n<p>These child Nodes are still whole new instances of V8. Assume at least 30ms\nstartup and 10mb memory for each new Node. That is, you cannot create many\nthousands of them.\n\n</p>\n<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a handle object to\nanother process. Child will receive the handle as as second argument to the\n<code>message</code> event. Here is an example of sending a handle:\n\n</p>\n<pre><code>var server = require(&apos;net&apos;).createServer();\nvar child = require(&apos;child_process&apos;).fork(__dirname + &apos;/child.js&apos;);\n// Open up the server object and send the handle.\nserver.listen(1337, function() {\n  child.send({ server: true }, server._handle);\n});</code></pre>\n<p>Here is an example of receiving the server handle and sharing it between\nprocesses:\n\n</p>\n<pre><code>process.on(&apos;message&apos;, function(m, serverHandle) {\n  if (serverHandle) {\n    var server = require(&apos;net&apos;).createServer();\n    server.listen(serverHandle);\n  }\n});</code></pre>\n<p>To close the IPC connection between parent and child use the\n<code>child.disconnect()</code> method. This allows the child to exit gracefully since\nthere is no IPC channel keeping it alive. When calling this method the\n<code>disconnect</code> event will be emitted in both parent and child, and the\n<code>connected</code> flag will be set to <code>false</code>. Please note that you can also call\n<code>process.disconnect()</code> in the child process.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Child Process"
    }
  ]
}
