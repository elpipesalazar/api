<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Módulos Node.js v0.6.19 Manual &amp; Documentación</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/modules-es.html">
</head>
<body class="alt apidoc" id="api-section-modules-es">
    <div id="bar"><span>es</span><a title="Documentación en inglés" class="mark mark-es" href="en/modules.html">en</a></div>
    <div id="intro" class="interior">
        <a href="http://www.nodejs.es/" title="Volder el site nodejs.es">
            <img id="logo" src="images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
      <div id="column2" class="interior">
        <div class="official-nodejs-es menu-block">
          <h2>Nodejs.es</h2>
            <ul>
                <li><a href="http://www.nodejs.es/" class="home">Home</a></li>
                <li><a href="http://api.nodejs.es" class="docs current">Docs</a></li>
                <li><a href="http://trabajos.nodejs.es/" class="jobs">Trabajos</a></li>
                <li><a href="https://github.com/nodejs-es/node/" class="download">GitHub</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs_es">@nodejs_es</a></p>
        </div>

        <div class="official-site menu-block">
          <h2>Sitio Oficial</h2>
            <ul>
                <li><a href="http://www.nodejs.org/" class="home">Home</a></li>
                <li><a href="http://www.nodejs.org/#download" class="download">Descargar</a></li>
                <li><a href="http://www.nodejs.org/about/" class="about">Acerca</a></li>
                <li><a href="http://search.npmjs.org/" class="npm">Registo npm</a></li>
                <li><a href="http://nodejs.org/api/" class="docs">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="http://www.nodejs.org/community/" class="community">Comunidad</a></li>
                <li><a href="http://www.nodejs.org/logos/" class="logos">Logos</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Trabajos</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>
      </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.6.19 Manual &amp; Documentación</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Índice</a> |
                <a href="all.html">Ver todo en una misma página</a> |
                <a href="modules-es.json">Ver como JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Tabla de Contenidos</h2>
            <ul>
<li><a href="#modules_es_m_dulos">Módulos</a><ul>
<li><a href="#modules_es_m_dulos_b_sicos">Módulos básicos</a></li>
<li><a href="#modules_es_m_dulo_file">Módulo File</a></li>
<li><a href="#modules_es_cargando_desde_la_carpeta_node_modules">Cargando desde la carpeta <code>node_modules</code></a><ul>
<li><a href="#modules_es_optimizaci_n_de_proceso_de_b_squeda_en_node_modules">Optimización de proceso de búsqueda en <code>node_modules</code></a></li>
</ul>
</li>
<li><a href="#modules_es_carpetas_como_m_dulos">Carpetas como módulos</a></li>
<li><a href="#modules_es_almacenamiento_en_la_cach">Almacenamiento en la caché</a></li>
<li><a href="#modules_es_todos_juntos">Todos juntos...</a></li>
<li><a href="#modules_es_cargar_desde_las_carpetas_de_require_paths">Cargar desde las carpetas de <code>require.paths</code></a><ul>
<li><a href="#modules_es_nota_por_favor_evite_la_modificaci_n_de_require_paths"><strong>Nota:</strong> Por favor evite la modificación de <code>require.paths</code></a><ul>
<li><a href="#modules_es_establecer_require_paths_a_alg_n_otro_valor_para_nada">Establecer <code>require.paths</code> a algún otro valor para nada.</a></li>
<li><a href="#modules_es_poner_rutas_relativas_en_require_paths_es_raro">Poner rutas relativas en <code>require.paths</code> es... raro.</a></li>
<li><a href="#modules_es_cero_aislamiento">Cero aislamiento</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#modules_es_addenda_consejos_para_administrar_paquetes">Addenda: Consejos para administrar paquetes</a></li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>Módulos<span><a class="mark" href="#modules_es_m_dulos" id="modules_es_m_dulos">#</a></span></h1>
<p>Node posee un secillo sistema de carga.  En Node, los ficheros y módulos son de
correspondencia biunívoca.  A modo de ejemplo, <code>foo.js</code> carga el módulo
<code>circle.js</code> en el mismo directorio.

</p>
<p>El contenido de <code>foo.js</code>:

</p>
<pre><code>var circle = require(&apos;./circle.js&apos;);
console.log( &apos;El área de un círculo con radio 4 es &apos;
           + circle.area(4));</code></pre>
<p>El contenido de <code>circle.js</code>:

</p>
<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>
<p>El módulo <code>circle.js</code> ha exportado las functiones <code>area()</code> y
<code>circumference()</code>.  Para exportar a un objeto, debe añadir el objeto especial
<code>exports</code>.


</p>
<p>Las variables locales del módulo serán privadas. En este ejemplo la variable <code>PI</code> es
privada en <code>circle.js</code>.

</p>
<h2>Módulos básicos<span><a class="mark" href="#modules_es_m_dulos_b_sicos" id="modules_es_m_dulos_b_sicos">#</a></span></h2>
<p>Node posee varios módulos compilados en binario.  Estos módulos son
descritos con más detalle en las siguientes secciones del documento.

</p>
<p>Los módulos básicos son definidos en el código fuente de node en la carpeta <code>lib/</code>.

</p>
<p>Los módulos básicos tienen la preferencia de cargarse primero si su indentificador es
pasado desde <code>require()</code>. Por ejemplo, <code>require(&apos;http&apos;)</code> siempre
devolverá lo construido en el módulo HTTP, incluso si hay un fichero con ese nombre.

</p>
<h2>Módulo File<span><a class="mark" href="#modules_es_m_dulo_file" id="modules_es_m_dulo_file">#</a></span></h2>
<p>Si el nombre exacto del fichero no es encontrado, entonces node intentará cargar 
el nombre del fichero seguido de la extensión <code>.js</code>, y a continuación con <code>.node</code>.

</p>
<p>Los ficheros <code>.js</code> son interpretados como ficheros de texto en JavaScript, y los ficheros <code>.node</code>
son interpretados como extensiones de módulos compilados cargados con <code>dlopen</code>.

</p>
<p>Un módulo con el prefijo <code>&apos;/&apos;</code> indica la ruta absoluta al fichero.  Por
ejemplo, <code>require(&apos;/home/marco/foo.js&apos;)</code> cargará el fichero en
<code>/home/marco/foo.js</code>.

</p>
<p>Un módulo con el prefijo <code>&apos;./&apos;</code> es relativo al fichero llamado con <code>require()</code>.
Es decir, <code>circle.js</code> debe estar en el mismo directorio que <code>foo.js</code> para que 
<code>require(&apos;./circle&apos;)</code> lo encuentre.

</p>
<p>Si se omite el uso de &apos;/&apos; o &apos;./&apos; en el fichero, el módulo puede ser un
&quot;módulo básico&quot; o se cargará desde la carpeta <code>node_modules</code>.


</p>
<h2>Cargando desde la carpeta <code>node_modules</code><span><a class="mark" href="#modules_es_cargando_desde_la_carpeta_node_modules" id="modules_es_cargando_desde_la_carpeta_node_modules">#</a></span></h2>
<p>Si el identificador del módulo pasa a <code>require()</code> no es un módulo nativo,
y no comienza con <code>&apos;/&apos;</code>, <code>&apos;../&apos;</code>, o <code>&apos;./&apos;</code>, entonces node inicia en el 
directorio principal del módulo actual, y añade <code>/node_modules</code>, e
intenta cargar el módulo desde esa ubicación.

</p>
<p>Si no se encuentra, entonces se dirige al directorio principal, y así 
sucesivamente, hasta que el módulo es encontrado, hasta en la raíz del árbol es
encontrado.

</p>
<p>Por ejemplo, si el fichero en <code>&apos;/home/ry/projects/foo.js&apos;</code> es llamado como
<code>require(&apos;bar.js&apos;)</code>, entonces node buscaría en las siguientes ubicaciones, en
este orden:

</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>Esto permite que los programas encuentren sus dependencias, de modo que no
entren en conflicto.


</p>
<h3>Optimización de proceso de búsqueda en <code>node_modules</code><span><a class="mark" href="#modules_es_optimizaci_n_de_proceso_de_b_squeda_en_node_modules" id="modules_es_optimizaci_n_de_proceso_de_b_squeda_en_node_modules">#</a></span></h3>
<p>Cuando existen muchos niveles de dependencias anidadas, es posible que los
árboles de directorios tomen bastante tiempo. Las siguientes optimizaciones se
realizan para este proceso.

</p>
<p>Primero, <code>/node_modules</code> no debe ser anexado a una carpeta ya que termina en
<code>/node_modules</code>.

</p>
<p>Segundo, si el fichero es llamado con  <code>require()</code> ya esta en la jerarquía de
<code>node_modules</code>, entonces el nivel superior de la carpeta <code>node_modules</code> es tratada como
la raíz del árbol de búsqueda.

</p>
<p>For example, if the file at
<code>&apos;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&apos;</code>
called <code>require(&apos;asdf.js&apos;)</code>, then node would search the following
locations:

</p>
<p>Por ejemplo, si el fichero en
<code>&apos;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&apos;</code>
llama como <code>require(&apos;asdf.js&apos;)</code>, entonces node buscaría en las siguientes
ubicaciones:

</p>
<ul>
<li><code>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/asdf.js</code></li>
<li><code>/home/ry/projects/foo/node_modules/bar/node_modules/asdf.js</code></li>
<li><code>/home/ry/projects/foo/node_modules/asdf.js</code></li>
</ul>
<h2>Carpetas como módulos<span><a class="mark" href="#modules_es_carpetas_como_m_dulos" id="modules_es_carpetas_como_m_dulos">#</a></span></h2>
<p>Es conveniente organizar los programas y librerías en los mismos directorios,
y proporcionar un único punto de entrar a la biblioteca.
Existe tres formas en donde una carpeta pueda usar <code>require()</code> como
un argumento.

</p>
<p>Lo primero es crear el fichero <code>package.json</code>en la raíz de la carpeta,
que especifique el módulo <code>main</code>. Un ejemplo de package.json podría verse
como esto:


</p>
<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>
<p>Si fuera una carpeta en <code>./some-library</code>, entonces
<code>require(&apos;./some-library&apos;)</code> trataría de cargar
<code>./some-library/lib/some-library.js</code>.

</p>
<p>Este es el mayor grado de conciencia de Node con el fichero package.json .

</p>
<p>Si no hay ningún fichero package.json presente en el directorio, entonces node
intentará cargar el fichero <code>index.js</code> o <code>index.node</code> de ese directorio.
Por ejemplo, si no hay ninguín fichero package.json en el ejemplo anterior,
entonces <code>require(&apos;./some-library&apos;)</code> intentará cargar:

</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>
<h2>Almacenamiento en la caché<span><a class="mark" href="#modules_es_almacenamiento_en_la_cach" id="modules_es_almacenamiento_en_la_cach">#</a></span></h2>
<p>Los módulos se alamacenan en la caché después que fueron cargados por primera vez.
Esto significa (entre otras cosas) que todas las llamadas a <code>require(&apos;foo&apos;)</code> devuelve
el mismo ojecto exacto, si se resolvería en el mismo fichero

</p>
<h2>Todos juntos...<span><a class="mark" href="#modules_es_todos_juntos" id="modules_es_todos_juntos">#</a></span></h2>
<p>Para obtener el nombre exacto del fichero que se cargará cuando se llame con <code>require()</code>, use
la función <code>require.resolve()</code>.

</p>
<p>Uniendo todo lo anterior, aquí se muestra un algoritmo de alto nievel
en pseudocódigo de lo que haría require.resolve :

</p>
<pre><code>require(X)
1. Si X es módulo básico,
   a. devolver el módulo básico
   b. STOP
2. Si X inicia con con `./` or `/`,
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

LOAD_AS_FILE(X)
1. Si X es un fichero, cargar X como texto JavaScript.  STOP
2. Si X.js es un fichero, cargar X.js como texto JavaScript.  STOP
3. Si X.node es un fichero, cargar X.node como extensión binaria.  STOP

LOAD_AS_DIRECTORY(X)
1. Si X/package.json es un fichero,
   a. Parsear X/package.json, y buscar el campo &quot;main&quot;.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. LOAD_AS_FILE(X/index)

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index es una instancia de &quot;node_modules&quot; en PARTS, o 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
6. return DIRS</code></pre>
<h2>Cargar desde las carpetas de <code>require.paths</code><span><a class="mark" href="#modules_es_cargar_desde_las_carpetas_de_require_paths" id="modules_es_cargar_desde_las_carpetas_de_require_paths">#</a></span></h2>
<p>En node, <code>require.paths</code> es un array de strings que representa las rutas de
acceso a los módulos cuando estos no tienen el prefijo <code>&apos;/&apos;</code>, <code>&apos;./&apos;</code>, o
<code>&apos;../&apos;</code>.  Por ejemplo, si establece require.paths como:

</p>
<pre><code>[ &apos;/home/micheil/.node_modules&apos;,
  &apos;/usr/local/lib/node_modules&apos; ]</code></pre>
<p>A continuación se llama a <code>require(&apos;bar/baz.js&apos;)</code> y buscará en las siguientes
ubicaciones:

</p>
<ul>
<li>1: <code>&apos;/home/micheil/.node_modules/bar/baz.js&apos;</code></li>
<li>2: <code>&apos;/usr/local/lib/node_modules/bar/baz.js&apos;</code></li>
</ul>
<p>El array en <code>require.paths</code> puede ser transformado en tiempo de ejecución para modificar
este comportamiento.

</p>
<p>Se establece inicialmente la variable de entorno <code>NODE_PATH</code>, que contiene 
una lista delimitada por dos puntos de rutas exactas.  En el anterior ejemplo,
la variable de entorno <code>NODE_PATH</code> puedo haber sido establecido como:

</p>
<pre><code>/home/micheil/.node_modules:/usr/local/lib/node_modules</code></pre>
<p>Cargar las ubicaciones desde <code>require.paths</code> sólo se realiza si el
módulon no se ha encontrado desde el algoritmo <code>node_modules</code>.
Los módulos globarles son de baja prioridad para las dependencias de los paquetes.

</p>
<h3><strong>Nota:</strong> Por favor evite la modificación de <code>require.paths</code><span><a class="mark" href="#modules_es_nota_por_favor_evite_la_modificaci_n_de_require_paths" id="modules_es_nota_por_favor_evite_la_modificaci_n_de_require_paths">#</a></span></h3>
<p>Por razones de compatibilidad, <code>require.paths</code> sigue siendo la primera prioridad
en el proceso de búsqueda de módulos. Sin embargo, puede desaparecer en una próxima
versión.

</p>
<p>Aunque parecía una buena idea en aquel tiempo, y ha permitido ser un 
experimento muy útil, en la práctica la transformación de <code>require.paths</code> es una
lista a menudo con problemas y dolores de cabeza.

</p>
<h4>Establecer <code>require.paths</code> a algún otro valor para nada.<span><a class="mark" href="#modules_es_establecer_require_paths_a_alg_n_otro_valor_para_nada" id="modules_es_establecer_require_paths_a_alg_n_otro_valor_para_nada">#</a></span></h4>
<p>Esto no hace nada de lo que se podría esperar:

</p>
<pre><code>require.paths = [ &apos;/usr/lib/node&apos; ];</code></pre>
<p>Todo lo que se hace aquí es perder la referencia <em>actual</em> de node en la búsqueda
de rutas, y crea una nueva referencia a otra cosa que no sirve
para nada.

</p>
<h4>Poner rutas relativas en <code>require.paths</code> es... raro.<span><a class="mark" href="#modules_es_poner_rutas_relativas_en_require_paths_es_raro" id="modules_es_poner_rutas_relativas_en_require_paths_es_raro">#</a></span></h4>
<p>Si hace esto:

</p>
<pre><code>require.paths.push(&apos;./lib&apos;);</code></pre>
<p>entonces <em>no</em> añada la ruta completa donde se resolvió <code>./lib</code>
en este sistema de ficheros.  En cambio, esto añade literalmente <code>&apos;./lib&apos;</code>,
lo que significa si hace <code>require(&apos;y.js&apos;)</code> en  <code>/a/b/x.js</code>, entonces se ve
en <code>/a/b/lib/y.js</code>.  Si a continuación se usa <code>require(&apos;y.js&apos;)</code> en
<code>/l/m/n/o/p.js</code>, entonces se ve en <code>/l/m/n/o/lib/y.js</code>.

</p>
<p>En la práctica, las personas han usado esto de una manera ad hoc para la
dependencia de paquetes, pero esta técnica es frágil.

</p>
<h4>Cero aislamiento<span><a class="mark" href="#modules_es_cero_aislamiento" id="modules_es_cero_aislamiento">#</a></span></h4>
<p>Existe (debido a un diseño lamentable), sólo un array <code>require.paths</code> utilizado para
todos los módulos.

</p>
<p>Como resultado, si un programa en node trata de confiar de este comportamiento, es posible
que de manera permanente y sutilmente altere el comportamiento de todos los programas 
escritos en node el mismo proceso. A media que el stack crece, y se reune más
funcionalidades, ya que esto es un problema con las partes que interactúan en forma
difíciles de predecir.

</p>
<h2>Addenda: Consejos para administrar paquetes<span><a class="mark" href="#modules_es_addenda_consejos_para_administrar_paquetes" id="modules_es_addenda_consejos_para_administrar_paquetes">#</a></span></h2>
<p>La semántica de Node en la función <code>require()</code> fue diseñada para ser lo 
suficientemente general para soportar una serie de esctructuras de directorios.
Los paquetes de programas como <code>dpkg</code>, <code>rpm</code>, y <code>npm</code> se esperan que sean construidos 
como paquetes nativos desde los módulos de Node sin modificaciones.

</p>
<p>A continuación sugerimos una estructura en la que puede trabajar:

</p>
<p>Supongamos que se desea tener en 
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> se mantenga el contenido de una
versión específica de un paquete.

</p>
<p>Los paquetes pueden depender uno del otro. Con el fin de instalar el paquete <code>foo</code>, 
puede que tenga que instalar una versión específica del paquete <code>bar</code>.  El paquete
 <code>bar</code> puede tener dependencias, y en algunos casos, estas dependencias, incluso pueden 
entrar en conflicto o crear ciclos.

</p>
<p>Desde la búsqueda con Node de la <code>ruta</code> de cualquier módulo cargado (es decir,
resueltos los enlaces simbólicos), y luego de buscar sus dependencias en la
carpeta <code>node_modules</code> como se describió anteriormente, esta situación es muy simple de 
resolver con la siguiente arquitectura:

</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Contenido del paquete <code>foo</code>, versión 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Contenido del paquete <code>bar</code> que es
dependencia de <code>foo</code>.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Enlace simbólico a
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Enlaces simbólicos a los paquetes
que <code>bar</code> depende.</li>
</ul>
<p>Por lo tanto, incluso si se encuentra, o si hay problemas de dependencias,
cada módulo será capza de obtener una versión de su dependencia para ser
utilizada.

</p>
<p>Cuando el código en el paquete <code>foo</code> utiliza <code>require(&apos;bar&apos;)</code>, se obtendrá la
versión al enlace simbólico en <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Luego, cuando el código del paquete <code>bar</code> llame a <code>require(&apos;quux&apos;)</code>, obtendrá
la versión simbólica en <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.

</p>
<p>Además, para hacer el proceso de búsqueda del módulo aún más óptima, en lugar
de poner los paquetes directamente en <code>/usr/lib/node</code>, se puede poner estos en
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Entonces node no se molestará en
buscar por dependencias no encontradas en <code>/usr/node_modules</code> o <code>/node_modules</code>.

</p>
<p>A fin de que los módulos disponibles para node en REPL, puedan ser útiles,
añade también la carpeta <code>/usr/lib/node_modules</code> a la variable de entorno <code>$NODE_PATH</code>.
Desde el módulo de búsquedas usando la carpeta <code>node_modules</code> donde todo es
relativo, y basado en la ruta real de los ficheros llamados por <code>require()</code>, 
los paquetes pueden ser llamado desde cualquier lugar.
</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <ul class="clearfix">
            <li><a href="http://www.nodejs.org/">Node.js</a></li>
            <li><a href="http://www.nodejs.es/">Node.js en español</a></li>
            <li><a href="http://twitter.com/nodejs_es" class="twitter">@nodejs_es</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.6.19/LICENSE">license</a>.</p>
    </div>
</body>
</html>

