<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Buffer Node.js v0.6.19 Manual &amp; Documentación</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/buffer-es.html">
</head>
<body class="alt apidoc" id="api-section-buffer-es">
    <div id="bar"><span>es</span><a title="Documentación en inglés" class="mark mark-es" href="en/buffer.html">en</a></div>
    <div id="intro" class="interior">
        <a href="http://www.nodejs.es/" title="Volder el site nodejs.es">
            <img id="logo" src="images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
      <div id="column2" class="interior">
        <div class="official-nodejs-es menu-block">
          <h2>Nodejs.es</h2>
            <ul>
                <li><a href="http://www.nodejs.es/" class="home">Home</a></li>
                <li><a href="http://api.nodejs.es" class="docs current">Docs</a></li>
                <li><a href="http://trabajos.nodejs.es/" class="jobs">Trabajos</a></li>
                <li><a href="https://github.com/nodejs-es/node/" class="download">GitHub</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs_es">@nodejs_es</a></p>
        </div>

        <div class="official-site menu-block">
          <h2>Sitio Oficial</h2>
            <ul>
                <li><a href="http://www.nodejs.org/" class="home">Home</a></li>
                <li><a href="http://www.nodejs.org/#download" class="download">Descargar</a></li>
                <li><a href="http://www.nodejs.org/about/" class="about">Acerca</a></li>
                <li><a href="http://search.npmjs.org/" class="npm">Registo npm</a></li>
                <li><a href="http://nodejs.org/api/" class="docs">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="http://www.nodejs.org/community/" class="community">Comunidad</a></li>
                <li><a href="http://www.nodejs.org/logos/" class="logos">Logos</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Trabajos</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>
      </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.6.19 Manual &amp; Documentación</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Índice</a> |
                <a href="all.html">Ver todo en una misma página</a> |
                <a href="buffer-es.json">Ver como JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Tabla de Contenidos</h2>
            <ul>
<li><a href="#buffer_es_buffer">Buffer</a><ul>
<li><a href="#buffer_es_class_buffer">Class: Buffer</a><ul>
<li><a href="#buffer_es_new_buffer_size">new Buffer(size)</a></li>
<li><a href="#buffer_es_new_buffer_array">new Buffer(array)</a></li>
<li><a href="#buffer_es_new_buffer_str_encoding">new Buffer(str, [encoding])</a></li>
<li><a href="#buffer_es_buf_write_string_offset_length_encoding">buf.write(string, [offset], [length], [encoding])</a></li>
<li><a href="#buffer_es_buf_tostring_encoding_start_end">buf.toString([encoding], [start], [end])</a></li>
<li><a href="#buffer_es_buf_index">buf[index]</a></li>
<li><a href="#buffer_es_class_method_buffer_isbuffer_obj">Class Method: Buffer.isBuffer(obj)</a></li>
<li><a href="#buffer_es_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string, [encoding])</a></li>
<li><a href="#buffer_es_buf_length">buf.length</a></li>
<li><a href="#buffer_es_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</a></li>
<li><a href="#buffer_es_buf_slice_start_end">buf.slice([start], [end])</a></li>
<li><a href="#buffer_es_buf_readuint8_offset_noassert">buf.readUInt8(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readint8_offset_noassert">buf.readInt8(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readint16le_offset_noassert">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readint16be_offset_noassert">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readint32le_offset_noassert">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readint32be_offset_noassert">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readfloatle_offset_noassert">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="#buffer_es_buf_fill_value_offset_end">buf.fill(value, [offset], [end])</a></li>
</ul>
</li>
<li><a href="#buffer_es_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="#buffer_es_class_slowbuffer">Class: SlowBuffer</a></li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>Buffer<span><a class="mark" href="#buffer_es_buffer" id="buffer_es_buffer">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>El puro Javascript es amigable con Unicode, pero no se lleva tan bien con 
los datos binarios. Cuando tratamos con streams TCP o ficheros del sistema,
es necesario manejar streams de octets. Node tiene algunas estrategias para
manipular, crear, y consumir streams de octets.

</p>
<p>Los datos en Raw son almacenados en instancias de la clase <code>Buffer</code>. Un 
<code>Buffer</code> es similar a un array de integers pero correspondiendo a una localización
en raw de la memeria fuera del heap de V8. Un <code>Buffer</code> no puede ser redimencionado.

</p>
<p>La clase <code>Buffer</code> es global, dado que es muy raro hacer un
<code>require(&apos;buffer&apos;)</code>.

</p>
<p>Convertir entre Buffers y objectos String de Javascript requiere de un método de 
codificación explícito. Aquí están las diferentes cadenas de codificación.

</p>
<ul>
<li><p><code>&apos;ascii&apos;</code> - solo para datos de 7 bit ASCII. Este método de codificación es muy rápido
y dejará el bit alto si está configurado.
Note that this encoding converts a null character (<code>&apos;\0&apos;</code> or <code>&apos;\u0000&apos;</code>) into
<code>0x20</code> (character code of a space). If you want to convert a null character
into <code>0x00</code>, you should use <code>&apos;utf8&apos;</code>.</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - Multiples bytes de caracteres con codificación Unicode. Muchas páginas webs y otros formatos de documentos usan UTF-8.</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> - 2-bytes, de caracteres con codificación <code>little endian</code> Unicode. 
Sólo pueden codificar BMP(Basic Multilingual Plane, U+0000 - U+FFFF).</p>
</li>
<li><p><code>&apos;base64&apos;</code> - String codificado a Base64.</p>
</li>
<li><p><code>&apos;binary&apos;</code> - Una forma de codificar datos binarios en Raw dentro de strings pero solo usando
los primeros 8 bits de cada caracter. Este método de codificación es obsoleto y
debe ser evitado en favor del objeto <code>Buffer</code> donde sea posible. Esta codificación
será eliminada en futuras versiones de Node.</p>
</li>
<li><p><code>&apos;hex&apos;</code> - Encode each byte as two hexidecimal characters.</p>
</li>
</ul>
<h2>Class: Buffer<span><a class="mark" href="#buffer_es_class_buffer" id="buffer_es_class_buffer">#</a></span></h2>
<p>The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.

</p>
<h3>new Buffer(size)<span><a class="mark" href="#buffer_es_new_buffer_size" id="buffer_es_new_buffer_size">#</a></span></h3>
<div class="signature"><ul>
<li><code>size</code> Number</li>
</div></ul>
<p>Asigna un nuevo buffer de <code>size</code> octets.

</p>
<h3>new Buffer(array)<span><a class="mark" href="#buffer_es_new_buffer_array" id="buffer_es_new_buffer_array">#</a></span></h3>
<div class="signature"><ul>
<li><code>array</code> Array</li>
</div></ul>
<p>Asigna un nuevo buffer usando un <code>array</code> de octets.

</p>
<h3>new Buffer(str, [encoding])<span><a class="mark" href="#buffer_es_new_buffer_str_encoding" id="buffer_es_new_buffer_str_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>str</code> String - string to encode.</li>
<li><code>encoding</code> String - encoding to use, Optional.</li>
</div></ul>
<p>Allocates a new buffer containing the given <code>str</code>.
<code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.

</p>
<h3>buf.write(string, [offset], [length], [encoding])<span><a class="mark" href="#buffer_es_buf_write_string_offset_length_encoding" id="buffer_es_buf_write_string_offset_length_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>string</code> String - data to be written to buffer</li>
<li><code>offset</code> Number, Optional, Default: 0</li>
<li><code>length</code> Number, Optional</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
</div></ul>
<p>Escribe <code>string</code> en el Buffer en <code>offset</code> usando el método dado.
<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>. <code>length</code> is
the number of bytes to write. Devuelve el número de octets escritos. Si <code>Buffer</code> 
no contiene suficiente espacio para encajar en el string completo, escribirá una
cantidad parcial de la cadena. <code>length</code> defaults to <code>buffer.length - offset</code>.
The method will not write partial characters.

</p>
<pre><code>buf = new Buffer(256);
len = buf.write(&apos;\u00bd + \u00bc = \u00be&apos;, 0);
console.log(len + &quot; bytes: &quot; + buf.toString(&apos;utf8&apos;, 0, len));</code></pre>
<p>The number of characters written (which may be different than the number of
bytes written) is set in <code>Buffer._charsWritten</code> and will be overwritten the
next time <code>buf.write()</code> is called.


</p>
<h3>buf.toString([encoding], [start], [end])<span><a class="mark" href="#buffer_es_buf_tostring_encoding_start_end" id="buffer_es_buf_tostring_encoding_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional</li>
</div></ul>
<p>Decodifica y devuelve un string con los datos de un buffer codificado con <code>encoding</code>
(por omisión en <code>&apos;utf8&apos;</code>) comenzando en <code>start</code> (por omisión <code>0</code>) y terminando en
<code>end</code> (por omisión <code>buffer.length</code>).

</p>
<p>Observe el ejemplo de <code>buffer.write()</code>, encima.


</p>
<h3>buf[index]<span><a class="mark" href="#buffer_es_buf_index" id="buffer_es_buf_index">#</a></span></h3>
<!--type=property-->
<!--name=[index]-->

<p>Obtiene y configura el octet en <code>index</code>. Los valores se refieren a bytes individuales,
por lo que el rango legal esta entre <code>0x00</code> and <code>0xFF</code> en hexadecimal o <code>0</code> y <code>255</code>.

</p>
<p>Ejemplo: Copiando un cadena ASCII dentro de un buffer, un byte cada vez:

</p>
<pre><code>str = &quot;node.js&quot;;
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>
<h3>Class Method: Buffer.isBuffer(obj)<span><a class="mark" href="#buffer_es_class_method_buffer_isbuffer_obj" id="buffer_es_class_method_buffer_isbuffer_obj">#</a></span></h3>
<div class="signature"><ul>
<li><code>obj</code> Object</li>
<li>Return: Boolean</li>
</div></ul>
<p>Comprueba si <code>obj</code> es un <code>Buffer</code>.

</p>
<h3>Class Method: Buffer.byteLength(string, [encoding])<span><a class="mark" href="#buffer_es_class_method_buffer_bytelength_string_encoding" id="buffer_es_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>string</code> String</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li>Return: Number</li>
</div></ul>
<p>Da la longitud de una cadena en bytes. <code>encoding</code> por omisión en <code>&apos;utf8&apos;</code>.
Esto no es lo mismo como <code>String.prototype.length</code> puesto que devuelve el
número de <em>caracteres</em> en el string.

</p>
<p>Ejemplo:

</p>
<pre><code>str = &apos;\u00bd + \u00bc = \u00be&apos;;

console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +
  Buffer.byteLength(str, &apos;utf8&apos;) + &quot; bytes&quot;);

// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
<h3>buf.length<span><a class="mark" href="#buffer_es_buf_length" id="buffer_es_buf_length">#</a></span></h3>
<div class="signature"><ul>
<li>Number</li>
</div></ul>
<p>El tamaño del buffer en bytes. Vea que esto no es necesariamente al tamaño
del contenido. <code>length</code> se refiere a la cantidad de memoria asignada para el
objeto buffer. No cambia cuando el contenido del buffer cambia.

</p>
<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write(&quot;some string&quot;, &quot;ascii&quot;, 0);
console.log(buf.length);

// 1234
// 1234</code></pre>
<h3>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])<span><a class="mark" href="#buffer_es_buf_copy_targetbuffer_targetstart_sourcestart_sourceend" id="buffer_es_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">#</a></span></h3>
<div class="signature"><ul>
<li><code>targetBuffer</code> Buffer object - Buffer to copy into</li>
<li><code>targetStart</code> Number, Optional, Default: 0</li>
<li><code>sourceStart</code> Number, Optional, Default: 0</li>
<li><code>sourceEnd</code> Number, Optional, Default: 0</li>
</div></ul>
<p>Does copy between buffers. The source and target regions can be overlapped.
<code>targetStart</code> and <code>sourceStart</code> default to <code>0</code>.
<code>sourceEnd</code> defaults to <code>buffer.length</code>.

</p>
<p>Ejemplo: construye dos Buffers, entonces copia <code>buf1</code> desde el byte 16 hasta el byte 19
dentro de <code>buf2</code>, comenzando en el octavo byte de <code>buf2</code>.

</p>
<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString(&apos;ascii&apos;, 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
<h3>buf.slice([start], [end])<span><a class="mark" href="#buffer_es_buf_slice_start_end" id="buffer_es_buf_slice_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional, Default: 0</li>
</div></ul>
<p>Devuelve un nuevo buffer el cual hace referencia a la misma memoria que el antíguo,
pero desplazado y cortado por los indices <code>start</code> (por omisión <code>0</code>) and 
<code>end</code> (por omisión <code>buffer.length</code>).


</p>
<p><strong>¡Al modificar el nuevo buffer, modificarás la memoria en el buffer original!</strong>

</p>
<p>Ejemplo: contruye un Buffer con el alfabeto ASCII, toma un fragmento, y 
entonces modifica un byte desde el Buffer original.

</p>
<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));

// abc
// !bc</code></pre>
<h3>buf.readUInt8(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readuint8_offset_noassert" id="buffer_es_buf_readuint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// 0x3
// 0x4
// 0x23
// 0x42</code></pre>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readuint16le_offset_noassert" id="buffer_es_buf_readuint16le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readuint16be_offset_noassert" id="buffer_es_buf_readuint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readuint32le_offset_noassert" id="buffer_es_buf_readuint32le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readuint32be_offset_noassert" id="buffer_es_buf_readuint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403</code></pre>
<h3>buf.readInt8(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readint8_offset_noassert" id="buffer_es_buf_readint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads a signed 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readInt16LE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readint16le_offset_noassert" id="buffer_es_buf_readint16le_offset_noassert">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readint16be_offset_noassert" id="buffer_es_buf_readint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readInt32LE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readint32le_offset_noassert" id="buffer_es_buf_readint32le_offset_noassert">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readint32be_offset_noassert" id="buffer_es_buf_readint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readFloatLE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readfloatle_offset_noassert" id="buffer_es_buf_readfloatle_offset_noassert">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readfloatbe_offset_noassert" id="buffer_es_buf_readfloatbe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// 0x01</code></pre>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readdoublele_offset_noassert" id="buffer_es_buf_readdoublele_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_readdoublebe_offset_noassert" id="buffer_es_buf_readdoublebe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// 0.3333333333333333</code></pre>
<h3>buf.writeUInt8(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeuint8_value_offset_noassert" id="buffer_es_buf_writeuint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);

// &lt;Buffer 03 04 23 42&gt;</code></pre>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeuint16le_value_offset_noassert" id="buffer_es_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeuint16be_value_offset_noassert" id="buffer_es_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);

// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeuint32le_value_offset_noassert" id="buffer_es_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeuint32be_value_offset_noassert" id="buffer_es_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);

// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>
<h3>buf.writeInt8(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeint8_value_offset_noassert" id="buffer_es_buf_writeint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&apos;s complement
signed integer into <code>buffer</code>.

</p>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeint16le_value_offset_noassert" id="buffer_es_buf_writeint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeint16be_value_offset_noassert" id="buffer_es_buf_writeint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeint32le_value_offset_noassert" id="buffer_es_buf_writeint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writeint32be_value_offset_noassert" id="buffer_es_buf_writeint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writefloatle_value_offset_noassert" id="buffer_es_buf_writefloatle_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writefloatbe_value_offset_noassert" id="buffer_es_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 32 bit float.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writedoublele_value_offset_noassert" id="buffer_es_buf_writedoublele_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a class="mark" href="#buffer_es_buf_writedoublebe_value_offset_noassert" id="buffer_es_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);

// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
<h3>buf.fill(value, [offset], [end])<span><a class="mark" href="#buffer_es_buf_fill_value_offset_end" id="buffer_es_buf_fill_value_offset_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code></li>
<li><code>offset</code> Number, Optional</li>
<li><code>end</code> Number, Optional</li>
</div></ul>
<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire
buffer.

</p>
<pre><code>var b = new Buffer(50);
b.fill(&quot;h&quot;);</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#buffer_es_buffer_inspect_max_bytes" id="buffer_es_buffer_inspect_max_bytes">#</a></span></h2>
<div class="signature"><ul>
<li>Number, Default: 50</li>
</div></ul>
<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overridden by user modules.

</p>
<p>Note that this is a property on the buffer module returned by
<code>require(&apos;buffer&apos;)</code>, not on the Buffer global, or a buffer instance.

</p>
<h2>Class: SlowBuffer<span><a class="mark" href="#buffer_es_class_slowbuffer" id="buffer_es_class_slowbuffer">#</a></span></h2>
<p>This class is primarily for internal use.  JavaScript programs should
use Buffer instead of using SlowBuffer.

</p>
<p>In order to avoid the overhead of allocating many C++ Buffer objects for
small blocks of memory in the lifetime of a server, Node allocates memory
in 8Kb (8192 byte) chunks.  If a buffer is smaller than this size, then it
will be backed by a parent SlowBuffer object.  If it is larger than this,
then Node will allocate a SlowBuffer slab for it directly.</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <ul class="clearfix">
            <li><a href="http://www.nodejs.org/">Node.js</a></li>
            <li><a href="http://www.nodejs.es/">Node.js en español</a></li>
            <li><a href="http://twitter.com/nodejs_es" class="twitter">@nodejs_es</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.6.19/LICENSE">license</a>.</p>
    </div>
</body>
</html>

