<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>About this Documentation Node.js v0.6.10 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/all.html">
</head>
<body class="alt apidoc" id="api-section-all">
    <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
            <img id="logo" src="images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <li><a href="/" class="home">Home</a></li>
                <li><a href="/#download" class="download">Download</a></li>
                <li><a href="/about/" class="about">About</a></li>
                <li><a href="http://search.npmjs.org/" class="npm">npm Registry</a></li>
                <li><a href="http://nodejs.org/docs/latest/api/index.html" class="docs current">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="/community/" class="community">Community</a></li>
                <li><a href="/logos/" class="logos">Logos</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Jobs</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.6.10 Manual &amp; Documentation</h1>
            <div id="gtoc">
              <p><a href="index.html" name="toc">Index</a> | <a href="all.html">View on single page</a></p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
<li><a href="#all_about_this_documentation">About this Documentation</a><ul>
<li><a href="#all_stability_index">Stability Index</a></li>
<li><a href="#all_json_output">JSON Output</a></li>
</ul>
</li>
<li><a href="#all_sinopsis">Sinopsis</a></li>
<li><a href="#all_objetos_globales">Objetos Globales</a><ul>
<li><a href="#all_global">global</a><ul>
<li><a href="#all_process">process</a></li>
<li><a href="#all_console">console</a></li>
</ul>
</li>
<li><a href="#all_class_buffer">Class: Buffer</a></li>
<li><a href="#all_require">require()</a><ul>
<li><a href="#all_require_resolve">require.resolve()</a></li>
<li><a href="#all_require_cache">require.cache</a></li>
<li><a href="#all_filename">__filename</a></li>
</ul>
</li>
<li><a href="#all_dirname">__dirname</a></li>
<li><a href="#all_module">module</a></li>
<li><a href="#all_exports">exports</a></li>
<li><a href="#all_settimeout_cb_ms">setTimeout(cb, ms)</a></li>
<li><a href="#all_cleartimeout_t">clearTimeout(t)</a></li>
<li><a href="#all_setinterval_cb_ms">setInterval(cb, ms)</a></li>
<li><a href="#all_clearinterval_t">clearInterval(t)</a></li>
</ul>
</li>
<li><a href="#all_console_1">console</a><ul>
<li><a href="#all_console_log">console.log()</a></li>
<li><a href="#all_console_info">console.info()</a></li>
<li><a href="#all_console_warn">console.warn()</a></li>
<li><a href="#all_console_error">console.error()</a></li>
<li><a href="#all_console_dir_obj">console.dir(obj)</a></li>
<li><a href="#all_console_time_label">console.time(label)</a></li>
<li><a href="#all_console_timeend_label">console.timeEnd(label)</a></li>
<li><a href="#all_console_trace">console.trace()</a></li>
<li><a href="#all_console_assert">console.assert()</a></li>
</ul>
</li>
<li><a href="#all_timer">Timer</a><ul>
<li><a href="#all_settimeout_callback_delay_arg">setTimeout(callback, delay, [arg], [...])</a></li>
<li><a href="#all_cleartimeout_timeoutid">clearTimeout(timeoutId)</a></li>
<li><a href="#all_setinterval_callback_delay_arg">setInterval(callback, delay, [arg], [...])</a></li>
<li><a href="#all_clearinterval_intervalid">clearInterval(intervalId)</a></li>
</ul>
</li>
<li><a href="#all_m_dulos">Módulos</a><ul>
<li><a href="#all_m_dulos_b_sicos">Módulos básicos</a></li>
<li><a href="#all_m_dulo_file">Módulo File</a></li>
<li><a href="#all_cargando_desde_la_carpeta_node_modules">Cargando desde la carpeta <code>node_modules</code></a><ul>
<li><a href="#all_optimizaci_n_de_proceso_de_b_squeda_en_node_modules">Optimización de proceso de búsqueda en <code>node_modules</code></a></li>
</ul>
</li>
<li><a href="#all_carpetas_como_m_dulos">Carpetas como módulos</a></li>
<li><a href="#all_almacenamiento_en_la_cach">Almacenamiento en la caché</a></li>
<li><a href="#all_todos_juntos">Todos juntos...</a></li>
<li><a href="#all_cargar_desde_las_carpetas_de_require_paths">Cargar desde las carpetas de <code>require.paths</code></a><ul>
<li><a href="#all_nota_por_favor_evite_la_modificaci_n_de_require_paths"><strong>Nota:</strong> Por favor evite la modificación de <code>require.paths</code></a><ul>
<li><a href="#all_establecer_require_paths_a_alg_n_otro_valor_para_nada">Establecer <code>require.paths</code> a algún otro valor para nada.</a></li>
<li><a href="#all_poner_rutas_relativas_en_require_paths_es_raro">Poner rutas relativas en <code>require.paths</code> es... raro.</a></li>
<li><a href="#all_cero_aislamiento">Cero aislamiento</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_addenda_consejos_para_administrar_paquetes">Addenda: Consejos para administrar paquetes</a></li>
</ul>
</li>
<li><a href="#all_addons">Addons</a></li>
<li><a href="#all_process_1">process</a><ul>
<li><a href="#all_evento_exit">Evento: &apos;exit&apos;</a></li>
<li><a href="#all_evento_uncaughtexception">Evento: &apos;uncaughtException&apos;</a></li>
<li><a href="#all_eventos_de_se_al">Eventos de señal</a></li>
<li><a href="#all_process_stdout">process.stdout</a><ul>
<li><a href="#all_process_stderr">process.stderr</a></li>
<li><a href="#all_process_stdin">process.stdin</a></li>
<li><a href="#all_process_argv">process.argv</a></li>
<li><a href="#all_process_execpath">process.execPath</a></li>
</ul>
</li>
<li><a href="#all_process_chdir_directory">process.chdir(directory)</a></li>
<li><a href="#all_process_cwd">process.cwd()</a><ul>
<li><a href="#all_process_env">process.env</a></li>
<li><a href="#all_process_exit_code_0">process.exit(code=0)</a></li>
</ul>
</li>
<li><a href="#all_process_getgid">process.getgid()</a><ul>
<li><a href="#all_process_setgid_id">process.setgid(id)</a></li>
</ul>
</li>
<li><a href="#all_process_getuid">process.getuid()</a><ul>
<li><a href="#all_process_setuid_id">process.setuid(id)</a></li>
</ul>
</li>
<li><a href="#all_process_version">process.version</a></li>
<li><a href="#all_process_installprefix">process.installPrefix</a></li>
<li><a href="#all_process_kill_pid_signal_sigterm">process.kill(pid, signal=&apos;SIGTERM&apos;)</a></li>
<li><a href="#all_process_pid">process.pid</a><ul>
<li><a href="#all_process_title">process.title</a></li>
</ul>
</li>
<li><a href="#all_process_platform">process.platform</a><ul>
<li><a href="#all_process_memoryusage">process.memoryUsage()</a></li>
<li><a href="#all_process_nexttick_callback">process.nextTick(callback)</a></li>
<li><a href="#all_process_umask_mask">process.umask([mask])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_util">util</a><ul>
<li><a href="#all_util_format">util.format()</a></li>
<li><a href="#all_util_debug_string">util.debug(string)</a><ul>
<li><a href="#all_util_log_string">util.log(string)</a></li>
<li><a href="#all_util_inspect_object_showhidden_false_depth_2">util.inspect(object, showHidden=false, depth=2)</a></li>
</ul>
</li>
<li><a href="#all_util_isarray_object">util.isArray(object)</a></li>
<li><a href="#all_util_isregexp_object">util.isRegExp(object)</a></li>
<li><a href="#all_util_isdate_object">util.isDate(object)</a></li>
<li><a href="#all_util_iserror_object">util.isError(object)</a></li>
<li><a href="#all_util_pump_readablestream_writablestream_callback">util.pump(readableStream, writableStream, [callback])</a><ul>
<li><a href="#all_util_inherits_constructor_superconstructor">util.inherits(constructor, superConstructor)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_eventos">Eventos</a><ul>
<li><a href="#all_events_eventemitter">events.EventEmitter</a></li>
<li><a href="#all_emitter_addlistener_event_listener">emitter.addListener(event, listener)</a></li>
<li><a href="#all_emitter_on_event_listener">emitter.on(event, listener)</a></li>
<li><a href="#all_emitter_once_event_listener">emitter.once(event, listener)</a></li>
<li><a href="#all_emitter_removelistener_event_listener">emitter.removeListener(event, listener)</a></li>
<li><a href="#all_emitter_removealllisteners_event">emitter.removeAllListeners(event)</a></li>
<li><a href="#all_emitter_setmaxlisteners_n">emitter.setMaxListeners(n)</a></li>
<li><a href="#all_emitter_listeners_event">emitter.listeners(event)</a></li>
<li><a href="#all_emitter_emit_event_arg1_arg2">emitter.emit(event, [arg1], [arg2], [...])</a></li>
<li><a href="#all_event_newlistener">Event: &apos;newListener&apos;</a></li>
</ul>
</li>
<li><a href="#all_buffer">Buffer</a><ul>
<li><a href="#all_class_buffer_1">Class: Buffer</a><ul>
<li><a href="#all_new_buffer_size">new Buffer(size)</a></li>
<li><a href="#all_new_buffer_array">new Buffer(array)</a></li>
<li><a href="#all_new_buffer_str_encoding">new Buffer(str, [encoding])</a></li>
<li><a href="#all_buf_write_string_offset_length_encoding">buf.write(string, [offset], [length], [encoding])</a></li>
<li><a href="#all_buf_tostring_encoding_start_end">buf.toString([encoding], [start], [end])</a></li>
<li><a href="#all_buf_index">buf[index]</a></li>
<li><a href="#all_class_method_buffer_isbuffer_obj">Class Method: Buffer.isBuffer(obj)</a></li>
<li><a href="#all_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string, [encoding])</a></li>
<li><a href="#all_buf_length">buf.length</a></li>
<li><a href="#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</a></li>
<li><a href="#all_buf_slice_start_end">buf.slice([start], [end])</a></li>
<li><a href="#all_buf_readuint8_offset_noassert">buf.readUInt8(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint8_offset_noassert">buf.readInt8(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint16le_offset_noassert">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint16be_offset_noassert">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint32le_offset_noassert">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint32be_offset_noassert">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readfloatle_offset_noassert">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_fill_value_offset_end">buf.fill(value, [offset], [end])</a></li>
</ul>
</li>
<li><a href="#all_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="#all_class_slowbuffer">Class: SlowBuffer</a></li>
</ul>
</li>
<li><a href="#all_streams">Streams</a><ul>
<li><a href="#all_readable_stream">Readable Stream</a><ul>
<li><a href="#all_event_data">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end">Event: &apos;end&apos;</a></li>
<li><a href="#all_event_error">Event: &apos;error&apos;</a></li>
<li><a href="#all_event_close">Event: &apos;close&apos;</a></li>
<li><a href="#all_event_fd">Event: &apos;fd&apos;</a></li>
<li><a href="#all_stream_readable">stream.readable</a></li>
<li><a href="#all_stream_setencoding_encoding">stream.setEncoding(encoding)</a></li>
<li><a href="#all_stream_pause">stream.pause()</a></li>
<li><a href="#all_stream_resume">stream.resume()</a></li>
<li><a href="#all_stream_destroy">stream.destroy()</a></li>
<li><a href="#all_stream_destroysoon">stream.destroySoon()</a></li>
<li><a href="#all_stream_pipe_destination_options">stream.pipe(destination, [options])</a></li>
</ul>
</li>
<li><a href="#all_writable_stream">Writable Stream</a><ul>
<li><a href="#all_event_drain">Event: &apos;drain&apos;</a></li>
<li><a href="#all_event_error_1">Event: &apos;error&apos;</a></li>
<li><a href="#all_event_close_1">Event: &apos;close&apos;</a></li>
<li><a href="#all_event_pipe">Event: &apos;pipe&apos;</a></li>
<li><a href="#all_stream_writable">stream.writable</a></li>
<li><a href="#all_stream_write_string_encoding_utf8_fd">stream.write(string, encoding=&apos;utf8&apos;, [fd])</a></li>
<li><a href="#all_stream_write_buffer">stream.write(buffer)</a></li>
<li><a href="#all_stream_end">stream.end()</a></li>
<li><a href="#all_stream_end_string_encoding">stream.end(string, encoding)</a></li>
<li><a href="#all_stream_end_buffer">stream.end(buffer)</a></li>
<li><a href="#all_stream_destroy_1">stream.destroy()</a></li>
<li><a href="#all_stream_destroysoon_1">stream.destroySoon()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_crypto">Crypto</a><ul>
<li><a href="#all_crypto_createcredentials_details">crypto.createCredentials(details)</a><ul>
<li><a href="#all_crypto_createhash_algorithm">crypto.createHash(algorithm)</a></li>
</ul>
</li>
<li><a href="#all_class_hash">Class: Hash</a><ul>
<li><a href="#all_hash_update_data">hash.update(data)</a></li>
<li><a href="#all_hash_digest_encoding">hash.digest([encoding])</a></li>
<li><a href="#all_crypto_createhmac_algorithm_key">crypto.createHmac(algorithm, key)</a></li>
</ul>
</li>
<li><a href="#all_class_hmac">Class: Hmac</a><ul>
<li><a href="#all_hmac_update_data">hmac.update(data)</a></li>
<li><a href="#all_hmac_digest_encoding_binary">hmac.digest(encoding=&apos;binary&apos;)</a></li>
<li><a href="#all_crypto_createcipher_algorithm_key">crypto.createCipher(algorithm, key)</a></li>
</ul>
</li>
<li><a href="#all_crypto_createcipheriv_algorithm_key_iv">crypto.createCipheriv(algorithm, key, iv)</a></li>
<li><a href="#all_class_cipher">Class: Cipher</a><ul>
<li><a href="#all_cipher_update_data_input_encoding_output_encoding">cipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_cipher_final_output_encoding">cipher.final([output_encoding])</a></li>
<li><a href="#all_cipher_setautopadding_auto_padding_true">cipher.setAutoPadding(auto_padding=true)</a></li>
<li><a href="#all_crypto_createdecipher_algorithm_key">crypto.createDecipher(algorithm, key)</a></li>
<li><a href="#all_decipher_update_data_input_encoding_binary_output_encoding_binary">decipher.update(data, input_encoding=&apos;binary&apos;, output_encoding=&apos;binary&apos;)</a></li>
</ul>
</li>
<li><a href="#all_class_decipher">Class: Decipher</a><ul>
<li><a href="#all_decipher_update_data_input_encoding_output_encoding">decipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_decipher_final_output_encoding">decipher.final([output_encoding])</a></li>
<li><a href="#all_decipher_setautopadding_auto_padding_true">decipher.setAutoPadding(auto_padding=true)</a></li>
</ul>
</li>
<li><a href="#all_crypto_createsign_algorithm">crypto.createSign(algorithm)</a></li>
<li><a href="#all_class_signer">Class: Signer</a><ul>
<li><a href="#all_signer_update_data">signer.update(data)</a></li>
<li><a href="#all_signer_sign_private_key_output_format_binary">signer.sign(private_key, output_format=&apos;binary&apos;)</a></li>
<li><a href="#all_crypto_createverify_algorithm">crypto.createVerify(algorithm)</a></li>
</ul>
</li>
<li><a href="#all_class_verify">Class: Verify</a><ul>
<li><a href="#all_verifier_update_data">verifier.update(data)</a></li>
<li><a href="#all_verifier_verify_cert_signature_signature_format_binary">verifier.verify(cert, signature, signature_format=&apos;binary&apos;)</a></li>
</ul>
</li>
<li><a href="#all_crypto_creatediffiehellman_prime_length">crypto.createDiffieHellman(prime_length)</a></li>
<li><a href="#all_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman(prime, [encoding])</a></li>
<li><a href="#all_class_diffiehellman">Class: DiffieHellman</a><ul>
<li><a href="#all_diffiehellman_generatekeys_encoding">diffieHellman.generateKeys([encoding])</a></li>
<li><a href="#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_diffiehellman_getprime_encoding">diffieHellman.getPrime([encoding])</a></li>
<li><a href="#all_diffiehellman_getgenerator_encoding">diffieHellman.getGenerator([encoding])</a></li>
<li><a href="#all_diffiehellman_getpublickey_encoding">diffieHellman.getPublicKey([encoding])</a></li>
<li><a href="#all_diffiehellman_getprivatekey_encoding">diffieHellman.getPrivateKey([encoding])</a></li>
<li><a href="#all_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey(public_key, [encoding])</a></li>
<li><a href="#all_diffiehellman_setprivatekey_public_key_encoding">diffieHellman.setPrivateKey(public_key, [encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_getdiffiehellman_group_name">crypto.getDiffieHellman(group_name)</a></li>
<li><a href="#all_crypto_pbkdf2_password_salt_iterations_keylen_callback">crypto.pbkdf2(password, salt, iterations, keylen, callback)</a></li>
<li><a href="#all_crypto_randombytes_size_callback">crypto.randomBytes(size, [callback])</a></li>
</ul>
</li>
<li><a href="#all_tls_ssl">TLS (SSL)</a><ul>
<li><a href="#all_s_tls_connect_port_host_options_callback">s = tls.connect(port, [host], [options], callback)</a></li>
<li><a href="#all_starttls">STARTTLS</a></li>
<li><a href="#all_tls_server">tls.Server</a><ul>
<li><a href="#all_tls_createserver_options_secureconnectionlistener">tls.createServer(options, secureConnectionListener)</a></li>
<li><a href="#all_event_secureconnection">Event: &apos;secureConnection&apos;</a></li>
<li><a href="#all_server_listen_port_host_callback">server.listen(port, [host], [callback])</a></li>
<li><a href="#all_server_close">server.close()</a></li>
<li><a href="#all_server_maxconnections">server.maxConnections</a></li>
<li><a href="#all_server_connections">server.connections</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_file_system">File System</a><ul>
<li><a href="#all_fs_rename_path1_path2_callback">fs.rename(path1, path2, [callback])</a></li>
<li><a href="#all_fs_renamesync_path1_path2">fs.renameSync(path1, path2)</a></li>
<li><a href="#all_fs_truncate_fd_len_callback">fs.truncate(fd, len, [callback])</a></li>
<li><a href="#all_fs_truncatesync_fd_len">fs.truncateSync(fd, len)</a></li>
<li><a href="#all_fs_chmod_path_mode_callback">fs.chmod(path, mode, [callback])</a></li>
<li><a href="#all_fs_chmodsync_path_mode">fs.chmodSync(path, mode)</a></li>
<li><a href="#all_fs_stat_path_callback">fs.stat(path, [callback])</a></li>
<li><a href="#all_fs_lstat_path_callback">fs.lstat(path, [callback])</a></li>
<li><a href="#all_fs_fstat_fd_callback">fs.fstat(fd, [callback])</a></li>
<li><a href="#all_fs_statsync_path">fs.statSync(path)</a></li>
<li><a href="#all_fs_lstatsync_path">fs.lstatSync(path)</a></li>
<li><a href="#all_fs_fstatsync_fd">fs.fstatSync(fd)</a></li>
<li><a href="#all_fs_link_srcpath_dstpath_callback">fs.link(srcpath, dstpath, [callback])</a></li>
<li><a href="#all_fs_linksync_srcpath_dstpath">fs.linkSync(srcpath, dstpath)</a></li>
<li><a href="#all_fs_symlink_linkdata_path_callback">fs.symlink(linkdata, path, [callback])</a></li>
<li><a href="#all_fs_symlinksync_linkdata_path">fs.symlinkSync(linkdata, path)</a></li>
<li><a href="#all_fs_readlink_path_callback">fs.readlink(path, [callback])</a></li>
<li><a href="#all_fs_readlinksync_path">fs.readlinkSync(path)</a></li>
<li><a href="#all_fs_realpath_path_callback">fs.realpath(path, [callback])</a></li>
<li><a href="#all_fs_realpathsync_path">fs.realpathSync(path)</a></li>
<li><a href="#all_fs_unlink_path_callback">fs.unlink(path, [callback])</a></li>
<li><a href="#all_fs_unlinksync_path">fs.unlinkSync(path)</a></li>
<li><a href="#all_fs_rmdir_path_callback">fs.rmdir(path, [callback])</a></li>
<li><a href="#all_fs_rmdirsync_path">fs.rmdirSync(path)</a></li>
<li><a href="#all_fs_mkdir_path_mode_callback">fs.mkdir(path, mode, [callback])</a></li>
<li><a href="#all_fs_mkdirsync_path_mode">fs.mkdirSync(path, mode)</a></li>
<li><a href="#all_fs_readdir_path_callback">fs.readdir(path, [callback])</a></li>
<li><a href="#all_fs_readdirsync_path">fs.readdirSync(path)</a></li>
<li><a href="#all_fs_close_fd_callback">fs.close(fd, [callback])</a></li>
<li><a href="#all_fs_closesync_fd">fs.closeSync(fd)</a></li>
<li><a href="#all_fs_open_path_flags_mode_callback">fs.open(path, flags, [mode], [callback])</a></li>
<li><a href="#all_fs_opensync_path_flags_mode">fs.openSync(path, flags, [mode])</a></li>
<li><a href="#all_fs_write_fd_buffer_offset_length_position_callback">fs.write(fd, buffer, offset, length, position, [callback])</a></li>
<li><a href="#all_fs_writesync_fd_buffer_offset_length_position">fs.writeSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#all_fs_writesync_fd_str_position_encoding_utf8">fs.writeSync(fd, str, position, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_fs_read_fd_buffer_offset_length_position_callback">fs.read(fd, buffer, offset, length, position, [callback])</a></li>
<li><a href="#all_fs_readsync_fd_buffer_offset_length_position">fs.readSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#all_fs_readsync_fd_length_position_encoding">fs.readSync(fd, length, position, encoding)</a></li>
<li><a href="#all_fs_readfile_filename_encoding_callback">fs.readFile(filename, [encoding], [callback])</a></li>
<li><a href="#all_fs_readfilesync_filename_encoding">fs.readFileSync(filename, [encoding])</a></li>
<li><a href="#all_fs_writefile_filename_data_encoding_utf8_callback">fs.writeFile(filename, data, encoding=&apos;utf8&apos;, [callback])</a></li>
<li><a href="#all_fs_writefilesync_filename_data_encoding_utf8">fs.writeFileSync(filename, data, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_fs_watchfile_filename_options_listener">fs.watchFile(filename, [options], listener)</a></li>
<li><a href="#all_fs_unwatchfile_filename">fs.unwatchFile(filename)</a></li>
<li><a href="#all_fs_stats">fs.Stats</a></li>
<li><a href="#all_fs_readstream">fs.ReadStream</a></li>
<li><a href="#all_fs_createreadstream_path_options">fs.createReadStream(path, [options])</a></li>
<li><a href="#all_fs_writestream">fs.WriteStream</a></li>
<li><a href="#all_event_open">Event: &apos;open&apos;</a></li>
<li><a href="#all_fs_createwritestream_path_options">fs.createWriteStream(path, [options])</a></li>
</ul>
</li>
<li><a href="#all_path">Path</a><ul>
<li><a href="#all_path_normalize_p">path.normalize(p)</a></li>
<li><a href="#all_path_join_path1_path2">path.join([path1], [path2], [...])</a></li>
<li><a href="#all_path_resolve_from_to">path.resolve([from ...], to)</a></li>
<li><a href="#all_path_relative_from_to">path.relative(from, to)</a></li>
<li><a href="#all_path_dirname_p">path.dirname(p)</a></li>
<li><a href="#all_path_basename_p_ext">path.basename(p, [ext])</a></li>
<li><a href="#all_path_extname_p">path.extname(p)</a></li>
</ul>
</li>
<li><a href="#all_net">net</a><ul>
<li><a href="#all_net_createserver_options_connectionlistener">net.createServer([options], [connectionListener])</a></li>
<li><a href="#all_net_connect_options_connectionlistener">net.connect(options, [connectionListener])</a></li>
<li><a href="#all_net_createconnection_options_connectionlistener">net.createConnection(options, [connectionListener])</a></li>
<li><a href="#all_net_connect_port_host_connectlistener">net.connect(port, [host], [connectListener])</a></li>
<li><a href="#all_net_createconnection_port_host_connectlistener">net.createConnection(port, [host], [connectListener])</a></li>
<li><a href="#all_net_connect_path_connectlistener">net.connect(path, [connectListener])</a></li>
<li><a href="#all_net_createconnection_path_connectlistener">net.createConnection(path, [connectListener])</a></li>
<li><a href="#all_class_net_server">Class: net.Server</a><ul>
<li><a href="#all_server_listen_port_host_listeninglistener">server.listen(port, [host], [listeningListener])</a></li>
<li><a href="#all_server_listen_path_listeninglistener">server.listen(path, [listeningListener])</a></li>
<li><a href="#all_server_close_cb">server.close([cb])</a></li>
<li><a href="#all_server_address">server.address()</a></li>
<li><a href="#all_server_maxconnections_1">server.maxConnections</a></li>
<li><a href="#all_server_connections_1">server.connections</a></li>
<li><a href="#all_event_listening">Event: &apos;listening&apos;</a></li>
<li><a href="#all_event_connection">Event: &apos;connection&apos;</a></li>
<li><a href="#all_event_close_2">Event: &apos;close&apos;</a></li>
<li><a href="#all_event_error_2">Event: &apos;error&apos;</a></li>
</ul>
</li>
<li><a href="#all_class_net_socket">Class: net.Socket</a><ul>
<li><a href="#all_new_net_socket_options">new net.Socket([options])</a></li>
<li><a href="#all_socket_connect_port_host_connectlistener">socket.connect(port, [host], [connectListener])</a></li>
<li><a href="#all_socket_connect_path_connectlistener">socket.connect(path, [connectListener])</a></li>
<li><a href="#all_socket_buffersize">socket.bufferSize</a></li>
<li><a href="#all_socket_setencoding_encoding">socket.setEncoding([encoding])</a></li>
<li><a href="#all_socket_write_data_encoding_callback">socket.write(data, [encoding], [callback])</a></li>
<li><a href="#all_socket_end_data_encoding">socket.end([data], [encoding])</a></li>
<li><a href="#all_socket_destroy">socket.destroy()</a></li>
<li><a href="#all_socket_pause">socket.pause()</a></li>
<li><a href="#all_socket_resume">socket.resume()</a></li>
<li><a href="#all_socket_settimeout_timeout_callback">socket.setTimeout(timeout, [callback])</a></li>
<li><a href="#all_socket_setnodelay_nodelay">socket.setNoDelay([noDelay])</a></li>
<li><a href="#all_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive([enable], [initialDelay])</a></li>
<li><a href="#all_socket_address">socket.address()</a></li>
<li><a href="#all_socket_remoteaddress">socket.remoteAddress</a></li>
<li><a href="#all_socket_remoteport">socket.remotePort</a></li>
<li><a href="#all_socket_bytesread">socket.bytesRead</a></li>
<li><a href="#all_socket_byteswritten">socket.bytesWritten</a></li>
<li><a href="#all_event_connect">Event: &apos;connect&apos;</a></li>
<li><a href="#all_event_data_1">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_1">Event: &apos;end&apos;</a></li>
<li><a href="#all_event_timeout">Event: &apos;timeout&apos;</a></li>
<li><a href="#all_event_drain_1">Event: &apos;drain&apos;</a></li>
<li><a href="#all_event_error_3">Event: &apos;error&apos;</a></li>
<li><a href="#all_event_close_3">Event: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="#all_net_isip_input">net.isIP(input)</a></li>
<li><a href="#all_net_isipv4_input">net.isIPv4(input)</a></li>
<li><a href="#all_net_isipv6_input">net.isIPv6(input)</a></li>
</ul>
</li>
<li><a href="#all_udp_sockets_de_datagrama">UDP / Sockets de Datagrama</a><ul>
<li><a href="#all_evento_message">Evento: &apos;message&apos;</a><ul>
<li><a href="#all_evento_listening">Evento: &apos;listening&apos;</a></li>
</ul>
</li>
<li><a href="#all_evento_close">Evento: &apos;close&apos;</a><ul>
<li><a href="#all_dgram_createsocket_type_callback">dgram.createSocket(type, [callback])</a></li>
<li><a href="#all_dgram_send_buf_offset_length_path_callback">dgram.send(buf, offset, length, path, [callback])</a></li>
</ul>
</li>
<li><a href="#all_dgram_send_buf_offset_length_port_address_callback">dgram.send(buf, offset, length, port, address, [callback])</a></li>
<li><a href="#all_dgram_bind_path">dgram.bind(path)</a><ul>
<li><a href="#all_dgram_bind_port_address">dgram.bind(port, [address])</a></li>
</ul>
</li>
<li><a href="#all_dgram_close">dgram.close()</a><ul>
<li><a href="#all_dgram_address">dgram.address()</a></li>
<li><a href="#all_dgram_setbroadcast_flag">dgram.setBroadcast(flag)</a></li>
</ul>
</li>
<li><a href="#all_dgram_setttl_ttl">dgram.setTTL(ttl)</a><ul>
<li><a href="#all_dgram_setmulticastttl_ttl">dgram.setMulticastTTL(ttl)</a></li>
<li><a href="#all_dgram_setmulticastloopback_flag">dgram.setMulticastLoopback(flag)</a></li>
</ul>
</li>
<li><a href="#all_dgram_addmembership_multicastaddress_multicastinterface">dgram.addMembership(multicastAddress, [multicastInterface])</a></li>
<li><a href="#all_dgram_dropmembership_multicastaddress_multicastinterface">dgram.dropMembership(multicastAddress, [multicastInterface])</a></li>
</ul>
</li>
<li><a href="#all_dns">DNS</a><ul>
<li><a href="#all_dns_lookup_domain_family_callback">dns.lookup(domain, [family], callback)</a></li>
<li><a href="#all_dns_resolve_domain_rrtype_callback">dns.resolve(domain, [rrtype], callback)</a></li>
<li><a href="#all_dns_resolve4_domain_callback">dns.resolve4(domain, callback)</a></li>
<li><a href="#all_dns_resolve6_domain_callback">dns.resolve6(domain, callback)</a></li>
<li><a href="#all_dns_resolvemx_domain_callback">dns.resolveMx(domain, callback)</a></li>
<li><a href="#all_dns_resolvetxt_domain_callback">dns.resolveTxt(domain, callback)</a></li>
<li><a href="#all_dns_resolvesrv_domain_callback">dns.resolveSrv(domain, callback)</a></li>
<li><a href="#all_dns_reverse_ip_callback">dns.reverse(ip, callback)</a></li>
<li><a href="#all_dns_resolvens_domain_callback">dns.resolveNs(domain, callback)</a></li>
<li><a href="#all_dns_resolvecname_domain_callback">dns.resolveCname(domain, callback)</a></li>
</ul>
</li>
<li><a href="#all_http">HTTP</a><ul>
<li><a href="#all_http_server">http.Server</a><ul>
<li><a href="#all_evento_request">Evento: &apos;request&apos;</a></li>
<li><a href="#all_evento_connection">Evento: &apos;connection&apos;</a></li>
<li><a href="#all_evento_close_1">Evento: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="#all_evento_request_1">Evento: &apos;request&apos;</a><ul>
<li><a href="#all_evento_checkcontinue">Evento: &apos;checkContinue&apos;</a></li>
<li><a href="#all_evento_upgrade">Evento: &apos;upgrade&apos;</a></li>
<li><a href="#all_evento_clienterror">Evento: &apos;clientError&apos;</a></li>
<li><a href="#all_http_createserver_requestlistener">http.createServer(requestListener)</a></li>
<li><a href="#all_server_listen_port_hostname_callback">server.listen(port, [hostname], [callback])</a></li>
<li><a href="#all_server_listen_path_callback">server.listen(path, [callback])</a></li>
<li><a href="#all_server_close_1">server.close()</a></li>
</ul>
</li>
<li><a href="#all_http_serverrequest">http.ServerRequest</a><ul>
<li><a href="#all_event_data_2">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_2">Event: &apos;end&apos;</a></li>
<li><a href="#all_request_method">request.method</a></li>
<li><a href="#all_request_url">request.url</a></li>
<li><a href="#all_request_headers">request.headers</a></li>
<li><a href="#all_request_trailers">request.trailers</a></li>
<li><a href="#all_request_httpversion">request.httpVersion</a></li>
<li><a href="#all_request_setencoding_encoding_null">request.setEncoding(encoding=null)</a></li>
<li><a href="#all_request_pause">request.pause()</a></li>
<li><a href="#all_request_resume">request.resume()</a></li>
<li><a href="#all_request_connection">request.connection</a></li>
</ul>
</li>
<li><a href="#all_http_serverresponse">http.ServerResponse</a><ul>
<li><a href="#all_response_writecontinue">response.writeContinue()</a></li>
<li><a href="#all_response_writehead_statuscode_reasonphrase_headers">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li>
<li><a href="#all_response_statuscode">response.statusCode</a></li>
<li><a href="#all_response_setheader_name_value">response.setHeader(name, value)</a></li>
<li><a href="#all_response_getheader_name">response.getHeader(name)</a></li>
<li><a href="#all_response_removeheader_name">response.removeHeader(name)</a></li>
<li><a href="#all_response_write_chunk_encoding_utf8">response.write(chunk, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_response_addtrailers_headers">response.addTrailers(headers)</a></li>
<li><a href="#all_response_end_data_encoding">response.end([data], [encoding])</a></li>
</ul>
</li>
<li><a href="#all_http_request_options_callback">http.request(options, callback)</a></li>
<li><a href="#all_http_get_options_callback">http.get(options, callback)</a></li>
<li><a href="#all_http_agent">http.Agent</a></li>
<li><a href="#all_http_getagent_host_port">http.getAgent(host, port)</a><ul>
<li><a href="#all_event_upgrade">Event: &apos;upgrade&apos;</a></li>
<li><a href="#all_event_continue">Event: &apos;continue&apos;</a></li>
<li><a href="#all_agent_maxsockets">agent.maxSockets</a></li>
<li><a href="#all_agent_sockets">agent.sockets</a></li>
<li><a href="#all_agent_queue">agent.queue</a></li>
</ul>
</li>
<li><a href="#all_http_clientrequest">http.ClientRequest</a><ul>
<li><a href="#all_event_response">Event &apos;response&apos;</a></li>
<li><a href="#all_request_write_chunk_encoding_utf8">request.write(chunk, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_request_end_data_encoding">request.end([data], [encoding])</a></li>
<li><a href="#all_request_abort">request.abort()</a></li>
</ul>
</li>
<li><a href="#all_http_clientresponse">http.ClientResponse</a><ul>
<li><a href="#all_event_data_3">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_3">Event: &apos;end&apos;</a></li>
<li><a href="#all_response_statuscode_1">response.statusCode</a></li>
<li><a href="#all_response_httpversion">response.httpVersion</a></li>
<li><a href="#all_response_headers">response.headers</a></li>
<li><a href="#all_response_trailers">response.trailers</a></li>
<li><a href="#all_response_setencoding_encoding_null">response.setEncoding(encoding=null)</a></li>
<li><a href="#all_response_pause">response.pause()</a></li>
<li><a href="#all_response_resume">response.resume()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_http_1">HTTP</a><ul>
<li><a href="#all_http_server_1">http.Server</a><ul>
<li><a href="#all_evento_request_2">Evento: &apos;request&apos;</a></li>
<li><a href="#all_evento_connection_1">Evento: &apos;connection&apos;</a></li>
<li><a href="#all_evento_close_2">Evento: &apos;close&apos;</a></li>
<li><a href="#all_evento_request_3">Evento: &apos;request&apos;</a></li>
<li><a href="#all_evento_checkcontinue_1">Evento: &apos;checkContinue&apos;</a></li>
<li><a href="#all_evento_upgrade_1">Evento: &apos;upgrade&apos;</a></li>
<li><a href="#all_evento_clienterror_1">Evento: &apos;clientError&apos;</a></li>
<li><a href="#all_http_createserver_requestlistener_1">http.createServer(requestListener)</a></li>
<li><a href="#all_server_listen_port_hostname_callback_1">server.listen(port, [hostname], [callback])</a></li>
<li><a href="#all_server_listen_path_callback_1">server.listen(path, [callback])</a></li>
<li><a href="#all_server_close_2">server.close()</a></li>
</ul>
</li>
<li><a href="#all_http_serverrequest_1">http.ServerRequest</a><ul>
<li><a href="#all_event_data_4">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_4">Event: &apos;end&apos;</a></li>
<li><a href="#all_request_method_1">request.method</a></li>
<li><a href="#all_request_url_1">request.url</a></li>
<li><a href="#all_request_headers_1">request.headers</a></li>
<li><a href="#all_request_trailers_1">request.trailers</a></li>
<li><a href="#all_request_httpversion_1">request.httpVersion</a></li>
<li><a href="#all_request_setencoding_encoding_null_1">request.setEncoding(encoding=null)</a></li>
<li><a href="#all_request_pause_1">request.pause()</a></li>
<li><a href="#all_request_resume_1">request.resume()</a></li>
<li><a href="#all_request_connection_1">request.connection</a></li>
</ul>
</li>
<li><a href="#all_http_serverresponse_1">http.ServerResponse</a><ul>
<li><a href="#all_response_writecontinue_1">response.writeContinue()</a></li>
<li><a href="#all_response_writehead_statuscode_reasonphrase_headers_1">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li>
<li><a href="#all_response_statuscode_2">response.statusCode</a></li>
<li><a href="#all_response_setheader_name_value_1">response.setHeader(name, value)</a></li>
<li><a href="#all_response_getheader_name_1">response.getHeader(name)</a></li>
<li><a href="#all_response_removeheader_name_1">response.removeHeader(name)</a></li>
<li><a href="#all_response_write_chunk_encoding_utf8_1">response.write(chunk, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_response_addtrailers_headers_1">response.addTrailers(headers)</a></li>
<li><a href="#all_response_end_data_encoding_1">response.end([data], [encoding])</a></li>
</ul>
</li>
<li><a href="#all_http_request_options_callback_1">http.request(options, callback)</a></li>
<li><a href="#all_http_get_options_callback_1">http.get(options, callback)</a></li>
<li><a href="#all_http_agent_1">http.Agent</a></li>
<li><a href="#all_http_getagent_host_port_1">http.getAgent(host, port)</a><ul>
<li><a href="#all_event_upgrade_1">Event: &apos;upgrade&apos;</a></li>
<li><a href="#all_event_continue_1">Event: &apos;continue&apos;</a></li>
<li><a href="#all_agent_maxsockets_1">agent.maxSockets</a></li>
<li><a href="#all_agent_sockets_1">agent.sockets</a></li>
<li><a href="#all_agent_queue_1">agent.queue</a></li>
</ul>
</li>
<li><a href="#all_http_clientrequest_1">http.ClientRequest</a><ul>
<li><a href="#all_event_response_1">Event &apos;response&apos;</a></li>
<li><a href="#all_request_write_chunk_encoding_utf8_1">request.write(chunk, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_request_end_data_encoding_1">request.end([data], [encoding])</a></li>
<li><a href="#all_request_abort_1">request.abort()</a></li>
</ul>
</li>
<li><a href="#all_http_clientresponse_1">http.ClientResponse</a><ul>
<li><a href="#all_event_data_5">Event: &apos;data&apos;</a></li>
<li><a href="#all_event_end_5">Event: &apos;end&apos;</a></li>
<li><a href="#all_response_statuscode_3">response.statusCode</a></li>
<li><a href="#all_response_httpversion_1">response.httpVersion</a></li>
<li><a href="#all_response_headers_1">response.headers</a></li>
<li><a href="#all_response_trailers_1">response.trailers</a></li>
<li><a href="#all_response_setencoding_encoding_null_1">response.setEncoding(encoding=null)</a></li>
<li><a href="#all_response_pause_1">response.pause()</a></li>
<li><a href="#all_response_resume_1">response.resume()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_url">URL</a><ul>
<li><a href="#all_url_parse_urlstr_parsequerystring_slashesdenotehost">url.parse(urlStr, [parseQueryString], [slashesDenoteHost])</a><ul>
<li><a href="#all_url_format_urlobj">url.format(urlObj)</a></li>
</ul>
</li>
<li><a href="#all_url_resolve_from_to">url.resolve(from, to)</a></li>
</ul>
</li>
<li><a href="#all_cadena_de_consulta">Cadena de consulta</a><ul>
<li><a href="#all_querystring_stringify_obj_sep_eq">querystring.stringify(obj, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)</a></li>
<li><a href="#all_querystring_parse_str_sep_eq">querystring.parse(str, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)</a></li>
<li><a href="#all_querystring_escape">querystring.escape</a></li>
<li><a href="#all_querystring_unescape">querystring.unescape</a></li>
</ul>
</li>
<li><a href="#all_readline">Readline</a><ul>
<li><a href="#all_createinterface_input_output_completer">createInterface(input, output, completer)</a></li>
<li><a href="#all_interface_setprompt_prompt_length">interface.setPrompt(prompt, length)</a></li>
<li><a href="#all_interface_prompt">interface.prompt()</a></li>
<li><a href="#all_interface_question_query_cb">interface.question(query, cb)</a><ul>
<li><a href="#all_interface_close">interface.close()</a></li>
</ul>
</li>
<li><a href="#all_interface_pause">interface.pause()</a></li>
<li><a href="#all_interface_resume">interface.resume()</a></li>
<li><a href="#all_interface_write">interface.write()</a></li>
</ul>
</li>
<li><a href="#all_repl">REPL</a><ul>
<li><a href="#all_repl_start_prompt_stream_eval_useglobal_ignoreundefined">repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined])</a></li>
<li><a href="#all_caracter_sticas_de_repl">Características de REPL</a></li>
</ul>
</li>
<li><a href="#all_executing_javascript">Executing JavaScript</a><ul>
<li><a href="#all_vm_runinthiscontext_code_filename">vm.runInThisContext(code, [filename])</a></li>
<li><a href="#all_vm_runinnewcontext_code_sandbox_filename">vm.runInNewContext(code, [sandbox], [filename])</a></li>
<li><a href="#all_vm_runincontext_code_context_filename">vm.runInContext(code, context, [filename])</a></li>
<li><a href="#all_vm_createcontext_initsandbox">vm.createContext([initSandbox])</a></li>
<li><a href="#all_vm_createscript_code_filename">vm.createScript(code, [filename])</a></li>
<li><a href="#all_class_script">Class: Script</a><ul>
<li><a href="#all_script_runinthiscontext">script.runInThisContext()</a></li>
<li><a href="#all_script_runinnewcontext_sandbox">script.runInNewContext([sandbox])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_child_process">Child Process</a><ul>
<li><a href="#all_class_childprocess">Class: ChildProcess</a><ul>
<li><a href="#all_evento_exit_1">Evento:  &apos;exit&apos;</a></li>
<li><a href="#all_event_disconnect">Event: &apos;disconnect&apos;</a></li>
<li><a href="#all_child_stdin">child.stdin</a></li>
<li><a href="#all_child_stdout">child.stdout</a></li>
<li><a href="#all_child_stderr">child.stderr</a></li>
<li><a href="#all_child_pid">child.pid</a></li>
<li><a href="#all_child_kill_signal">child.kill([signal])</a></li>
<li><a href="#all_child_send_message_sendhandle">child.send(message, [sendHandle])</a></li>
</ul>
</li>
<li><a href="#all_child_process_spawn_command_args_options">child_process.spawn(command, [args], [options])</a></li>
<li><a href="#all_child_process_exec_command_options_callback">child_process.exec(command, [options], callback)</a></li>
<li><a href="#all_child_process_execfile_file_args_options_callback">child_process.execFile(file, args, options, callback)</a></li>
<li><a href="#all_child_process_fork_modulepath_args_options">child_process.fork(modulePath, [args], [options])</a></li>
</ul>
</li>
<li><a href="#all_assert">Assert</a><ul>
<li><a href="#all_assert_fail_actual_expected_message_operator">assert.fail(actual, expected, message, operator)</a></li>
<li><a href="#all_assert_ok_value_message">assert.ok(value, [message])</a></li>
<li><a href="#all_assert_equal_actual_expected_message">assert.equal(actual, expected, [message])</a></li>
<li><a href="#all_assert_notequal_actual_expected_message">assert.notEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_deepequal_actual_expected_message">assert.deepEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_notdeepequal_actual_expected_message">assert.notDeepEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_strictequal_actual_expected_message">assert.strictEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_notstrictequal_actual_expected_message">assert.notStrictEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_throws_block_error_message">assert.throws(block, [error], [message])</a></li>
<li><a href="#all_assert_doesnotthrow_block_error_message">assert.doesNotThrow(block, [error], [message])</a></li>
<li><a href="#all_assert_iferror_value">assert.ifError(value)</a></li>
</ul>
</li>
<li><a href="#all_tty_terminal">TTY (Terminal)</a><ul>
<li><a href="#all_tty_open_path_args">tty.open(path, args=[])</a></li>
<li><a href="#all_tty_isatty_fd">tty.isatty(fd)</a></li>
<li><a href="#all_tty_setrawmode_mode">tty.setRawMode(mode)</a></li>
<li><a href="#all_tty_setwindowsize_fd_row_col">tty.setWindowSize(fd, row, col)</a></li>
<li><a href="#all_tty_getwindowsize_fd">tty.getWindowSize(fd)</a></li>
</ul>
</li>
<li><a href="#all_zlib">Zlib</a><ul>
<li><a href="#all_examples">Examples</a></li>
<li><a href="#all_constants">Constants</a></li>
<li><a href="#all_zlib_creategzip_options">zlib.createGzip([options])</a></li>
<li><a href="#all_zlib_creategunzip_options">zlib.createGunzip([options])</a></li>
<li><a href="#all_zlib_createdeflate_options">zlib.createDeflate([options])</a></li>
<li><a href="#all_zlib_createinflate_options">zlib.createInflate([options])</a></li>
<li><a href="#all_zlib_createdeflateraw_options">zlib.createDeflateRaw([options])</a></li>
<li><a href="#all_zlib_createinflateraw_options">zlib.createInflateRaw([options])</a></li>
<li><a href="#all_zlib_createunzip_options">zlib.createUnzip([options])</a></li>
<li><a href="#all_class_zlib_gzip">Class: zlib.Gzip</a></li>
<li><a href="#all_class_zlib_gunzip">Class: zlib.Gunzip</a></li>
<li><a href="#all_class_zlib_deflate">Class: zlib.Deflate</a></li>
<li><a href="#all_class_zlib_inflate">Class: zlib.Inflate</a></li>
<li><a href="#all_class_zlib_deflateraw">Class: zlib.DeflateRaw</a></li>
<li><a href="#all_class_zlib_inflateraw">Class: zlib.InflateRaw</a></li>
<li><a href="#all_class_zlib_unzip">Class: zlib.Unzip</a></li>
<li><a href="#all_convenience_methods">Convenience Methods</a></li>
<li><a href="#all_zlib_deflate_buf_callback">zlib.deflate(buf, callback)</a></li>
<li><a href="#all_zlib_deflateraw_buf_callback">zlib.deflateRaw(buf, callback)</a></li>
<li><a href="#all_zlib_gzip_buf_callback">zlib.gzip(buf, callback)</a></li>
<li><a href="#all_zlib_gunzip_buf_callback">zlib.gunzip(buf, callback)</a></li>
<li><a href="#all_zlib_inflate_buf_callback">zlib.inflate(buf, callback)</a></li>
<li><a href="#all_zlib_inflateraw_buf_callback">zlib.inflateRaw(buf, callback)</a></li>
<li><a href="#all_zlib_unzip_buf_callback">zlib.unzip(buf, callback)</a></li>
<li><a href="#all_options">Options</a></li>
<li><a href="#all_memory_usage_tuning">Memory Usage Tuning</a></li>
</ul>
</li>
<li><a href="#all_m_dulo_os">Módulo os</a><ul>
<li><a href="#all_os_hostname">os.hostname()</a></li>
<li><a href="#all_os_type">os.type()</a></li>
<li><a href="#all_os_release">os.release()</a></li>
<li><a href="#all_os_uptime">os.uptime()</a></li>
<li><a href="#all_os_loadavg">os.loadavg()</a></li>
<li><a href="#all_os_totalmem">os.totalmem()</a></li>
<li><a href="#all_os_freemem">os.freemem()</a></li>
<li><a href="#all_os_cpus">os.cpus()</a></li>
</ul>
</li>
<li><a href="#all_depurador">Depurador</a><ul>
<li><a href="#all_watchers">Watchers</a></li>
<li><a href="#all_commands_reference">Commands reference</a><ul>
<li><a href="#all_stepping">Stepping</a></li>
<li><a href="#all_breakpoints">Breakpoints</a></li>
<li><a href="#all_info">Info</a></li>
<li><a href="#all_execution_control">Execution control</a></li>
<li><a href="#all_various">Various</a></li>
</ul>
</li>
<li><a href="#all_uso_avanzado">Uso avanzado</a></li>
</ul>
</li>
<li><a href="#all_cluster">Cluster</a><ul>
<li><a href="#all_cluster_settings">cluster.settings</a></li>
<li><a href="#all_cluster_ismaster">cluster.isMaster</a></li>
<li><a href="#all_cluster_isworker">cluster.isWorker</a></li>
<li><a href="#all_event_fork">Event: &apos;fork&apos;</a></li>
<li><a href="#all_event_online">Event: &apos;online&apos;</a></li>
<li><a href="#all_event_listening_1">Event: &apos;listening&apos;</a></li>
<li><a href="#all_event_death">Event: &apos;death&apos;</a></li>
<li><a href="#all_event_setup">Event: &apos;setup&apos;</a></li>
<li><a href="#all_cluster_setupmaster_settings">cluster.setupMaster([settings])</a></li>
<li><a href="#all_cluster_fork_env">cluster.fork([env])</a></li>
<li><a href="#all_cluster_settings_1">cluster.settings</a></li>
<li><a href="#all_cluster_workers">cluster.workers</a></li>
<li><a href="#all_class_worker">Class: Worker</a><ul>
<li><a href="#all_worker_uniqueid">worker.uniqueID</a></li>
<li><a href="#all_worker_process">worker.process</a></li>
<li><a href="#all_worker_suicide">worker.suicide</a></li>
<li><a href="#all_worker_send_message_sendhandle">worker.send(message, [sendHandle])</a></li>
<li><a href="#all_worker_destroy">worker.destroy()</a></li>
<li><a href="#all_event_message">Event: &apos;message&apos;</a></li>
<li><a href="#all_event_online_1">Event: &apos;online&apos;</a></li>
<li><a href="#all_event_listening_2">Event: &apos;listening&apos;</a></li>
</ul>
</li>
<li><a href="#all_event_death_1">Event: &apos;death&apos;</a></li>
</ul>
</li>
<li><a href="#all_ap_ndice_1_m_dulos_de_terceros">Apéndice 1 - Módulos de terceros</a></li>
</ul>

          </div>

          <div id="apicontent">
            <h1>About this Documentation<span><a class="mark" href="#all_about_this_documentation" id="all_about_this_documentation">#</a></span></h1>
<!-- type=misc -->

<p>The goal of this documentation is to comprehensively explain the Node.js
API, both from a reference as well as a conceptual point of view.  Each
section describes a built-in module or high-level concept.

</p>
<p>Where appropriate, property types, method arguments, and the arguments
provided to event handlers are detailed in a list underneath the topic
heading.

</p>
<p>Every <code>.html</code> document has a corresponding <code>.json</code> document presenting
the same information in a structured manner.  This feature is
experimental, and added for the benefit of IDEs and other utilities that
wish to do programmatic things with the documentation.

</p>
<p>Every <code>.html</code> and <code>.json</code> file is generated based on the corresponding
<code>.markdown</code> file in the <code>doc/api/</code> folder in node&apos;s source tree.  The
documentation is generated using the <code>tools/doc/generate.js</code> program.
The HTML template is located at <code>doc/template.html</code>.

</p>
<h2>Stability Index<span><a class="mark" href="#all_stability_index" id="all_stability_index">#</a></span></h2>
<!--type=misc-->

<p>Throughout the documentation, you will see indications of a section&apos;s
stability.  The Node.js API is still somewhat changing, and as it
matures, certain parts are more reliable than others.  Some are so
proven, and so relied upon, that they are unlikely to ever change at
all.  Others are brand new and experimental, or known to be hazardous
and in the process of being redesigned.

</p>
<p>The notices look like this:

</p>
<pre><code>Stability: 1 Experimental</code></pre>
<p>The stability indices are as follows:

</p>
<ul>
<li><strong>0 - Deprecated</strong>  This feature is known to be problematic, and changes are
planned.  Do not rely on it.  Use of the feature may cause warnings.  Backwards
compatibility should not be expected.</li>
</ul>
<ul>
<li><strong>1 - Experimental</strong>  This feature was introduced recently, and may change
or be removed in future versions.  Please try it out and provide feedback.
If it addresses a use-case that is important to you, tell the node core team.</li>
</ul>
<ul>
<li><strong>2 - Unstable</strong>  The API is in the process of settling, but has not yet had
sufficient real-world testing to be considered stable. Backwards-compatibility
will be maintained if reasonable.</li>
</ul>
<ul>
<li><strong>3 - Stable</strong>  The API has proven satisfactory, but cleanup in the underlying
code may cause minor changes.  Backwards-compatibility is guaranteed.</li>
</ul>
<ul>
<li><strong>4 - API Frozen</strong>  This API has been tested extensively in production and is
unlikely to ever have to change.</li>
</ul>
<ul>
<li><strong>5 - Locked</strong>  Unless serious bugs are found, this code will not ever
change.  Please do not suggest changes in this area; they will be refused.</li>
</ul>
<h2>JSON Output<span><a class="mark" href="#all_json_output" id="all_json_output">#</a></span></h2>
<pre><code>Stability: 1 - Experimental</code></pre>
<p>Every HTML file in the markdown has a corresponding JSON file with the
same data.

</p>
<p>This feature is new as of node v0.6.12.  It is experimental.

</p>
<h1>Sinopsis<span><a class="mark" href="#all_sinopsis" id="all_sinopsis">#</a></span></h1>
<!--type=misc-->

<p>Un ejemplo de un <a href="http.html">servidor web</a> escrito en Node que responde con &apos;Hola
mundo&apos;:

</p>
<pre><code>var http = require(&apos;http&apos;);

http.createServer(function (request, response) {
  response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
  response.end(&apos;Hola mundo\n&apos;);
}).listen(8124);

console.log(&apos;Servidor ejecutándose en http://127.0.0.1:8124/&apos;);</code></pre>
<p>Para ejecutar el servidor, copie el código en un fichero llamado <code>example.js</code> y ejecútelo
con el programa node

</p>
<pre><code>&gt; node example.js
Servidor ejecutándose en http://127.0.0.1:8124/</code></pre>
<p>Todos los ejemplos en está documentación son ejecutados de manera similar.
</p>
<h1>Objetos Globales<span><a class="mark" href="#all_objetos_globales" id="all_objetos_globales">#</a></span></h1>
<!-- type=misc -->

<p>Estos objectos estan disponibles en todos los módulos. Algunos de estos
objetos no están en el ámbito global pero si a nivel módulo - Tómelo en cuenta.

</p>
<h2>global<span><a class="mark" href="#all_global" id="all_global">#</a></span></h2>
<!-- type=global -->

<ul>
<li>{Object} El namespace del objeto global.</li>
</ul>
<p>En los navegadores, el ambito del nivel superior es el ambito global. Esto significa
que en los navegadores si tu estas en el ambito global <code>var something</code> definirá una variable.
En Node esto es diferente. El ambito del nivel superior no es el ambito global; 
<code>var something</code> dentro de un módulo de node será local para este módulo.

</p>
<h3>process<span><a class="mark" href="#all_process" id="all_process">#</a></span></h3>
<!-- type=global -->

<ul>
<li>{Object}</li>
</ul>
<p>El objeto process. Véase la sección <a href="process.html#process">objeto process</a>.

</p>
<h3>console<span><a class="mark" href="#all_console" id="all_console">#</a></span></h3>
<!-- type=global -->

<ul>
<li>{Object}</li>
</ul>
<p>Usado para la salida de pantalla de stdout y stderr. Véase la sección <a href="stdio.html">stdio</a>

</p>
<h2>Class: Buffer<span><a class="mark" href="#all_class_buffer" id="all_class_buffer">#</a></span></h2>
<!-- type=global -->

<ul>
<li>{Function}</li>
</ul>
<p>Used to handle binary data. See the <a href="buffer.html">buffer section</a>.

</p>
<h2>require()<span><a class="mark" href="#all_require" id="all_require">#</a></span></h2>
<!-- type=var -->

<ul>
<li>{Function}</li>
</ul>
<p>Para requerir módulos. Véase la sección <a href="modules.html#modules">Módules</a>.
<code>require</code> no es global sino más bien local para cada módulo.

</p>
<h3>require.resolve()<span><a class="mark" href="#all_require_resolve" id="all_require_resolve">#</a></span></h3>
<p>Usa el mecanismo interno de <code>require()</code> para buscar la localización de un módulo,
pero en lugar de cargar el módulo, solo devuelve el nombre del fichero que lo contine.

</p>
<h3>require.cache<span><a class="mark" href="#all_require_cache" id="all_require_cache">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>Modules are cached in this object when they are required. By deleting a key
value from this object, the next <code>require</code> will reload the module.

</p>
<h3>__filename<span><a class="mark" href="#all_filename" id="all_filename">#</a></span></h3>
<!-- type=var -->

<ul>
<li>{String}</li>
</ul>
<p>El nombre del fichero que contiene al script que esta siendo ejecutado. 
Este esta definido como ruta absoluta, y no es necesariamente el mismo nombre
del fichero pasado como argumento en la linea de comando. El valor dentro
del módulo es la ruta al mismo.

</p>
<p>Ejemplo: Ejecutando <code>node example.js</code> desde <code>/User/mjr</code>

</p>
<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>
<p><code>__filename</code> isn&apos;t actually a global but rather local to each module.

</p>
<h2>__dirname<span><a class="mark" href="#all_dirname" id="all_dirname">#</a></span></h2>
<!-- type=var -->

<ul>
<li>{String}</li>
</ul>
<p>El nombre del directorio del script que esta siendo ejecutado.

</p>
<p>Ejemplo:Ejecutando <code>node example.js</code> desde <code>/User/mjr</code>

</p>
<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>
<p><code>__dirname</code> isn&apos;t actually a global but rather local to each module.


</p>
<h2>module<span><a class="mark" href="#all_module" id="all_module">#</a></span></h2>
<!-- type=var -->

<ul>
<li>{Object}</li>
</ul>
<p>Una referencia al actual módulo. En particular 
<code>module.exports</code> es igual al objeto <code>exports</code>.
<code>module</code> isn&apos;t actually a global but rather local to each module.

</p>
<p>Véase <a href="modules.html">la documentación del sistema de módulos</a> para más
información.

</p>
<h2>exports<span><a class="mark" href="#all_exports" id="all_exports">#</a></span></h2>
<!-- type=var -->

<p>An object which is shared between all instances of the current module and
made accessible through <code>require()</code>.
<code>exports</code> is the same as the <code>module.exports</code> object.
<code>exports</code> isn&apos;t actually a global but rather local to each module.

</p>
<p>See the <a href="modules.html">module system documentation</a> for more
information.

</p>
<p>See the <a href="modules.html">module section</a> for more information.

</p>
<h2>setTimeout(cb, ms)<span><a class="mark" href="#all_settimeout_cb_ms" id="all_settimeout_cb_ms">#</a></span></h2>
<h2>clearTimeout(t)<span><a class="mark" href="#all_cleartimeout_t" id="all_cleartimeout_t">#</a></span></h2>
<h2>setInterval(cb, ms)<span><a class="mark" href="#all_setinterval_cb_ms" id="all_setinterval_cb_ms">#</a></span></h2>
<h2>clearInterval(t)<span><a class="mark" href="#all_clearinterval_t" id="all_clearinterval_t">#</a></span></h2>
<!--type=global-->

<p>The timer functions are global variables. See the <a href="timers.html">timers</a> section.
</p>
<h1>console<span><a class="mark" href="#all_console_1" id="all_console_1">#</a></span></h1>
<pre><code>Stability: 4 - API Frozen</code></pre>
<ul>
<li>{Object}</li>
</ul>
<!--type=global-->

<p>For printing to stdout and stderr.  Similar to the console object functions
provided by most web browsers, here the output is sent to stdout or stderr.


</p>
<h2>console.log()<span><a class="mark" href="#all_console_log" id="all_console_log">#</a></span></h2>
<p>Prints to stdout with newline. This function can take multiple arguments in a
<code>printf()</code>-like way. Example:

</p>
<pre><code>console.log(&apos;count: %d&apos;, count);</code></pre>
<p>If formatting elements are not found in the first string then <code>util.inspect</code>
is used on each argument.
See <a href="util.html#util.format">util.format()</a> for more information.

</p>
<h2>console.info()<span><a class="mark" href="#all_console_info" id="all_console_info">#</a></span></h2>
<p>Same as <code>console.log</code>.

</p>
<h2>console.warn()<span><a class="mark" href="#all_console_warn" id="all_console_warn">#</a></span></h2>
<h2>console.error()<span><a class="mark" href="#all_console_error" id="all_console_error">#</a></span></h2>
<p>Same as <code>console.log</code> but prints to stderr.

</p>
<h2>console.dir(obj)<span><a class="mark" href="#all_console_dir_obj" id="all_console_dir_obj">#</a></span></h2>
<p>Uses <code>util.inspect</code> on <code>obj</code> and prints resulting string to stderr.

</p>
<h2>console.time(label)<span><a class="mark" href="#all_console_time_label" id="all_console_time_label">#</a></span></h2>
<p>Mark a time.


</p>
<h2>console.timeEnd(label)<span><a class="mark" href="#all_console_timeend_label" id="all_console_timeend_label">#</a></span></h2>
<p>Finish timer, record output. Example

</p>
<pre><code>console.time(&apos;100-elements&apos;);
for (var i = 0; i &lt; 100; i++) {
  ;
}
console.timeEnd(&apos;100-elements&apos;);</code></pre>
<h2>console.trace()<span><a class="mark" href="#all_console_trace" id="all_console_trace">#</a></span></h2>
<p>Print a stack trace to stderr of the current position.

</p>
<h2>console.assert()<span><a class="mark" href="#all_console_assert" id="all_console_assert">#</a></span></h2>
<p>Same as <code>assert.ok()</code>.

</p>
<h1>Timer<span><a class="mark" href="#all_timer" id="all_timer">#</a></span></h1>
<h2>setTimeout(callback, delay, [arg], [...])<span><a class="mark" href="#all_settimeout_callback_delay_arg" id="all_settimeout_callback_delay_arg">#</a></span></h2>
<p>Para programar la ejecución de <code>callback</code> después de <code>delay</code> milisegundos. Devuelve un <code>timeoutId</code> para un posible uso con <code>clearTimeout()</code>. Opcionalmente, tu puedes también pasar argumentos al callback.

</p>
<h2>clearTimeout(timeoutId)<span><a class="mark" href="#all_cleartimeout_timeoutid" id="all_cleartimeout_timeoutid">#</a></span></h2>
<p>Evita la ejecución de un callback por uno de sus disparadores.

</p>
<h2>setInterval(callback, delay, [arg], [...])<span><a class="mark" href="#all_setinterval_callback_delay_arg" id="all_setinterval_callback_delay_arg">#</a></span></h2>
<p>Para programar la repetición repetitiva de un <code>callback</code> cada <code>delay</code> milisegundos. Devuelve un <code>intervalId</code> para un posible uso con <code>clearInterval()</code>. Opcionalmente, tu puedes también pasar argumentos al callback.

</p>
<h2>clearInterval(intervalId)<span><a class="mark" href="#all_clearinterval_intervalid" id="all_clearinterval_intervalid">#</a></span></h2>
<p>Evita la ejecución de un callback por uno de sus disparadores.

</p>
<h1>Módulos<span><a class="mark" href="#all_m_dulos" id="all_m_dulos">#</a></span></h1>
<p>Node posee un secillo sistema de carga.  En Node, los ficheros y módulos son de
correspondencia biunívoca.  A modo de ejemplo, <code>foo.js</code> carga el módulo
<code>circle.js</code> en el mismo directorio.

</p>
<p>El contenido de <code>foo.js</code>:

</p>
<pre><code>var circle = require(&apos;./circle.js&apos;);
console.log( &apos;El área de un círculo con radio 4 es &apos;
           + circle.area(4));</code></pre>
<p>El contenido de <code>circle.js</code>:

</p>
<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>
<p>El módulo <code>circle.js</code> ha exportado las functiones <code>area()</code> y
<code>circumference()</code>.  Para exportar a un objeto, debe añadir el objeto especial
<code>exports</code>.


</p>
<p>Las variables locales del módulo serán privadas. En este ejemplo la variable <code>PI</code> es
privada en <code>circle.js</code>.

</p>
<h2>Módulos básicos<span><a class="mark" href="#all_m_dulos_b_sicos" id="all_m_dulos_b_sicos">#</a></span></h2>
<p>Node posee varios módulos compilados en binario.  Estos módulos son
descritos con más detalle en las siguientes secciones del documento.

</p>
<p>Los módulos básicos son definidos en el código fuente de node en la carpeta <code>lib/</code>.

</p>
<p>Los módulos básicos tienen la preferencia de cargarse primero si su indentificador es
pasado desde <code>require()</code>. Por ejemplo, <code>require(&apos;http&apos;)</code> siempre
devolverá lo construido en el módulo HTTP, incluso si hay un fichero con ese nombre.

</p>
<h2>Módulo File<span><a class="mark" href="#all_m_dulo_file" id="all_m_dulo_file">#</a></span></h2>
<p>Si el nombre exacto del fichero no es encontrado, entonces node intentará cargar 
el nombre del fichero seguido de la extensión <code>.js</code>, y a continuación con <code>.node</code>.

</p>
<p>Los ficheros <code>.js</code> son interpretados como ficheros de texto en JavaScript, y los ficheros <code>.node</code>
son interpretados como extensiones de módulos compilados cargados con <code>dlopen</code>.

</p>
<p>Un módulo con el prefijo <code>&apos;/&apos;</code> indica la ruta absoluta al fichero.  Por
ejemplo, <code>require(&apos;/home/marco/foo.js&apos;)</code> cargará el fichero en
<code>/home/marco/foo.js</code>.

</p>
<p>Un módulo con el prefijo <code>&apos;./&apos;</code> es relativo al fichero llamado con <code>require()</code>.
Es decir, <code>circle.js</code> debe estar en el mismo directorio que <code>foo.js</code> para que 
<code>require(&apos;./circle&apos;)</code> lo encuentre.

</p>
<p>Si se omite el uso de &apos;/&apos; o &apos;./&apos; en el fichero, el módulo puede ser un
&quot;módulo básico&quot; o se cargará desde la carpeta <code>node_modules</code>.


</p>
<h2>Cargando desde la carpeta <code>node_modules</code><span><a class="mark" href="#all_cargando_desde_la_carpeta_node_modules" id="all_cargando_desde_la_carpeta_node_modules">#</a></span></h2>
<p>Si el identificador del módulo pasa a <code>require()</code> no es un módulo nativo,
y no comienza con <code>&apos;/&apos;</code>, <code>&apos;../&apos;</code>, o <code>&apos;./&apos;</code>, entonces node inicia en el 
directorio principal del módulo actual, y añade <code>/node_modules</code>, e
intenta cargar el módulo desde esa ubicación.

</p>
<p>Si no se encuentra, entonces se dirige al directorio principal, y así 
sucesivamente, hasta que el módulo es encontrado, hasta en la raíz del árbol es
encontrado.

</p>
<p>Por ejemplo, si el fichero en <code>&apos;/home/ry/projects/foo.js&apos;</code> es llamado como
<code>require(&apos;bar.js&apos;)</code>, entonces node buscaría en las siguientes ubicaciones, en
este orden:

</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>Esto permite que los programas encuentren sus dependencias, de modo que no
entren en conflicto.


</p>
<h3>Optimización de proceso de búsqueda en <code>node_modules</code><span><a class="mark" href="#all_optimizaci_n_de_proceso_de_b_squeda_en_node_modules" id="all_optimizaci_n_de_proceso_de_b_squeda_en_node_modules">#</a></span></h3>
<p>Cuando existen muchos niveles de dependencias anidadas, es posible que los
árboles de directorios tomen bastante tiempo. Las siguientes optimizaciones se
realizan para este proceso.

</p>
<p>Primero, <code>/node_modules</code> no debe ser anexado a una carpeta ya que termina en
<code>/node_modules</code>.

</p>
<p>Segundo, si el fichero es llamado con  <code>require()</code> ya esta en la jerarquía de
<code>node_modules</code>, entonces el nivel superior de la carpeta <code>node_modules</code> es tratada como
la raíz del árbol de búsqueda.

</p>
<p>For example, if the file at
<code>&apos;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&apos;</code>
called <code>require(&apos;asdf.js&apos;)</code>, then node would search the following
locations:

</p>
<p>Por ejemplo, si el fichero en
<code>&apos;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&apos;</code>
llama como <code>require(&apos;asdf.js&apos;)</code>, entonces node buscaría en las siguientes
ubicaciones:

</p>
<ul>
<li><code>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/asdf.js</code></li>
<li><code>/home/ry/projects/foo/node_modules/bar/node_modules/asdf.js</code></li>
<li><code>/home/ry/projects/foo/node_modules/asdf.js</code></li>
</ul>
<h2>Carpetas como módulos<span><a class="mark" href="#all_carpetas_como_m_dulos" id="all_carpetas_como_m_dulos">#</a></span></h2>
<p>Es conveniente organizar los programas y librerías en los mismos directorios,
y proporcionar un único punto de entrar a la biblioteca.
Existe tres formas en donde una carpeta pueda usar <code>require()</code> como
un argumento.

</p>
<p>Lo primero es crear el fichero <code>package.json</code>en la raíz de la carpeta,
que especifique el módulo <code>main</code>. Un ejemplo de package.json podría verse
como esto:


</p>
<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>
<p>Si fuera una carpeta en <code>./some-library</code>, entonces
<code>require(&apos;./some-library&apos;)</code> trataría de cargar
<code>./some-library/lib/some-library.js</code>.

</p>
<p>Este es el mayor grado de conciencia de Node con el fichero package.json .

</p>
<p>Si no hay ningún fichero package.json presente en el directorio, entonces node
intentará cargar el fichero <code>index.js</code> o <code>index.node</code> de ese directorio.
Por ejemplo, si no hay ninguín fichero package.json en el ejemplo anterior,
entonces <code>require(&apos;./some-library&apos;)</code> intentará cargar:

</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>
<h2>Almacenamiento en la caché<span><a class="mark" href="#all_almacenamiento_en_la_cach" id="all_almacenamiento_en_la_cach">#</a></span></h2>
<p>Los módulos se alamacenan en la caché después que fueron cargados por primera vez.
Esto significa (entre otras cosas) que todas las llamadas a <code>require(&apos;foo&apos;)</code> devuelve
el mismo ojecto exacto, si se resolvería en el mismo fichero

</p>
<h2>Todos juntos...<span><a class="mark" href="#all_todos_juntos" id="all_todos_juntos">#</a></span></h2>
<p>Para obtener el nombre exacto del fichero que se cargará cuando se llame con <code>require()</code>, use
la función <code>require.resolve()</code>.

</p>
<p>Uniendo todo lo anterior, aquí se muestra un algoritmo de alto nievel
en pseudocódigo de lo que haría require.resolve :

</p>
<pre><code>require(X)
1. Si X es módulo básico,
   a. devolver el módulo básico
   b. STOP
2. Si X inicia con con `./` or `/`,
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

LOAD_AS_FILE(X)
1. Si X es un fichero, cargar X como texto JavaScript.  STOP
2. Si X.js es un fichero, cargar X.js como texto JavaScript.  STOP
3. Si X.node es un fichero, cargar X.node como extensión binaria.  STOP

LOAD_AS_DIRECTORY(X)
1. Si X/package.json es un fichero,
   a. Parsear X/package.json, y buscar el campo &quot;main&quot;.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. LOAD_AS_FILE(X/index)

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index es una instancia de &quot;node_modules&quot; en PARTS, o 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
6. return DIRS</code></pre>
<h2>Cargar desde las carpetas de <code>require.paths</code><span><a class="mark" href="#all_cargar_desde_las_carpetas_de_require_paths" id="all_cargar_desde_las_carpetas_de_require_paths">#</a></span></h2>
<p>En node, <code>require.paths</code> es un array de strings que representa las rutas de
acceso a los módulos cuando estos no tienen el prefijo <code>&apos;/&apos;</code>, <code>&apos;./&apos;</code>, o
<code>&apos;../&apos;</code>.  Por ejemplo, si establece require.paths como:

</p>
<pre><code>[ &apos;/home/micheil/.node_modules&apos;,
  &apos;/usr/local/lib/node_modules&apos; ]</code></pre>
<p>A continuación se llama a <code>require(&apos;bar/baz.js&apos;)</code> y buscará en las siguientes
ubicaciones:

</p>
<ul>
<li>1: <code>&apos;/home/micheil/.node_modules/bar/baz.js&apos;</code></li>
<li>2: <code>&apos;/usr/local/lib/node_modules/bar/baz.js&apos;</code></li>
</ul>
<p>El array en <code>require.paths</code> puede ser transformado en tiempo de ejecución para modificar
este comportamiento.

</p>
<p>Se establece inicialmente la variable de entorno <code>NODE_PATH</code>, que contiene 
una lista delimitada por dos puntos de rutas exactas.  En el anterior ejemplo,
la variable de entorno <code>NODE_PATH</code> puedo haber sido establecido como:

</p>
<pre><code>/home/micheil/.node_modules:/usr/local/lib/node_modules</code></pre>
<p>Cargar las ubicaciones desde <code>require.paths</code> sólo se realiza si el
módulon no se ha encontrado desde el algoritmo <code>node_modules</code>.
Los módulos globarles son de baja prioridad para las dependencias de los paquetes.

</p>
<h3><strong>Nota:</strong> Por favor evite la modificación de <code>require.paths</code><span><a class="mark" href="#all_nota_por_favor_evite_la_modificaci_n_de_require_paths" id="all_nota_por_favor_evite_la_modificaci_n_de_require_paths">#</a></span></h3>
<p>Por razones de compatibilidad, <code>require.paths</code> sigue siendo la primera prioridad
en el proceso de búsqueda de módulos. Sin embargo, puede desaparecer en una próxima
versión.

</p>
<p>Aunque parecía una buena idea en aquel tiempo, y ha permitido ser un 
experimento muy útil, en la práctica la transformación de <code>require.paths</code> es una
lista a menudo con problemas y dolores de cabeza.

</p>
<h4>Establecer <code>require.paths</code> a algún otro valor para nada.<span><a class="mark" href="#all_establecer_require_paths_a_alg_n_otro_valor_para_nada" id="all_establecer_require_paths_a_alg_n_otro_valor_para_nada">#</a></span></h4>
<p>Esto no hace nada de lo que se podría esperar:

</p>
<pre><code>require.paths = [ &apos;/usr/lib/node&apos; ];</code></pre>
<p>Todo lo que se hace aquí es perder la referencia <em>actual</em> de node en la búsqueda
de rutas, y crea una nueva referencia a otra cosa que no sirve
para nada.

</p>
<h4>Poner rutas relativas en <code>require.paths</code> es... raro.<span><a class="mark" href="#all_poner_rutas_relativas_en_require_paths_es_raro" id="all_poner_rutas_relativas_en_require_paths_es_raro">#</a></span></h4>
<p>Si hace esto:

</p>
<pre><code>require.paths.push(&apos;./lib&apos;);</code></pre>
<p>entonces <em>no</em> añada la ruta completa donde se resolvió <code>./lib</code>
en este sistema de ficheros.  En cambio, esto añade literalmente <code>&apos;./lib&apos;</code>,
lo que significa si hace <code>require(&apos;y.js&apos;)</code> en  <code>/a/b/x.js</code>, entonces se ve
en <code>/a/b/lib/y.js</code>.  Si a continuación se usa <code>require(&apos;y.js&apos;)</code> en
<code>/l/m/n/o/p.js</code>, entonces se ve en <code>/l/m/n/o/lib/y.js</code>.

</p>
<p>En la práctica, las personas han usado esto de una manera ad hoc para la
dependencia de paquetes, pero esta técnica es frágil.

</p>
<h4>Cero aislamiento<span><a class="mark" href="#all_cero_aislamiento" id="all_cero_aislamiento">#</a></span></h4>
<p>Existe (debido a un diseño lamentable), sólo un array <code>require.paths</code> utilizado para
todos los módulos.

</p>
<p>Como resultado, si un programa en node trata de confiar de este comportamiento, es posible
que de manera permanente y sutilmente altere el comportamiento de todos los programas 
escritos en node el mismo proceso. A media que el stack crece, y se reune más
funcionalidades, ya que esto es un problema con las partes que interactúan en forma
difíciles de predecir.

</p>
<h2>Addenda: Consejos para administrar paquetes<span><a class="mark" href="#all_addenda_consejos_para_administrar_paquetes" id="all_addenda_consejos_para_administrar_paquetes">#</a></span></h2>
<p>La semántica de Node en la función <code>require()</code> fue diseñada para ser lo 
suficientemente general para soportar una serie de esctructuras de directorios.
Los paquetes de programas como <code>dpkg</code>, <code>rpm</code>, y <code>npm</code> se esperan que sean construidos 
como paquetes nativos desde los módulos de Node sin modificaciones.

</p>
<p>A continuación sugerimos una estructura en la que puede trabajar:

</p>
<p>Supongamos que se desea tener en 
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> se mantenga el contenido de una
versión específica de un paquete.

</p>
<p>Los paquetes pueden depender uno del otro. Con el fin de instalar el paquete <code>foo</code>, 
puede que tenga que instalar una versión específica del paquete <code>bar</code>.  El paquete
 <code>bar</code> puede tener dependencias, y en algunos casos, estas dependencias, incluso pueden 
entrar en conflicto o crear ciclos.

</p>
<p>Desde la búsqueda con Node de la <code>ruta</code> de cualquier módulo cargado (es decir,
resueltos los enlaces simbólicos), y luego de buscar sus dependencias en la
carpeta <code>node_modules</code> como se describió anteriormente, esta situación es muy simple de 
resolver con la siguiente arquitectura:

</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Contenido del paquete <code>foo</code>, versión 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Contenido del paquete <code>bar</code> que es
dependencia de <code>foo</code>.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Enlace simbólico a
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Enlaces simbólicos a los paquetes
que <code>bar</code> depende.</li>
</ul>
<p>Por lo tanto, incluso si se encuentra, o si hay problemas de dependencias,
cada módulo será capza de obtener una versión de su dependencia para ser
utilizada.

</p>
<p>Cuando el código en el paquete <code>foo</code> utiliza <code>require(&apos;bar&apos;)</code>, se obtendrá la
versión al enlace simbólico en <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Luego, cuando el código del paquete <code>bar</code> llame a <code>require(&apos;quux&apos;)</code>, obtendrá
la versión simbólica en <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.

</p>
<p>Además, para hacer el proceso de búsqueda del módulo aún más óptima, en lugar
de poner los paquetes directamente en <code>/usr/lib/node</code>, se puede poner estos en
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Entonces node no se molestará en
buscar por dependencias no encontradas en <code>/usr/node_modules</code> o <code>/node_modules</code>.

</p>
<p>A fin de que los módulos disponibles para node en REPL, puedan ser útiles,
añade también la carpeta <code>/usr/lib/node_modules</code> a la variable de entorno <code>$NODE_PATH</code>.
Desde el módulo de búsquedas usando la carpeta <code>node_modules</code> donde todo es
relativo, y basado en la ruta real de los ficheros llamados por <code>require()</code>, 
los paquetes pueden ser llamado desde cualquier lugar.

</p>
<h1>Addons<span><a class="mark" href="#all_addons" id="all_addons">#</a></span></h1>
<p>Addons son objetos enlazados dinamicamente. Ellos pueden ser el pegamento entre las librerias C y C++ con NodeJS. La API (en estos momentos) es algo compleja, siendo necesario el conocimiento de varias librerias.

</p>
<ul>
<li><p>V8 JavaScript, una libreria C++. Usada como interfaz con JavaScript:
creación de objetos, llamada a funciones, etc. Documentada extensamente en fichero de cabecera <code>v8.h</code> (<code>deps/v8/include/v8.h</code> en el arbol de fuentes de Node).</p>
</li>
<li><p>libev, C libreria para crear un bucle de evento. En cualquier momentos que sea necesario esperar para que el descriptor de un fichero llegue a ser legible, esperar por un timer, o esperar por una señal, que llevarlo a cabo será necesario utilizar el intefez de libev. Esto es, si tu realizas cualquier I/O, necesitaras usar libev. Node usa en bucle de evento <code>EV_DEFAULT</code>. La documentación puede ser encontrada <a href="http://cvs.schmorp.de/libev/ev.html">aqui</a>.</p>
</li>
<li><p>libie, librería para manejar el pool de las hebras. Usado para hacer llamadas bloqueantes POSIX del sistema de forma asincrona. Una amplia variedad de envolturas ya existe para cada llamada, en <code>src/file.cc</code> por lo que posiblemente no tengas que usarla. Si necesitas usarla echale un vistazo al fichero de cabecera <code>deps/libie/eio.h</code>.</p>
</li>
<li><p>Librerias internas de Node. La más importante es la clase <code>node::ObjectWrap</code> que probablemente de la que tu desearas heredar.</p>
</li>
<li><p>Otras. Mira en <code>deps/</code> para cualquier cosa disponible.</p>
</li>
</ul>
<p>Node estáticamente compila todas las dependencias dentro del ejecutable. Cuando compiles tú módulo, tu no tendrás que preocuparte sobre enlazar ninguna de estas librerias.

</p>
<p>Para comenzar hagamos un pequeño Addon el cual hará lo siguiente in C++:

</p>
<pre><code>exports.hello = &apos;world&apos;;</code></pre>
<p>Para comenzar creamos el fichero <code>hello.cc</code>:

</p>
<pre><code>#include &lt;v8.h&gt;

using namespace v8;

extern &quot;C&quot; void
init (Handle&lt;Object&gt; target)
{
  HandleScope scope;
  target-&gt;Set(String::New(&quot;hello&quot;), String::New(&quot;world&quot;));
}</code></pre>
<p>Este código fuente necesita ser construido dentro de <code>hello.node</code>, el Addon binario. Para hacer esto nosotros creamos un fichero llamado <code>wscript</code> el cual es código python y se ve como sigue:

</p>
<pre><code>srcdir = &apos;.&apos;
blddir = &apos;build&apos;
VERSION = &apos;0.0.1&apos;

def set_options(opt):
  opt.tool_options(&apos;compiler_cxx&apos;)

def configure(conf):
  conf.check_tool(&apos;compiler_cxx&apos;)
  conf.check_tool(&apos;node_addon&apos;)

def build(bld):
  obj = bld.new_task_gen(&apos;cxx&apos;, &apos;shlib&apos;, &apos;node_addon&apos;)
  obj.target = &apos;hello&apos;
  obj.source = &apos;hello.cc&apos;</code></pre>
<p>Lanzando <code>node-waf configure build</code> crearemos un fichero <code>build/default/hello.node</code> el cual es nuestro Addon.

</p>
<p><code>node-waf</code> es solo <a href="http://code.google.com/p/waf">WAF</a>, el sistema de construcción basado en python. <code>node-waf</code> is proporcionado para la facilidad de los usuarios.

</p>
<p>Todos los Addons de Node deben exportar un función llamada <code>init</code> con la siguiente constitución:

</p>
<pre><code>extern &apos;C&apos; void init (Handle&lt;Object&gt; target)</code></pre>
<p>Por el momento, esta es toda la documentación sobre Addons. Por favor, mira <a href="https://github.com/ry/node_postgres">https://github.com/ry/node_postgres</a> para un ejemplo real.

</p>
<h1>process<span><a class="mark" href="#all_process_1" id="all_process_1">#</a></span></h1>
<p>El objeto <code>process</code> es un objeto global y puede ser accedido desde cualquier parte.
Es una instancia de <code>EventEmitter</code>.


</p>
<h2>Evento: &apos;exit&apos;<span><a class="mark" href="#all_evento_exit" id="all_evento_exit">#</a></span></h2>
<p><code>function () {}</code>

</p>
<p>Emitido cuando el proceso está apunto de salir. Es un buen hook para realizar 
un control del tiempo constante del estado del módulo (por ejemplo para tests unitarios).<br>El bucle del evento principal no seguirá ejecutándose después de finalizar el callback &apos;exit&apos;, 
por lo tanto los timers no pueden ser programados.

</p>
<p>Ejemplo escuchando a <code>exit</code>:

</p>
<pre><code>process.on(&apos;exit&apos;, function () {
  process.nextTick(function () {
   console.log(&apos;Esto no se ejecutará&apos;);
  });
  console.log(&apos;Apunto de salir.&apos;);
});</code></pre>
<h2>Evento: &apos;uncaughtException&apos;<span><a class="mark" href="#all_evento_uncaughtexception" id="all_evento_uncaughtexception">#</a></span></h2>
<p><code>function (err) { }</code>

</p>
<p>Emitido cuando una excepción es devuelta hacia el bucle de evento. Si se
ha añadido un listener a esta excepción, no se producirá la acción por defecto 
(imprimir una traza del stack y salir).

</p>
<p>Ejemplo escuchando a <code>uncaughtException</code>:

</p>
<pre><code>process.on(&apos;uncaughtException&apos;, function (err) {
  console.log(&apos;Excepción recogida: &apos; + err);
});

setTimeout(function () {
  console.log(&apos;Esto seguirá ejecutándose.&apos;);
}, 500);

// Se fuerza una excepción, pero no se recoge.
nonexistentFunc();
console.log(&apos;Esto no se ejecutará.&apos;);</code></pre>
<p>Nótese que <code>uncaughtException</code> es un mecanismo muy básico para 
manejar excepciones.  Usando try / catch en tu programa te dará más control sobre
el flujo de tu programa. Especialmente para aplicaciones de servidor que están diseñados para
ejecutarse eternamente, <code>uncaughtException</code> puede ser un mecanismo muy útil de seguridad.


</p>
<h2>Eventos de señal<span><a class="mark" href="#all_eventos_de_se_al" id="all_eventos_de_se_al">#</a></span></h2>
<p><code>function () {}</code>

</p>
<p>Emitido cuando los procesos reciben una señal. Mirar sigaction(2) para una lista de 
nombres de señal estándard POSIX como SIGINT, SIGUSR1, etc.

</p>
<p>Ejemplo escuchando a <code>SIGINT</code>:

</p>
<pre><code>// Empieza leyendo de stdin para evitar salir.
process.stdin.resume();

process.on(&apos;SIGINT&apos;, function () {
  console.log(&apos;Recibido SIGINT.  Haz Control-D para salir.&apos;);
});</code></pre>
<p>Una manera sencilla de enviar la señal <code>SIGINT</code> es con <code>Control-C</code> en la mayoria 
de aplicaciones de terminal.


</p>
<h2>process.stdout<span><a class="mark" href="#all_process_stdout" id="all_process_stdout">#</a></span></h2>
<p>Un <code>Stream de Escritura</code> para <code>stdout</code>.

</p>
<p>Ejemplo: la definición de <code>console.log</code>

</p>
<pre><code>console.log = function (d) {
  process.stdout.write(d + &apos;\n&apos;);
};</code></pre>
<h3>process.stderr<span><a class="mark" href="#all_process_stderr" id="all_process_stderr">#</a></span></h3>
<p>Un stream de escritura para stderr. Las escrituras en este stream son bloqueantes.


</p>
<h3>process.stdin<span><a class="mark" href="#all_process_stdin" id="all_process_stdin">#</a></span></h3>
<p>Un <code>Stream de Lectura</code> para stdin. El stream stdin se detiene por defecto, así que 
se tiene que llamar a <code>process.stdin.resume()</code> para leer de él.

</p>
<p>Ejemplo de como abir la entrada estándard (stdin) y escuchar a ambos eventos:

</p>
<pre><code>process.stdin.resume();
process.stdin.setEncoding(&apos;utf8&apos;);

process.stdin.on(&apos;data&apos;, function (chunk) {
  process.stdout.write(&apos;data: &apos; + chunk);
});

process.stdin.on(&apos;end&apos;, function () {
  process.stdout.write(&apos;end&apos;);
});</code></pre>
<h3>process.argv<span><a class="mark" href="#all_process_argv" id="all_process_argv">#</a></span></h3>
<p>Un array que contiene los argumentos de la línea de comandos. El primer elemento será
&apos;node&apos;, el segundo elemento será el nombre del fichero JavaScript. Los
siguientes elementos serán argumentos adicionales de la línea de comandos.

</p>
<pre><code>// imprimir process.argv
process.argv.forEach(function (val, index, array) {
  console.log(index + &apos;: &apos; + val);
});</code></pre>
<p>Generará:

</p>
<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four</code></pre>
<h3>process.execPath<span><a class="mark" href="#all_process_execpath" id="all_process_execpath">#</a></span></h3>
<p>Es la ruta absoluta del ejecutable que inició el proceso.

</p>
<p>Ejemplo:

</p>
<pre><code>/usr/local/bin/node</code></pre>
<h2>process.chdir(directory)<span><a class="mark" href="#all_process_chdir_directory" id="all_process_chdir_directory">#</a></span></h2>
<p>Cambia el directorio actual de trabajo del proceso o lanza una excepción si falla.

</p>
<pre><code>console.log(&apos;Directorio inicial: &apos; + process.cwd());
try {
  process.chdir(&apos;/tmp&apos;);
  console.log(&apos;Directorio nuevo: &apos; + process.cwd());
}
catch (err) {
  console.log(&apos;chdir: &apos; + err);
}</code></pre>
<h2>process.cwd()<span><a class="mark" href="#all_process_cwd" id="all_process_cwd">#</a></span></h2>
<p>Devuelve el directorio actual de trabajo del proceso.

</p>
<pre><code>console.log(&apos;Directorio actual: &apos; + process.cwd());</code></pre>
<h3>process.env<span><a class="mark" href="#all_process_env" id="all_process_env">#</a></span></h3>
<p>Un objeto que contiene el entorno del usuario. Mirar environ(7).


</p>
<h3>process.exit(code=0)<span><a class="mark" href="#all_process_exit_code_0" id="all_process_exit_code_0">#</a></span></h3>
<p>Termina el proceso con el <code>code</code> especificado.  Si se omite, <code>exit</code> usa el código 
de &apos;éxito&apos; <code>0</code>.

</p>
<p>Para salir con un código de &apos;fallo&apos;:

</p>
<pre><code>process.exit(1);</code></pre>
<p>El shell que ha ejecutado node debería ver 1 como código de salida.


</p>
<h2>process.getgid()<span><a class="mark" href="#all_process_getgid" id="all_process_getgid">#</a></span></h2>
<p>Obtiene la identidad de grupo del proceso.  (Mirar getgid(2).)
Es el id de grupo numérico, no el nombre del grupo.

</p>
<pre><code>console.log(&apos;Actual gid: &apos; + process.getgid());</code></pre>
<h3>process.setgid(id)<span><a class="mark" href="#all_process_setgid_id" id="all_process_setgid_id">#</a></span></h3>
<p>Establece la identidad de grupo del proceso. (Mirar setgid(2).)  Acepta tanto 
un ID numérico como una cadena de texto con el nombre del grupo. 
Si se especifica el nombre del grupo, el método se bloquea mientras lo 
resuelve a un ID numérico.

</p>
<pre><code>console.log(&apos;Actual gid: &apos; + process.getgid());
try {
  process.setgid(501);
  console.log(&apos;Nuevo gid: &apos; + process.getgid());
}
catch (err) {
  console.log(&apos;Fallo al cambiar el gid: &apos; + err);
}</code></pre>
<h2>process.getuid()<span><a class="mark" href="#all_process_getuid" id="all_process_getuid">#</a></span></h2>
<p>Obtiene la identidad de usuario del proceso. (Mirar getuid(2).)
Es la id de usuario númerica, no el nombre de usuario.

</p>
<pre><code>console.log(&apos;Actual uid: &apos; + process.getuid());</code></pre>
<h3>process.setuid(id)<span><a class="mark" href="#all_process_setuid_id" id="all_process_setuid_id">#</a></span></h3>
<p>Establece la identidad de usuario del proceso. (Mirar setuid(2).)  Acepta tanto 
un ID numérico como una cadena de texto con el nombre de usuario.  Si se especifica 
el nombre de usuario, el método se bloquea mientras lo resuelve a un ID numérico.

</p>
<pre><code>console.log(&apos;Actual uid: &apos; + process.getuid());
try {
  process.setuid(501);
  console.log(&apos;Nuevo uid: &apos; + process.getuid());
}
catch (err) {
  console.log(&apos;Fallo al establecer uid: &apos; + err);
}</code></pre>
<h2>process.version<span><a class="mark" href="#all_process_version" id="all_process_version">#</a></span></h2>
<p>Una propiedad dentro del compilado que expone <code>NODE_VERSION</code>.

</p>
<pre><code>console.log(&apos;Versión: &apos; + process.version);</code></pre>
<h2>process.installPrefix<span><a class="mark" href="#all_process_installprefix" id="all_process_installprefix">#</a></span></h2>
<p>Una propiedad dentro del compilado que expone <code>NODE_PREFIX</code>.

</p>
<pre><code>console.log(&apos;Prefijo: &apos; + process.installPrefix);</code></pre>
<h2>process.kill(pid, signal=&apos;SIGTERM&apos;)<span><a class="mark" href="#all_process_kill_pid_signal_sigterm" id="all_process_kill_pid_signal_sigterm">#</a></span></h2>
<p>Envia una señal a un proceso. <code>pid</code> es la id de proceso y <code>signal</code> es la cadena de 
texto que describe la señal a enviar.  Los nombres de señales son cadenas de texto
 como &apos;SIGINT&apos; o &apos;SIGUSR1&apos;.  Si se omite, la señal será &apos;SIGTERM&apos;.
Mirar kill(2) para más información.

</p>
<p>Notar que ya que el nombre de la función es <code>process.kill</code>, se trata solo de 
un emisor de señales, como la llamada a sistema <code>kill</code>. La señal enviada
puede hacer algo más que matar el proceso escogido.

</p>
<p>Ejemplo de como enviarse una señal a uno mismo:

</p>
<pre><code>process.on(&apos;SIGHUP&apos;, function () {
  console.log(&apos;Recibida señal SIGHUP.&apos;);
});

setTimeout(function () {
  console.log(&apos;Saliendo.&apos;);
  process.exit(0);
}, 100);

process.kill(process.pid, &apos;SIGHUP&apos;);</code></pre>
<h2>process.pid<span><a class="mark" href="#all_process_pid" id="all_process_pid">#</a></span></h2>
<p>El PID del proceso.

</p>
<pre><code>console.log(&apos;El pid de este proceso es  &apos; + process.pid);</code></pre>
<h3>process.title<span><a class="mark" href="#all_process_title" id="all_process_title">#</a></span></h3>
<p>Getter/setter para establecer lo que mostrará &apos;ps&apos;.


</p>
<h2>process.platform<span><a class="mark" href="#all_process_platform" id="all_process_platform">#</a></span></h2>
<p>En que plataforma se está ejecutando. <code>&apos;linux2&apos;</code>, <code>&apos;darwin&apos;</code>, etc.

</p>
<pre><code>console.log(&apos;La plataforma es &apos; + process.platform);</code></pre>
<h3>process.memoryUsage()<span><a class="mark" href="#all_process_memoryusage" id="all_process_memoryusage">#</a></span></h3>
<p>Devuelve un objeto describiendo el uso de la memoria del proceso Node.

</p>
<pre><code>var util = require(&apos;util&apos;);

console.log(util.inspect(process.memoryUsage()));</code></pre>
<p>Generará:

</p>
<pre><code>{ rss: 4935680,
  vsize: 41893888,
  heapTotal: 1826816,
  heapUsed: 650472 }</code></pre>
<p><code>heapTotal</code> y <code>heapUsed</code> se refieren al uso de la memoria de V8.


</p>
<h3>process.nextTick(callback)<span><a class="mark" href="#all_process_nexttick_callback" id="all_process_nexttick_callback">#</a></span></h3>
<p>En la siguiente iteración del bucle del evento se llama a callback.
No es simplemente un alias para <code>setTimeout(fn, 0)</code> , es mucho
más eficiente.

</p>
<pre><code>process.nextTick(function () {
  console.log(&apos;nextTick callback&apos;);
});</code></pre>
<h3>process.umask([mask])<span><a class="mark" href="#all_process_umask_mask" id="all_process_umask_mask">#</a></span></h3>
<p>Establece o lee la máscara del modo de creación del fichero del proceso. Los procesos 
hijos heredan la máscara del proceso padre. Devuelve la antigua máscara si se pasa el argumento 
<code>mask</code>, si no devuelve la máscara actual. 

</p>
<pre><code>var oldmask, newmask = 0644;

oldmask = process.umask(newmask);
console.log(&apos;Cambiada umask de: &apos; + oldmask.toString(8) +
            &apos; a &apos; + newmask.toString(8));</code></pre>
<h1>util<span><a class="mark" href="#all_util" id="all_util">#</a></span></h1>
<pre><code>Stability: 5 - Locked</code></pre>
<p>Estas funciones estan en el módulo <code>&apos;util&apos;</code>. Usa <code>require(&apos;util&apos;)</code> para acceder 
a ellas.


</p>
<h2>util.format()<span><a class="mark" href="#all_util_format" id="all_util_format">#</a></span></h2>
<p>Returns a formatted string using the first argument as a <code>printf</code>-like format.

</p>
<p>The first argument is a string that contains zero or more <em>placeholders</em>.
Each placeholder is replaced with the converted value from its corresponding
argument. Supported placeholders are:

</p>
<ul>
<li><code>%s</code> - String.</li>
<li><code>%d</code> - Number (both integer and float).</li>
<li><code>%j</code> - JSON.</li>
<li><code>%%</code> - single percent sign (<code>&apos;%&apos;</code>). This does not consume an argument.</li>
</ul>
<p>If the placeholder does not have a corresponding argument, the placeholder is
not replaced.

</p>
<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;); // &apos;foo:%s&apos;</code></pre>
<p>If there are more arguments than placeholders, the extra arguments are
converted to strings with <code>util.inspect()</code> and these strings are concatenated,
delimited by a space.

</p>
<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;); // &apos;foo:bar baz&apos;</code></pre>
<p>If the first argument is not a format string then <code>util.format()</code> returns
a string that is the concatenation of all its arguments separated by spaces.
Each argument is converted to a string with <code>util.inspect()</code>.

</p>
<pre><code>util.format(1, 2, 3); // &apos;1 2 3&apos;</code></pre>
<h2>util.debug(string)<span><a class="mark" href="#all_util_debug_string" id="all_util_debug_string">#</a></span></h2>
<p>Una función de salida síncrona. Bloquerá el proceso y pondrá 
<code>string</code> inmediatamente en <code>stderr</code>.

</p>
<pre><code>require(&apos;util&apos;).debug(&apos;mensaje en stderr&apos;);</code></pre>
<h3>util.log(string)<span><a class="mark" href="#all_util_log_string" id="all_util_log_string">#</a></span></h3>
<p>Salida con timestamp en <code>stdout</code>.

</p>
<pre><code>require(&apos;util&apos;).log(&apos;Mensaje con marca de tiempo.&apos;);</code></pre>
<h3>util.inspect(object, showHidden=false, depth=2)<span><a class="mark" href="#all_util_inspect_object_showhidden_false_depth_2" id="all_util_inspect_object_showhidden_false_depth_2">#</a></span></h3>
<p>Devuelve la cadena que representa a <code>object</code>, lo cual es útil para corregir fallos.

</p>
<p>Si <code>showHidden</code> es <code>true</code>, entonces las propiedades no-enumerables del 
objeto serán mostradas también. Por omisión es <code>false</code>.

</p>
<p>Si <code>depth</code> es proporcionado, le dice a <code>inspect</code> cuantas veces tiene que recurrir
mientras formatea el objeto. Esto es útil para objetos muy largos y complejos.

</p>
<p>Por defecto solo se recurre un par de veces. Para hacer que recurra indefinidamente
pasa <code>null</code> a <code>depth</code>.

</p>
<p>Si <code>colors</code> es <code>true</code>, entonces la salida mostrará los estilos con los código de colores en ANSI.
Por omisión es <code>false</code>.

</p>
<p>Ejemplo de inspeccionar todas las propiedades del objeto <code>util</code>:

</p>
<pre><code>var util = require(&apos;util&apos;);

console.log(util.inspect(util, true, null));</code></pre>
<h2>util.isArray(object)<span><a class="mark" href="#all_util_isarray_object" id="all_util_isarray_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Array</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isArray([])
  // true
util.isArray(new Array)
  // true
util.isArray({})
  // false</code></pre>
<h2>util.isRegExp(object)<span><a class="mark" href="#all_util_isregexp_object" id="all_util_isregexp_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>RegExp</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isRegExp(/some regexp/)
  // true
util.isRegExp(new RegExp(&apos;another regexp&apos;))
  // true
util.isRegExp({})
  // false</code></pre>
<h2>util.isDate(object)<span><a class="mark" href="#all_util_isdate_object" id="all_util_isdate_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Date</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isDate(new Date())
  // true
util.isDate(Date())
  // false (without &apos;new&apos; returns a String)
util.isDate({})
  // false</code></pre>
<h2>util.isError(object)<span><a class="mark" href="#all_util_iserror_object" id="all_util_iserror_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Error</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isError(new Error())
  // true
util.isError(new TypeError())
  // true
util.isError({ name: &apos;Error&apos;, message: &apos;an error occurred&apos; })
  // false</code></pre>
<h2>util.pump(readableStream, writableStream, [callback])<span><a class="mark" href="#all_util_pump_readablestream_writablestream_callback" id="all_util_pump_readablestream_writablestream_callback">#</a></span></h2>
<p>Experimental

</p>
<p>Lee los datos desde <code>readableStream</code> y los envia al <code>writableStream</code>.
Cuando <code>writableStream.write(data)</code> devuelve <code>false</code> <code>readableStream</code> será
pausado hasta que ocurra el evento <code>drain</code> sobre <code>writableStream</code>. <code>callback</code>
tiene un error como único argumento y es llamada cuando <code>writableStream</code> es
cerrado o cuando ocurre un error.


</p>
<h3>util.inherits(constructor, superConstructor)<span><a class="mark" href="#all_util_inherits_constructor_superconstructor" id="all_util_inherits_constructor_superconstructor">#</a></span></h3>
<p>Hereda los métodos del prototype desde un 
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor">constructor</a>
dentro de otro. El prototype del <code>constructor</code> será configurado a un nuevo
objecto creado desde <code>superConstructor</code>.

</p>
<p>Como mejora adicional, <code>superConstructor</code>será accesible atravez de 
la propiedad <code>constructor.super_</code>.

</p>
<pre><code>var util = require(&quot;util&quot;);
var events = require(&quot;events&quot;);

function MyStream() {
    events.EventEmitter.call(this);
}

util.inherits(MyStream, events.EventEmitter);

MyStream.prototype.write = function(data) {
    this.emit(&quot;data&quot;, data);
}

var stream = new MyStream();

console.log(stream instanceof events.EventEmitter); // true
console.log(MyStream.super_ === events.EventEmitter); // true

stream.on(&quot;data&quot;, function(data) {
    console.log(&apos;Received data: &quot;&apos; + data + &apos;&quot;&apos;);
})
stream.write(&quot;It works!&quot;); // Received data: &quot;It works!&quot;</code></pre>
<h1>Eventos<span><a class="mark" href="#all_eventos" id="all_eventos">#</a></span></h1>
<p>Muchos objetos en Node emiten eventos: un <code>net.Server</code> emite un evento cada vez que se establece una conexión, un <code>fs.readStream</code> emite un evento cuando se abre un fichero. Todos los objectos que emiten eventos son instancias de <code>events.EventEmitter</code>.
Puedes usar este módulo haciendo <code>require(&quot;events&quot;);</code>

</p>
<p>Normalmente, los nombres de los eventos siguen la notacion camel-case, sin embargo, no hay ninguna restricción en este aspecto y cualquier cadena será aceptada.

</p>
<p>Se pueden adjuntar funciones a objetos, para que sean ejecutadas cuando se emita un evento. Estas funciones reciben el nombre de <em>listeners</em>. 

</p>
<h2>events.EventEmitter<span><a class="mark" href="#all_events_eventemitter" id="all_events_eventemitter">#</a></span></h2>
<p>Para usar la clase EventEmitter, haz de importarla
haciendo <code>require(&apos;events&apos;).EventEmiter</code>.

</p>
<p>Cuando una instancia de la clase EventEmitter se encuentra con un error, la acción típica
es emitir un evento de error. Los eventos de error son tratados como un caso especial en node.
Si no tiene un listener asociado la acción por defecto será imprimir la traza de la pila y salir
del programa

</p>
<p>Todos los EventEmitters emite el evento <code>&apos;newListener&apos;</code> cuando se añaden nuevos listeners.

</p>
<h2>emitter.addListener(event, listener)<span><a class="mark" href="#all_emitter_addlistener_event_listener" id="all_emitter_addlistener_event_listener">#</a></span></h2>
<h2>emitter.on(event, listener)<span><a class="mark" href="#all_emitter_on_event_listener" id="all_emitter_on_event_listener">#</a></span></h2>
<p>Añade un listener al final del array de listeners para el evento espeficicado

</p>
<pre><code>server.on(&apos;connection&apos;, function (stream) {
  console.log(&apos;someone connected!&apos;);
});</code></pre>
<h2>emitter.once(event, listener)<span><a class="mark" href="#all_emitter_once_event_listener" id="all_emitter_once_event_listener">#</a></span></h2>
<p>Añade un listener al evento. El listener se invocará sólo la primera vez que se dispara el evento.
luego se elimina. 

</p>
<pre><code>server.once(&apos;connection&apos;, function (stream) {
  console.log(&apos;Ah, we have our first user!&apos;);
});</code></pre>
<h2>emitter.removeListener(event, listener)<span><a class="mark" href="#all_emitter_removelistener_event_listener" id="all_emitter_removelistener_event_listener">#</a></span></h2>
<p>Elimina un listener del array de listeners asociado al evento especificado
<strong>Atención</strong>: modifica el indice del array de listeners 

</p>
<pre><code>var callback = function(stream) {
  console.log(&apos;someone connected!&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);</code></pre>
<h2>emitter.removeAllListeners(event)<span><a class="mark" href="#all_emitter_removealllisteners_event" id="all_emitter_removealllisteners_event">#</a></span></h2>
<p>Elimina todos los listeners del array de listeners asociado al evento especificado

</p>
<h2>emitter.setMaxListeners(n)<span><a class="mark" href="#all_emitter_setmaxlisteners_n" id="all_emitter_setmaxlisteners_n">#</a></span></h2>
<p>Por defecto los EventEmitters imprimirán un warning si se le añaden más de 10 listeners.
Este comportamiento por defecto ayuda a encontrar memory leaks. Obviamente no todos los EventEmitters
deberían limitarse a 10. Esta función permite incrementar este valor. Use cero para establecer un valor ilimitado.


</p>
<h2>emitter.listeners(event)<span><a class="mark" href="#all_emitter_listeners_event" id="all_emitter_listeners_event">#</a></span></h2>
<p>Devuelve un array de listeners asociado al evento especificado. Este array puede ser manipulado, por ejemplo, eliminando un listener.

</p>
<pre><code>server.on(&apos;connection&apos;, function (stream) {
  console.log(&apos;someone connected!&apos;);
});
console.log(util.inspect(server.listeners(&apos;connection&apos;)); // [ [Function] ]</code></pre>
<h2>emitter.emit(event, [arg1], [arg2], [...])<span><a class="mark" href="#all_emitter_emit_event_arg1_arg2" id="all_emitter_emit_event_arg1_arg2">#</a></span></h2>
<p>Llama a cada uno de los listeners en el orden en el que fueron pasados por parámetros

</p>
<h2>Event: &apos;newListener&apos;<span><a class="mark" href="#all_event_newlistener" id="all_event_newlistener">#</a></span></h2>
<p><code>function (event, listener) { }</code>

</p>
<p>Este evento es emitido cada vez que se añade un nuevo listener.

</p>
<h1>Buffer<span><a class="mark" href="#all_buffer" id="all_buffer">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>El puro Javascript es amigable con Unicode, pero no se lleva tan bien con 
los datos binarios. Cuando tratamos con streams TCP o ficheros del sistema,
es necesario manejar streams de octets. Node tiene algunas estrategias para
manipular, crear, y consumir streams de octets.

</p>
<p>Los datos en Raw son almacenados en instancias de la clase <code>Buffer</code>. Un 
<code>Buffer</code> es similar a un array de integers pero correspondiendo a una localización
en raw de la memeria fuera del heap de V8. Un <code>Buffer</code> no puede ser redimencionado.

</p>
<p>La clase <code>Buffer</code> es global, dado que es muy raro hacer un
<code>require(&apos;buffer&apos;)</code>.

</p>
<p>Convertir entre Buffers y objectos String de Javascript requiere de un método de 
codificación explícito. Aquí están las diferentes cadenas de codificación.

</p>
<ul>
<li><p><code>&apos;ascii&apos;</code> - solo para datos de 7 bit ASCII. Este método de codificación es muy rápido
y dejará el bit alto si está configurado.
Note that this encoding converts a null character (<code>&apos;\0&apos;</code> or <code>&apos;\u0000&apos;</code>) into
<code>0x20</code> (character code of a space). If you want to convert a null character
into <code>0x00</code>, you should use <code>&apos;utf8&apos;</code>.</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - Multiples bytes de caracteres con codificación Unicode. Muchas páginas webs y otros formatos de documentos usan UTF-8.</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> - 2-bytes, de caracteres con codificación <code>little endian</code> Unicode. 
Sólo pueden codificar BMP(Basic Multilingual Plane, U+0000 - U+FFFF).</p>
</li>
<li><p><code>&apos;base64&apos;</code> - String codificado a Base64.</p>
</li>
<li><p><code>&apos;binary&apos;</code> - Una forma de codificar datos binarios en Raw dentro de strings pero solo usando
los primeros 8 bits de cada caracter. Este método de codificación es obsoleto y
debe ser evitado en favor del objeto <code>Buffer</code> donde sea posible. Esta codificación
será eliminada en futuras versiones de Node.</p>
</li>
<li><p><code>&apos;hex&apos;</code> - Encode each byte as two hexidecimal characters.</p>
</li>
</ul>
<h2>Class: Buffer<span><a class="mark" href="#all_class_buffer_1" id="all_class_buffer_1">#</a></span></h2>
<p>The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.

</p>
<h3>new Buffer(size)<span><a class="mark" href="#all_new_buffer_size" id="all_new_buffer_size">#</a></span></h3>
<div class="signature"><ul>
<li><code>size</code> Number</li>
</div></ul>
<p>Asigna un nuevo buffer de <code>size</code> octets.

</p>
<h3>new Buffer(array)<span><a class="mark" href="#all_new_buffer_array" id="all_new_buffer_array">#</a></span></h3>
<div class="signature"><ul>
<li><code>array</code> Array</li>
</div></ul>
<p>Asigna un nuevo buffer usando un <code>array</code> de octets.

</p>
<h3>new Buffer(str, [encoding])<span><a class="mark" href="#all_new_buffer_str_encoding" id="all_new_buffer_str_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>str</code> String - string to encode.</li>
<li><code>encoding</code> String - encoding to use, Optional.</li>
</div></ul>
<p>Allocates a new buffer containing the given <code>str</code>.
<code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.

</p>
<h3>buf.write(string, [offset], [length], [encoding])<span><a class="mark" href="#all_buf_write_string_offset_length_encoding" id="all_buf_write_string_offset_length_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>string</code> String - data to be written to buffer</li>
<li><code>offset</code> Number, Optional, Default: 0</li>
<li><code>length</code> Number, Optional</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
</div></ul>
<p>Escribe <code>string</code> en el Buffer en <code>offset</code> usando el método dado.
<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>. <code>length</code> is
the number of bytes to write. Devuelve el número de octets escritos. Si <code>Buffer</code> 
no contiene suficiente espacio para encajar en el string completo, escribirá una
cantidad parcial de la cadena. <code>length</code> defaults to <code>buffer.length - offset</code>.
The method will not write partial characters.

</p>
<pre><code>buf = new Buffer(256);
len = buf.write(&apos;\u00bd + \u00bc = \u00be&apos;, 0);
console.log(len + &quot; bytes: &quot; + buf.toString(&apos;utf8&apos;, 0, len));</code></pre>
<p>The number of characters written (which may be different than the number of
bytes written) is set in <code>Buffer._charsWritten</code> and will be overwritten the
next time <code>buf.write()</code> is called.


</p>
<h3>buf.toString([encoding], [start], [end])<span><a class="mark" href="#all_buf_tostring_encoding_start_end" id="all_buf_tostring_encoding_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional</li>
</div></ul>
<p>Decodifica y devuelve un string con los datos de un buffer codificado con <code>encoding</code>
(por omisión en <code>&apos;utf8&apos;</code>) comenzando en <code>start</code> (por omisión <code>0</code>) y terminando en
<code>end</code> (por omisión <code>buffer.length</code>).

</p>
<p>Observe el ejemplo de <code>buffer.write()</code>, encima.


</p>
<h3>buf[index]<span><a class="mark" href="#all_buf_index" id="all_buf_index">#</a></span></h3>
<!--type=property-->
<!--name=[index]-->

<p>Obtiene y configura el octet en <code>index</code>. Los valores se refieren a bytes individuales,
por lo que el rango legal esta entre <code>0x00</code> and <code>0xFF</code> en hexadecimal o <code>0</code> y <code>255</code>.

</p>
<p>Ejemplo: Copiando un cadena ASCII dentro de un buffer, un byte cada vez:

</p>
<pre><code>str = &quot;node.js&quot;;
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>
<h3>Class Method: Buffer.isBuffer(obj)<span><a class="mark" href="#all_class_method_buffer_isbuffer_obj" id="all_class_method_buffer_isbuffer_obj">#</a></span></h3>
<div class="signature"><ul>
<li><code>obj</code> Object</li>
<li>Return: Boolean</li>
</div></ul>
<p>Comprueba si <code>obj</code> es un <code>Buffer</code>.

</p>
<h3>Class Method: Buffer.byteLength(string, [encoding])<span><a class="mark" href="#all_class_method_buffer_bytelength_string_encoding" id="all_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>string</code> String</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li>Return: Number</li>
</div></ul>
<p>Da la longitud de una cadena en bytes. <code>encoding</code> por omisión en <code>&apos;utf8&apos;</code>.
Esto no es lo mismo como <code>String.prototype.length</code> puesto que devuelve el
número de <em>caracteres</em> en el string.

</p>
<p>Ejemplo:

</p>
<pre><code>str = &apos;\u00bd + \u00bc = \u00be&apos;;

console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +
  Buffer.byteLength(str, &apos;utf8&apos;) + &quot; bytes&quot;);

// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
<h3>buf.length<span><a class="mark" href="#all_buf_length" id="all_buf_length">#</a></span></h3>
<div class="signature"><ul>
<li>Number</li>
</div></ul>
<p>El tamaño del buffer en bytes. Vea que esto no es necesariamente al tamaño
del contenido. <code>length</code> se refiere a la cantidad de memoria asignada para el
objeto buffer. No cambia cuando el contenido del buffer cambia.

</p>
<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write(&quot;some string&quot;, &quot;ascii&quot;, 0);
console.log(buf.length);

// 1234
// 1234</code></pre>
<h3>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])<span><a class="mark" href="#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend" id="all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">#</a></span></h3>
<div class="signature"><ul>
<li><code>targetBuffer</code> Buffer object - Buffer to copy into</li>
<li><code>targetStart</code> Number, Optional, Default: 0</li>
<li><code>sourceStart</code> Number, Optional, Default: 0</li>
<li><code>sourceEnd</code> Number, Optional, Default: 0</li>
</div></ul>
<p>Does copy between buffers. The source and target regions can be overlapped.
<code>targetStart</code> and <code>sourceStart</code> default to <code>0</code>.
<code>sourceEnd</code> defaults to <code>buffer.length</code>.

</p>
<p>Ejemplo: construye dos Buffers, entonces copia <code>buf1</code> desde el byte 16 hasta el byte 19
dentro de <code>buf2</code>, comenzando en el octavo byte de <code>buf2</code>.

</p>
<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString(&apos;ascii&apos;, 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
<h3>buf.slice([start], [end])<span><a class="mark" href="#all_buf_slice_start_end" id="all_buf_slice_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional, Default: 0</li>
</div></ul>
<p>Devuelve un nuevo buffer el cual hace referencia a la misma memoria que el antíguo,
pero desplazado y cortado por los indices <code>start</code> (por omisión <code>0</code>) and 
<code>end</code> (por omisión <code>buffer.length</code>).


</p>
<p><strong>¡Al modificar el nuevo buffer, modificarás la memoria en el buffer original!</strong>

</p>
<p>Ejemplo: contruye un Buffer con el alfabeto ASCII, toma un fragmento, y 
entonces modifica un byte desde el Buffer original.

</p>
<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));

// abc
// !bc</code></pre>
<h3>buf.readUInt8(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint8_offset_noassert" id="all_buf_readuint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// 0x3
// 0x4
// 0x23
// 0x42</code></pre>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint16le_offset_noassert" id="all_buf_readuint16le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint16be_offset_noassert" id="all_buf_readuint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint32le_offset_noassert" id="all_buf_readuint32le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint32be_offset_noassert" id="all_buf_readuint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403</code></pre>
<h3>buf.readInt8(offset, [noAssert])<span><a class="mark" href="#all_buf_readint8_offset_noassert" id="all_buf_readint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads a signed 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readInt16LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint16le_offset_noassert" id="all_buf_readint16le_offset_noassert">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint16be_offset_noassert" id="all_buf_readint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readInt32LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint32le_offset_noassert" id="all_buf_readint32le_offset_noassert">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint32be_offset_noassert" id="all_buf_readint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readFloatLE(offset, [noAssert])<span><a class="mark" href="#all_buf_readfloatle_offset_noassert" id="all_buf_readfloatle_offset_noassert">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a class="mark" href="#all_buf_readfloatbe_offset_noassert" id="all_buf_readfloatbe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// 0x01</code></pre>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a class="mark" href="#all_buf_readdoublele_offset_noassert" id="all_buf_readdoublele_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a class="mark" href="#all_buf_readdoublebe_offset_noassert" id="all_buf_readdoublebe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// 0.3333333333333333</code></pre>
<h3>buf.writeUInt8(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint8_value_offset_noassert" id="all_buf_writeuint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);

// &lt;Buffer 03 04 23 42&gt;</code></pre>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint16le_value_offset_noassert" id="all_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint16be_value_offset_noassert" id="all_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);

// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint32le_value_offset_noassert" id="all_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint32be_value_offset_noassert" id="all_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);

// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>
<h3>buf.writeInt8(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint8_value_offset_noassert" id="all_buf_writeint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&apos;s complement
signed integer into <code>buffer</code>.

</p>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint16le_value_offset_noassert" id="all_buf_writeint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint16be_value_offset_noassert" id="all_buf_writeint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint32le_value_offset_noassert" id="all_buf_writeint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint32be_value_offset_noassert" id="all_buf_writeint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writefloatle_value_offset_noassert" id="all_buf_writefloatle_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writefloatbe_value_offset_noassert" id="all_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 32 bit float.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writedoublele_value_offset_noassert" id="all_buf_writedoublele_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writedoublebe_value_offset_noassert" id="all_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);

// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
<h3>buf.fill(value, [offset], [end])<span><a class="mark" href="#all_buf_fill_value_offset_end" id="all_buf_fill_value_offset_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code></li>
<li><code>offset</code> Number, Optional</li>
<li><code>end</code> Number, Optional</li>
</div></ul>
<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire
buffer.

</p>
<pre><code>var b = new Buffer(50);
b.fill(&quot;h&quot;);</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#all_buffer_inspect_max_bytes" id="all_buffer_inspect_max_bytes">#</a></span></h2>
<div class="signature"><ul>
<li>Number, Default: 50</li>
</div></ul>
<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overridden by user modules.

</p>
<p>Note that this is a property on the buffer module returned by
<code>require(&apos;buffer&apos;)</code>, not on the Buffer global, or a buffer instance.

</p>
<h2>Class: SlowBuffer<span><a class="mark" href="#all_class_slowbuffer" id="all_class_slowbuffer">#</a></span></h2>
<p>This class is primarily for internal use.  JavaScript programs should
use Buffer instead of using SlowBuffer.

</p>
<p>In order to avoid the overhead of allocating many C++ Buffer objects for
small blocks of memory in the lifetime of a server, Node allocates memory
in 8Kb (8192 byte) chunks.  If a buffer is smaller than this size, then it
will be backed by a parent SlowBuffer object.  If it is larger than this,
then Node will allocate a SlowBuffer slab for it directly.
</p>
<h1>Streams<span><a class="mark" href="#all_streams" id="all_streams">#</a></span></h1>
<p>Un Stream es un interfaz abstracto implementado por varios objetos en Node. Por ejemplo una petición a un servidor HTTP es un Stream, como un stdout. Los Streams son legibles, escribibles o ambos. Todos los stream son instancias de <code>EventEmitter</code>.

</p>
<h2>Readable Stream<span><a class="mark" href="#all_readable_stream" id="all_readable_stream">#</a></span></h2>
<p>A <code>Readable Stream</code> has the following methods, members, and events.

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data" id="all_event_data">#</a></span></h3>
<p><code>function (data) { }</code>

</p>
<p>The <code>&apos;data&apos;</code> event emits either a <code>Buffer</code> (by default) or a string if
<code>setEncoding()</code> was used.

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end" id="all_event_end">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Emitted when the stream has received an EOF (FIN in TCP terminology).
Indicates that no more <code>&apos;data&apos;</code> events will happen. If the stream is also
writable, it may be possible to continue writing.

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error" id="all_event_error">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<p>Emitted if there was an error receiving data.

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close" id="all_event_close">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Emitted when the underlying file descriptor has been closed. Not all streams
will emit this.  (For example, an incoming HTTP request will not emit
<code>&apos;close&apos;</code>.)

</p>
<h3>Event: &apos;fd&apos;<span><a class="mark" href="#all_event_fd" id="all_event_fd">#</a></span></h3>
<p><code>function (fd) { }</code>

</p>
<p>Emitted when a file descriptor is received on the stream. Only UNIX streams
support this functionality; all others will simply never emit this event.

</p>
<h3>stream.readable<span><a class="mark" href="#all_stream_readable" id="all_stream_readable">#</a></span></h3>
<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>&apos;error&apos;</code>
occurred, the stream came to an <code>&apos;end&apos;</code>, or <code>destroy()</code> was called.

</p>
<h3>stream.setEncoding(encoding)<span><a class="mark" href="#all_stream_setencoding_encoding" id="all_stream_setencoding_encoding">#</a></span></h3>
<p>Makes the data event emit a string instead of a <code>Buffer</code>. <code>encoding</code> can be
<code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.

</p>
<h3>stream.pause()<span><a class="mark" href="#all_stream_pause" id="all_stream_pause">#</a></span></h3>
<p>Pauses the incoming <code>&apos;data&apos;</code> events.

</p>
<h3>stream.resume()<span><a class="mark" href="#all_stream_resume" id="all_stream_resume">#</a></span></h3>
<p>Resumes the incoming <code>&apos;data&apos;</code> events after a <code>pause()</code>.

</p>
<h3>stream.destroy()<span><a class="mark" href="#all_stream_destroy" id="all_stream_destroy">#</a></span></h3>
<p>Closes the underlying file descriptor. Stream will not emit any more events.


</p>
<h3>stream.destroySoon()<span><a class="mark" href="#all_stream_destroysoon" id="all_stream_destroysoon">#</a></span></h3>
<p>After the write queue is drained, close the file descriptor.

</p>
<h3>stream.pipe(destination, [options])<span><a class="mark" href="#all_stream_pipe_destination_options" id="all_stream_pipe_destination_options">#</a></span></h3>
<p>This is a <code>Stream.prototype</code> method available on all <code>Stream</code>s.

</p>
<p>Connects this read stream to <code>destination</code> WriteStream. Incoming
data on this stream gets written to <code>destination</code>. The destination and source
streams are kept in sync by pausing and resuming as necessary.

</p>
<p>Emulating the Unix <code>cat</code> command:

</p>
<pre><code>process.stdin.resume();
process.stdin.pipe(process.stdout);</code></pre>
<p>By default <code>end()</code> is called on the destination when the source stream emits
<code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end: false }</code> as
<code>options</code> to keep the destination stream open.

</p>
<p>This keeps <code>process.stdout</code> open so that &quot;Goodbye&quot; can be written at the end.

</p>
<pre><code>process.stdin.resume();

process.stdin.pipe(process.stdout, { end: false });

process.stdin.on(&quot;end&quot;, function() {
  process.stdout.write(&quot;Goodbye\n&quot;);
});</code></pre>
<p>NOTE: If the source stream does not support <code>pause()</code> and <code>resume()</code>, this function
adds simple definitions which simply emit <code>&apos;pause&apos;</code> and <code>&apos;resume&apos;</code> events on
the source stream.

</p>
<h2>Writable Stream<span><a class="mark" href="#all_writable_stream" id="all_writable_stream">#</a></span></h2>
<p>A <code>Writable Stream</code> has the following methods, members, and events.

</p>
<h3>Event: &apos;drain&apos;<span><a class="mark" href="#all_event_drain" id="all_event_drain">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Emitted after a <code>write()</code> method was called that returned <code>false</code> to
indicate that it is safe to write again.

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_1" id="all_event_error_1">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<p>Emitted on error with the exception <code>exception</code>.

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_1" id="all_event_close_1">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Emitted when the underlying file descriptor has been closed.

</p>
<h3>Event: &apos;pipe&apos;<span><a class="mark" href="#all_event_pipe" id="all_event_pipe">#</a></span></h3>
<p><code>function (src) { }</code>

</p>
<p>Emitted when the stream is passed to a readable stream&apos;s pipe method.

</p>
<h3>stream.writable<span><a class="mark" href="#all_stream_writable" id="all_stream_writable">#</a></span></h3>
<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>&apos;error&apos;</code>
occurred or <code>end()</code> / <code>destroy()</code> was called.

</p>
<h3>stream.write(string, encoding=&apos;utf8&apos;, [fd])<span><a class="mark" href="#all_stream_write_string_encoding_utf8_fd" id="all_stream_write_string_encoding_utf8_fd">#</a></span></h3>
<p>Writes <code>string</code> with the given <code>encoding</code> to the stream.  Returns <code>true</code> if
the string has been flushed to the kernel buffer.  Returns <code>false</code> to
indicate that the kernel buffer is full, and the data will be sent out in
the future. The <code>&apos;drain&apos;</code> event will indicate when the kernel buffer is
empty again. The <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.

</p>
<p>If the optional <code>fd</code> parameter is specified, it is interpreted as an integral
file descriptor to be sent over the stream. This is only supported for UNIX
streams, and is silently ignored otherwise. When writing a file descriptor in
this manner, closing the descriptor before the stream drains risks sending an
invalid (closed) FD.

</p>
<h3>stream.write(buffer)<span><a class="mark" href="#all_stream_write_buffer" id="all_stream_write_buffer">#</a></span></h3>
<p>Same as the above except with a raw buffer.

</p>
<h3>stream.end()<span><a class="mark" href="#all_stream_end" id="all_stream_end">#</a></span></h3>
<p>Terminates the stream with EOF or FIN.

</p>
<h3>stream.end(string, encoding)<span><a class="mark" href="#all_stream_end_string_encoding" id="all_stream_end_string_encoding">#</a></span></h3>
<p>Sends <code>string</code> with the given <code>encoding</code> and terminates the stream with EOF
or FIN. This is useful to reduce the number of packets sent.

</p>
<h3>stream.end(buffer)<span><a class="mark" href="#all_stream_end_buffer" id="all_stream_end_buffer">#</a></span></h3>
<p>Same as above but with a <code>buffer</code>.

</p>
<h3>stream.destroy()<span><a class="mark" href="#all_stream_destroy_1" id="all_stream_destroy_1">#</a></span></h3>
<p>Closes the underlying file descriptor. Stream will not emit any more events.

</p>
<h3>stream.destroySoon()<span><a class="mark" href="#all_stream_destroysoon_1" id="all_stream_destroysoon_1">#</a></span></h3>
<p>After the write queue is drained, close the file descriptor. <code>destroySoon()</code>
can still destroy straight away, as long as there is no data left in the queue
for writes.

</p>
<h1>Crypto<span><a class="mark" href="#all_crypto" id="all_crypto">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>Usa <code>require(&apos;crypto&apos;)</code> para acceder a este módulo.

</p>
<p>El módulo crypto necesita que OpenSSL esté disponible en el sistema.
Ofrece una forma de encapsular credenciales seguras para ser usadas 
como parte de una red HTTPS segura o una conexión http.

</p>
<p>Además ofrece un conjunto de envoltorios para los métodos hash, hmac, cipher, decipher, sign y verify de OpenSSL.

</p>
<h2>crypto.createCredentials(details)<span><a class="mark" href="#all_crypto_createcredentials_details" id="all_crypto_createcredentials_details">#</a></span></h2>
<p>Crea un objeto credenciales, con los detalles opcionales en forma de diccionario con las siguientes claves:

</p>
<ul>
<li><code>key</code> : cadena que contiene la clave privada codificada en PEM.</li>
<li><code>passphrase</code> : A string of passphrase for the private key</li>
<li><code>cert</code> : cadena que contiene el certificado codificado en PEM.</li>
<li><code>ca</code> : cadena o lista de cadenas de certificados de confianza codificados en PEM.</li>
<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List)</li>
<li><code>ciphers</code>: A string describing the ciphers to use or exclude. Consult
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a> for details
on the format.</li>
</ul>
<p>Si no se han dado ningún elemento en <code>ca</code>, node.js usará la lista de CAs de confianza publicadas como dice en
</p>
<p><a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.


</p>
<h3>crypto.createHash(algorithm)<span><a class="mark" href="#all_crypto_createhash_algorithm" id="all_crypto_createhash_algorithm">#</a></span></h3>
<p>Crea y devuelve un nuevo objeto hash, un hash criptográfico con el algoritmo 
dado que puede ser usado para generar el hash digests.

</p>
<p><code>algorithm</code> depende de los algoritmos disponibles en la versión de OpenSSL en el sistema.
Algunos ejemplos son <code>&apos;sha1&apos;</code>, <code>&apos;md5&apos;</code>, <code>&apos;sha256&apos;</code>, <code>&apos;sha512&apos;</code>, etc. 
En versiones recientes, <code>openssl list-message-digest-algorithms</code> mostrará los algoritmos digest disponibles.

</p>
<p>Example: this program that takes the sha1 sum of a file

</p>
<pre><code>var filename = process.argv[2];
var crypto = require(&apos;crypto&apos;);
var fs = require(&apos;fs&apos;);

var shasum = crypto.createHash(&apos;sha1&apos;);

var s = fs.ReadStream(filename);
s.on(&apos;data&apos;, function(d) {
  shasum.update(d);
});

s.on(&apos;end&apos;, function() {
  var d = shasum.digest(&apos;hex&apos;);
  console.log(d + &apos;  &apos; + filename);
});</code></pre>
<h2>Class: Hash<span><a class="mark" href="#all_class_hash" id="all_class_hash">#</a></span></h2>
<p>The class for creating hash digests of data.

</p>
<p>Returned by <code>crypto.createHash</code>.

</p>
<h3>hash.update(data)<span><a class="mark" href="#all_hash_update_data" id="all_hash_update_data">#</a></span></h3>
<p>Actualiza el contenido del hash con el <code>data</code> dado. the encoding of which is given
in <code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code>.
Defaults to <code>&apos;binary&apos;</code>.
Esto puede ser invocado muchas veces con dato nuevo mientras estos van llegando.

</p>
<h3>hash.digest([encoding])<span><a class="mark" href="#all_hash_digest_encoding" id="all_hash_digest_encoding">#</a></span></h3>
<p>Calcula el digest todos los datos que van al hash.
La codificación (<code>encoding</code>) puede ser <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> o <code>&apos;base64&apos;</code>.
Por omisíón es <code>&apos;binary&apos;</code>.

</p>
<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method been called.


</p>
<h3>crypto.createHmac(algorithm, key)<span><a class="mark" href="#all_crypto_createhmac_algorithm_key" id="all_crypto_createhmac_algorithm_key">#</a></span></h3>
<p>Crea y devuelve un objeto hmac, un hmac criptográfico con el algoritmo y la clave dadas.

</p>
<p><code>algorithm</code> depende de los algoritmos disponibles en la versión de OpenSSL en el sistema -  ver createHash arriba.
<code>key</code> es la clave hmac a usar.

</p>
<h2>Class: Hmac<span><a class="mark" href="#all_class_hmac" id="all_class_hmac">#</a></span></h2>
<p>Class for creating cryptographic hmac content.

</p>
<p>Returned by <code>crypto.createHmac</code>.

</p>
<h3>hmac.update(data)<span><a class="mark" href="#all_hmac_update_data" id="all_hmac_update_data">#</a></span></h3>
<p>Actualiza el contenido del hmac con el <code>data</code> dado.
Esto puede ser invocado muchas veces con dato nuevo mientras estos van llegando.

</p>
<h3>hmac.digest(encoding=&apos;binary&apos;)<span><a class="mark" href="#all_hmac_digest_encoding_binary" id="all_hmac_digest_encoding_binary">#</a></span></h3>
<p>Calcula el digest (resumen) de todos los datos que van al hmac.
La codificación (<code>encoding</code>) puede ser <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> o <code>&apos;base64&apos;</code>.
Por omisíón es <code>&apos;binary&apos;</code>.

</p>
<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method been called.


</p>
<h3>crypto.createCipher(algorithm, key)<span><a class="mark" href="#all_crypto_createcipher_algorithm_key" id="all_crypto_createcipher_algorithm_key">#</a></span></h3>
<p>Crea y devuelve un objeto cipher (codificador), con el algoritmo y la clave dadas.

</p>
<p><code>algorithm</code> es dependiente de OpenSSL, por ejemplo <code>&apos;aes192&apos;</code>, etc.
En versiones recientes, <code>openssl list-cipher-algorithms</code> mostrará 
los algoritmos cipher disponibles.
<code>password</code> is used to derive key and IV, which must be <code>&apos;binary&apos;</code> encoded
string (See the <a href="buffer.html">Buffer section</a> for more information).

</p>
<h2>crypto.createCipheriv(algorithm, key, iv)<span><a class="mark" href="#all_crypto_createcipheriv_algorithm_key_iv" id="all_crypto_createcipheriv_algorithm_key_iv">#</a></span></h2>
<p>Creates and returns a cipher object, with the given algorithm, key and iv.

</p>
<p><code>algorithm</code> is the same as the <code>createCipher()</code>. <code>key</code> is a raw key used in
algorithm. <code>iv</code> is an Initialization vector. <code>key</code> and <code>iv</code> must be <code>&apos;binary&apos;</code>
encoded string (See the <a href="buffer.html">Buffer section</a> for more information).

</p>
<h2>Class: Cipher<span><a class="mark" href="#all_class_cipher" id="all_class_cipher">#</a></span></h2>
<p>Class for encrypting data.

</p>
<p>Returned by <code>crypto.createCipher</code> and <code>crypto.createCipheriv</code>.

</p>
<h3>cipher.update(data, [input_encoding], [output_encoding])<span><a class="mark" href="#all_cipher_update_data_input_encoding_output_encoding" id="all_cipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Actualiza el cipher con <code>data</code>, la codificación viene dada en 
<code>input_encoding</code> y puede ser <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> o <code>&apos;binary&apos;</code>. 
Por omisión <code>&apos;binary&apos;</code>. 

</p>
<p>El <code>output_encoding</code> especifica el formato de la salida del dato codificado,
y puede ser <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> o <code>&apos;hex&apos;</code>. Por omisión <code>&apos;binary&apos;</code>.

</p>
<p>Devuelve el contenido codificado, y puede ser llamado muchas veces a medida que nuevos datos van llegando.

</p>
<h3>cipher.final([output_encoding])<span><a class="mark" href="#all_cipher_final_output_encoding" id="all_cipher_final_output_encoding">#</a></span></h3>
<p>Devuelve cualquier contenido codificado restante, donde <code>output_encoding</code> puede ser:
<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> o <code>&apos;hex&apos;</code>. Por omisión <code>&apos;binary&apos;</code>.

</p>
<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method been called.

</p>
<h3>cipher.setAutoPadding(auto_padding=true)<span><a class="mark" href="#all_cipher_setautopadding_auto_padding_true" id="all_cipher_setautopadding_auto_padding_true">#</a></span></h3>
<p>You can disable automatic padding of the input data to block size. If <code>auto_padding</code> is false,
the length of the entire input data must be a multiple of the cipher&apos;s block size or <code>final</code> will fail.
Useful for non-standard padding, e.g. using <code>0x0</code> instead of PKCS padding. You must call this before <code>cipher.final</code>.


</p>
<h3>crypto.createDecipher(algorithm, key)<span><a class="mark" href="#all_crypto_createdecipher_algorithm_key" id="all_crypto_createdecipher_algorithm_key">#</a></span></h3>
<p>Crea y devuelve un objeto decipher (decodificación), con el algoritmo y clave dado.
Este es el simétrico del objeto cipher (codificación) de arriba.

</p>
<h3>decipher.update(data, input_encoding=&apos;binary&apos;, output_encoding=&apos;binary&apos;)<span><a class="mark" href="#all_decipher_update_data_input_encoding_binary_output_encoding_binary" id="all_decipher_update_data_input_encoding_binary_output_encoding_binary">#</a></span></h3>
<p>Actualiza el objeto decodificador con <code>data</code>, que puede estar codificado en <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> o <code>&apos;hex&apos;</code>.
El <code>output_decoding</code> especifica en qué formato devolver el texto plano decodificdo: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> o <code>&apos;utf8&apos;</code>.

</p>
<h2>Class: Decipher<span><a class="mark" href="#all_class_decipher" id="all_class_decipher">#</a></span></h2>
<p>Class for decrypting data.

</p>
<p>Returned by <code>crypto.createDecipher</code> and <code>crypto.createDecipheriv</code>.

</p>
<h3>decipher.update(data, [input_encoding], [output_encoding])<span><a class="mark" href="#all_decipher_update_data_input_encoding_output_encoding" id="all_decipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Updates the decipher with <code>data</code>, which is encoded in <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code>
or <code>&apos;hex&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<p>The <code>output_decoding</code> specifies in what format to return the deciphered
plaintext: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>decipher.final([output_encoding])<span><a class="mark" href="#all_decipher_final_output_encoding" id="all_decipher_final_output_encoding">#</a></span></h3>
<p>Devuelve el texto plano decodificado restante, siendo
<code>output_encoding</code> <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> o <code>&apos;utf8&apos;</code>.
Por omisión <code>&apos;binary&apos;</code>.

</p>
<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method been called.

</p>
<h3>decipher.setAutoPadding(auto_padding=true)<span><a class="mark" href="#all_decipher_setautopadding_auto_padding_true" id="all_decipher_setautopadding_auto_padding_true">#</a></span></h3>
<p>You can disable auto padding if the data has been encrypted without standard block padding to prevent
<code>decipher.final</code> from checking and removing it. Can only work if the input data&apos;s length is a multiple of the
ciphers block size. You must call this before streaming data to <code>decipher.update</code>.

</p>
<h2>crypto.createSign(algorithm)<span><a class="mark" href="#all_crypto_createsign_algorithm" id="all_crypto_createsign_algorithm">#</a></span></h2>
<p>Crea y devuelve un objeto firma (signing) con el algoritmo dado.
En versiones recientes, <code>openssl list-public-key-algorithms</code> muestra
los algoritmos de firmado disponibles. Por ejemplo: `&apos;RSA-SHA256

</p>
<h2>Class: Signer<span><a class="mark" href="#all_class_signer" id="all_class_signer">#</a></span></h2>
<p>Class for generating signatures.

</p>
<p>Returned by <code>crypto.createSign</code>.

</p>
<h3>signer.update(data)<span><a class="mark" href="#all_signer_update_data" id="all_signer_update_data">#</a></span></h3>
<p>Actualiza el objeto firma con los datos dados.
Puede ser llamado muchas veces a medida que nuevos datos van llegando.

</p>
<h3>signer.sign(private_key, output_format=&apos;binary&apos;)<span><a class="mark" href="#all_signer_sign_private_key_output_format_binary" id="all_signer_sign_private_key_output_format_binary">#</a></span></h3>
<p>Calcula la firma en todos los datos actualizados pasados a través del objetvo firma.
<code>private_key</code> es una cadena que contiene la clave privada para firmar codificada en PEM.

</p>
<p>Devuelve la firma en <code>output_format</code> que puede estar en <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> o 
<code>&apos;base64&apos;</code>. Por omisión <code>&apos;binary&apos;</code>.

</p>
<p>Note: <code>signer</code> object can not be used after <code>sign()</code> method been called.

</p>
<h3>crypto.createVerify(algorithm)<span><a class="mark" href="#all_crypto_createverify_algorithm" id="all_crypto_createverify_algorithm">#</a></span></h3>
<p>Crea y devuelve un objeto verificación con el algoritmo dado.
Este es el simétrico del objeto firma de arriba.

</p>
<h2>Class: Verify<span><a class="mark" href="#all_class_verify" id="all_class_verify">#</a></span></h2>
<p>Class for verifying signatures.

</p>
<p>Returned by <code>crypto.createVerify</code>.

</p>
<h3>verifier.update(data)<span><a class="mark" href="#all_verifier_update_data" id="all_verifier_update_data">#</a></span></h3>
<p>Actualiza el objeto verificador con los datos dados.
Puede ser llamado muchas veces a medida que nuevos datos van llegando.

</p>
<h3>verifier.verify(cert, signature, signature_format=&apos;binary&apos;)<span><a class="mark" href="#all_verifier_verify_cert_signature_signature_format_binary" id="all_verifier_verify_cert_signature_signature_format_binary">#</a></span></h3>
<p>Verifica los datos firmados usando <code>cert</code>, que es una cadena que contiene la llave pública codificada en PEM; y <code>signature</code>, que es la firma del dato previamente calculada; <code>signature_format</code> puede ser <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> o <code>&apos;base64&apos;</code>.

</p>
<p>Devuelve true o false dependiendo en la validez de la firma para el dato y la clave pública dadas.

</p>
<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method been called.

</p>
<h2>crypto.createDiffieHellman(prime_length)<span><a class="mark" href="#all_crypto_creatediffiehellman_prime_length" id="all_crypto_creatediffiehellman_prime_length">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object and generates a prime of the
given bit length. The generator used is <code>2</code>.

</p>
<h2>crypto.createDiffieHellman(prime, [encoding])<span><a class="mark" href="#all_crypto_creatediffiehellman_prime_encoding" id="all_crypto_creatediffiehellman_prime_encoding">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object using the supplied prime. The
generator used is <code>2</code>. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>.
Defaults to <code>&apos;binary&apos;</code>.

</p>
<h2>Class: DiffieHellman<span><a class="mark" href="#all_class_diffiehellman" id="all_class_diffiehellman">#</a></span></h2>
<p>The class for creating Diffie-Hellman key exchanges.

</p>
<p>Returned by <code>crypto.createDiffieHellman</code>.

</p>
<h3>diffieHellman.generateKeys([encoding])<span><a class="mark" href="#all_diffiehellman_generatekeys_encoding" id="all_diffiehellman_generatekeys_encoding">#</a></span></h3>
<p>Generates private and public Diffie-Hellman key values, and returns the
public key in the specified encoding. This key should be transferred to the
other party. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>.
Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])<span><a class="mark" href="#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding" id="all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">#</a></span></h3>
<p>Computes the shared secret using <code>other_public_key</code> as the other party&apos;s
public key and returns the computed shared secret. Supplied key is
interpreted using specified <code>input_encoding</code>, and secret is encoded using
specified <code>output_encoding</code>. Encodings can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or
<code>&apos;base64&apos;</code>. The input encoding defaults to <code>&apos;binary&apos;</code>.
If no output encoding is given, the input encoding is used as output encoding.

</p>
<h3>diffieHellman.getPrime([encoding])<span><a class="mark" href="#all_diffiehellman_getprime_encoding" id="all_diffiehellman_getprime_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can be
<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.getGenerator([encoding])<span><a class="mark" href="#all_diffiehellman_getgenerator_encoding" id="all_diffiehellman_getgenerator_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can be
<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.getPublicKey([encoding])<span><a class="mark" href="#all_diffiehellman_getpublickey_encoding" id="all_diffiehellman_getpublickey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman public key in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.getPrivateKey([encoding])<span><a class="mark" href="#all_diffiehellman_getprivatekey_encoding" id="all_diffiehellman_getprivatekey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman private key in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.setPublicKey(public_key, [encoding])<span><a class="mark" href="#all_diffiehellman_setpublickey_public_key_encoding" id="all_diffiehellman_setpublickey_public_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman public key. Key encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,
or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.setPrivateKey(public_key, [encoding])<span><a class="mark" href="#all_diffiehellman_setprivatekey_public_key_encoding" id="all_diffiehellman_setprivatekey_public_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman private key. Key encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,
or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h2>crypto.getDiffieHellman(group_name)<span><a class="mark" href="#all_crypto_getdiffiehellman_group_name" id="all_crypto_getdiffiehellman_group_name">#</a></span></h2>
<p>Creates a predefined Diffie-Hellman key exchange object.
The supported groups are: <code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code>
(defined in <a href="http://www.rfc-editor.org/rfc/rfc2412.txt">RFC 2412</a>)
and <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>, <code>&apos;modp18&apos;</code>
(defined in <a href="http://www.rfc-editor.org/rfc/rfc3526.txt">RFC 3526</a>).
The returned object mimics the interface of objects created by
<a href="#crypto.createDiffieHellman">crypto.createDiffieHellman()</a> above, but
will not allow to change the keys (with
<a href="#diffieHellman.setPublicKey">diffieHellman.setPublicKey()</a> for example).
The advantage of using this routine is that the parties don&apos;t have to
generate nor exchange group modulus beforehand, saving both processor and
communication time.

</p>
<p>Example (obtaining a shared secret):

</p>
<pre><code>var crypto = require(&apos;crypto&apos;);
var alice = crypto.getDiffieHellman(&apos;modp5&apos;);
var bob = crypto.getDiffieHellman(&apos;modp5&apos;);

alice.generateKeys();
bob.generateKeys();

var alice_secret = alice.computeSecret(bob.getPublicKey(), &apos;binary&apos;, &apos;hex&apos;);
var bob_secret = bob.computeSecret(alice.getPublicKey(), &apos;binary&apos;, &apos;hex&apos;);

/* alice_secret and bob_secret should be the same */
console.log(alice_secret == bob_secret);</code></pre>
<h2>crypto.pbkdf2(password, salt, iterations, keylen, callback)<span><a class="mark" href="#all_crypto_pbkdf2_password_salt_iterations_keylen_callback" id="all_crypto_pbkdf2_password_salt_iterations_keylen_callback">#</a></span></h2>
<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive
a key of given length from the given password, salt and iterations.
The callback gets two arguments <code>(err, derivedKey)</code>.

</p>
<h2>crypto.randomBytes(size, [callback])<span><a class="mark" href="#all_crypto_randombytes_size_callback" id="all_crypto_randombytes_size_callback">#</a></span></h2>
<p>Generates cryptographically strong pseudo-random data. Usage:

</p>
<pre><code>// async
crypto.randomBytes(256, function(ex, buf) {
  if (ex) throw ex;
  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);
});

// sync
try {
  var buf = crypto.randomBytes(256);
  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);
} catch (ex) {
  // handle error
}</code></pre>
<h1>TLS (SSL)<span><a class="mark" href="#all_tls_ssl" id="all_tls_ssl">#</a></span></h1>
<p>Usa <code>require(&apos;tls&apos;)</code> para acceder a este módulo.

</p>
<p>El módulo <code>tls</code> utiliza OpenSSL para proveer seguridad en la Transport Layer Security y/o Secure Socket Layer: encriptacion de flujo de comunicaciones.

</p>
<p>TLS/SSL es una infraestructura de clave publica/privada. Cada cliente y cada servidor deben tener una clave privada. Una clave privada se crea como sigue:

</p>
<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>
<p>Todos los servidores y algunos clientes necesitan tener un certificado. Los certificados son claves públicas firmadas por una autoridad certificadora (CA) o por ellas mismas. El primer paso para obtener un certificado es crear un fichero de &quot;Petición de firma de Certificado&quot; (CSR). Esto se hace como sigue:

</p>
<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p>Para crear un certificado auto firmado con el CSR, hay que hacer:

</p>
<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p>De forma alternativa puedes enviar el CSR a la autoridad certificadora para firmarlo.

</p>
<p>(TODO: documentos sobre la creación de una CA, por ahora los usuarios interesados deberían echar un vistazo a <code>test/fixtures/keys/Makefile</code> en el código fuente de Node)

</p>
<h2>s = tls.connect(port, [host], [options], callback)<span><a class="mark" href="#all_s_tls_connect_port_host_options_callback" id="all_s_tls_connect_port_host_options_callback">#</a></span></h2>
<p>Crea una nueva conexión cliente al <code>port</code> y al <code>host</code> dados. (<code>host</code> por defecto es <code>localhost</code>.) <code>options</code> debe ser un objeto que especifique:

</p>
<ul>
<li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la llave privada del servidor en formato PEM. (Requerido)</p>
</li>
<li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene la clave del certificado del servidor en formato PEM.</p>
</li>
<li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs &quot;root&quot; bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p>
</li>
</ul>
<p><code>tls.connect()</code> devuelve un objeto <code>CryptoStream</code> en texto plano.

</p>
<p>Después del TSL/SSL handshake el <code>callback</code> es invocado. El <code>callback</code> será invocado independientemente si el certificado del servidor fue autorizado o no. Es responsabilidad del usuario probar <code>s.authorized</code> para ver si el certificado del servidor estaba firmado por una de las CAs especificadas. Si <code>s.authorized === false</code> entonces el error puede encontrarse en <code>s.authorizationError</code>.


</p>
<h2>STARTTLS<span><a class="mark" href="#all_starttls" id="all_starttls">#</a></span></h2>
<p>In the v0.4 branch no function exists for starting a TLS session on an
already existing TCP connection.  This is possible it just requires a bit of
work. The technique is to use <code>tls.createSecurePair()</code> which returns two
streams: an encrypted stream and a plaintext stream. The encrypted stream is then
piped to the socket, the plaintext stream is what the user interacts with thereafter.

</p>
<p><a href="http://gist.github.com/848444">Here is some code that does it.</a>




</p>
<h2>tls.Server<span><a class="mark" href="#all_tls_server" id="all_tls_server">#</a></span></h2>
<p>Esta clase es una subclase de <code>net.Server</code> y tiene los mismos métodos.
En lugar de aceptar solo conexiones TCP en bruto, acepta conexiones encriptadas usando TLS o SSL.

</p>
<p>Aquí hay un ejemplo simple de un servidor eco:

</p>
<pre><code>var tls = require(&apos;tls&apos;);
var fs = require(&apos;fs&apos;);

var options = {
  key: fs.readFileSync(&apos;server-key.pem&apos;),
  cert: fs.readFileSync(&apos;server-cert.pem&apos;)
};

tls.createServer(options, function (s) {
  s.write(&quot;welcome!\n&quot;);
  s.pipe(s);
}).listen(8000);</code></pre>
<p>Puedes probar este servidor conectándose a él con <code>openssl s_client</code>:

</p>
<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
<h3>tls.createServer(options, secureConnectionListener)<span><a class="mark" href="#all_tls_createserver_options_secureconnectionlistener" id="all_tls_createserver_options_secureconnectionlistener">#</a></span></h3>
<p>Este es un constructor para la clase <code>tls.Server</code>. El objeto options puede contener:

</p>
<ul>
<li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la clave privada del servidor en formato PEM. (Requerido)</p>
</li>
<li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene el certificado del servidor en formato PEM. (Requerido)</p>
</li>
<li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs &quot;root&quot; bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p>
</li>
<li><p><code>requestCert</code>: Si es <code>true</code> el servidor solicitará un certificado de todos los clientes que se conecten e intenten verificar ese certificado. Por defecto: <code>false</code></p>
</li>
<li><p><code>rejectUnauthorized</code>: Si es <code>true</code> el servidor rechazará cualquier conexión no autorizada por la lista de CAs suministradas. Esta opción solo tiene efecto si <code>requestCert</code> es <code>true</code>. Por defecto: <code>false</code>.</p>
</li>
</ul>
<h3>Event: &apos;secureConnection&apos;<span><a class="mark" href="#all_event_secureconnection" id="all_event_secureconnection">#</a></span></h3>
<p><code>function (cleartextStream) {}</code>

</p>
<p>Este evento es emitido después de que una nueva conexión haya realizado con éxito el handshake. El argumento es una instancia de <code>stream.Stream</code>. Tiene todos los métodos y eventos de stream.

</p>
<p><code>cleartextStream.authorized</code> es un valor boolean que indica si el cliente está verificado por una de las CA suministradas por el servidor. Si <code>cleartextStream.authorized</code> es false, entonces <code>cleartextStream.authorizationError</code> describe como falló la autorización. Relacionado pero merece mencionarse: dependiendo de la configuración del servidor TLS, tus autorizaciones de conexión pueden ser aceptadas.

</p>
<h3>server.listen(port, [host], [callback])<span><a class="mark" href="#all_server_listen_port_host_callback" id="all_server_listen_port_host_callback">#</a></span></h3>
<p>Empieza aceptando conexiones en el <code>port</code> y el <code>host</code> especificados. Si el <code>host</code> es omitido, el servidor aceptará conexiones dirigidas a cualquier dirección IPv4 (<code>INADDR_ANY</code>).

</p>
<p>Esta función es asíncrona. El último parámetro <code>callback</code> se invocará cuando el servidor esté saturado.

</p>
<p>Mirar <code>net.Server</code> para más información.

</p>
<h3>server.close()<span><a class="mark" href="#all_server_close" id="all_server_close">#</a></span></h3>
<p>Detiene el servidor, dejando de aceptar conexiones. Esta función es asíncrona, el servidor finalmente se cierra cuando emite un evento <code>&apos;close&apos;</code>.

</p>
<h3>server.maxConnections<span><a class="mark" href="#all_server_maxconnections" id="all_server_maxconnections">#</a></span></h3>
<p>Establece esta propiedad para rechazar conexiones cuando el número de conexiones del servidor sea alta.

</p>
<h3>server.connections<span><a class="mark" href="#all_server_connections" id="all_server_connections">#</a></span></h3>
<p>Número de conexiones concurrentes en el servidor.


</p>
<h1>File System<span><a class="mark" href="#all_file_system" id="all_file_system">#</a></span></h1>
<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code>require(&apos;fs&apos;)</code>. All the methods have asynchronous and
synchronous forms.

</p>
<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.

</p>
<p>Here is an example of the asynchronous version:

</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.unlink(&apos;/tmp/hello&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;successfully deleted /tmp/hello&apos;);
});</code></pre>
<p>Here is the synchronous version:

</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.unlinkSync(&apos;/tmp/hello&apos;)
console.log(&apos;successfully deleted /tmp/hello&apos;);</code></pre>
<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;renamed complete&apos;);
});
fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
  if (err) throw err;
  console.log(&apos;stats: &apos; + JSON.stringify(stats));
});</code></pre>
<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.
The correct way to do this is to chain the callbacks.

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
    if (err) throw err;
    console.log(&apos;stats: &apos; + JSON.stringify(stats));
  });
});</code></pre>
<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.

</p>
<h2>fs.rename(path1, path2, [callback])<span><a class="mark" href="#all_fs_rename_path1_path2_callback" id="all_fs_rename_path1_path2_callback">#</a></span></h2>
<p>Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<h2>fs.renameSync(path1, path2)<span><a class="mark" href="#all_fs_renamesync_path1_path2" id="all_fs_renamesync_path1_path2">#</a></span></h2>
<p>Synchronous rename(2).

</p>
<h2>fs.truncate(fd, len, [callback])<span><a class="mark" href="#all_fs_truncate_fd_len_callback" id="all_fs_truncate_fd_len_callback">#</a></span></h2>
<p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<h2>fs.truncateSync(fd, len)<span><a class="mark" href="#all_fs_truncatesync_fd_len" id="all_fs_truncatesync_fd_len">#</a></span></h2>
<p>Synchronous ftruncate(2).

</p>
<h2>fs.chmod(path, mode, [callback])<span><a class="mark" href="#all_fs_chmod_path_mode_callback" id="all_fs_chmod_path_mode_callback">#</a></span></h2>
<p>Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<h2>fs.chmodSync(path, mode)<span><a class="mark" href="#all_fs_chmodsync_path_mode" id="all_fs_chmodsync_path_mode">#</a></span></h2>
<p>Synchronous chmod(2).

</p>
<h2>fs.stat(path, [callback])<span><a class="mark" href="#all_fs_stat_path_callback" id="all_fs_stat_path_callback">#</a></span></h2>
<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. It looks like this:

</p>
<pre><code>{ dev: 2049,
  ino: 305352,
  mode: 16877,
  nlink: 12,
  uid: 1000,
  gid: 1000,
  rdev: 0,
  size: 4096,
  blksize: 4096,
  blocks: 8,
  atime: &apos;2009-06-29T11:11:55Z&apos;,
  mtime: &apos;2009-06-29T11:11:40Z&apos;,
  ctime: &apos;2009-06-29T11:11:40Z&apos; }</code></pre>
<p>See the <code>fs.Stats</code> section below for more information.

</p>
<h2>fs.lstat(path, [callback])<span><a class="mark" href="#all_fs_lstat_path_callback" id="all_fs_lstat_path_callback">#</a></span></h2>
<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. lstat() is identical to stat(), except that if
path is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.

</p>
<h2>fs.fstat(fd, [callback])<span><a class="mark" href="#all_fs_fstat_fd_callback" id="all_fs_fstat_fd_callback">#</a></span></h2>
<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object.

</p>
<h2>fs.statSync(path)<span><a class="mark" href="#all_fs_statsync_path" id="all_fs_statsync_path">#</a></span></h2>
<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<h2>fs.lstatSync(path)<span><a class="mark" href="#all_fs_lstatsync_path" id="all_fs_lstatsync_path">#</a></span></h2>
<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<h2>fs.fstatSync(fd)<span><a class="mark" href="#all_fs_fstatsync_fd" id="all_fs_fstatsync_fd">#</a></span></h2>
<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<h2>fs.link(srcpath, dstpath, [callback])<span><a class="mark" href="#all_fs_link_srcpath_dstpath_callback" id="all_fs_link_srcpath_dstpath_callback">#</a></span></h2>
<p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.

</p>
<h2>fs.linkSync(srcpath, dstpath)<span><a class="mark" href="#all_fs_linksync_srcpath_dstpath" id="all_fs_linksync_srcpath_dstpath">#</a></span></h2>
<p>Synchronous link(2).

</p>
<h2>fs.symlink(linkdata, path, [callback])<span><a class="mark" href="#all_fs_symlink_linkdata_path_callback" id="all_fs_symlink_linkdata_path_callback">#</a></span></h2>
<p>Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<h2>fs.symlinkSync(linkdata, path)<span><a class="mark" href="#all_fs_symlinksync_linkdata_path" id="all_fs_symlinksync_linkdata_path">#</a></span></h2>
<p>Synchronous symlink(2).

</p>
<h2>fs.readlink(path, [callback])<span><a class="mark" href="#all_fs_readlink_path_callback" id="all_fs_readlink_path_callback">#</a></span></h2>
<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,
resolvedPath)</code>.

</p>
<h2>fs.readlinkSync(path)<span><a class="mark" href="#all_fs_readlinksync_path" id="all_fs_readlinksync_path">#</a></span></h2>
<p>Synchronous readlink(2). Returns the resolved path.

</p>
<h2>fs.realpath(path, [callback])<span><a class="mark" href="#all_fs_realpath_path_callback" id="all_fs_realpath_path_callback">#</a></span></h2>
<p>Asynchronous realpath(2).  The callback gets two arguments <code>(err,
resolvedPath)</code>.

</p>
<h2>fs.realpathSync(path)<span><a class="mark" href="#all_fs_realpathsync_path" id="all_fs_realpathsync_path">#</a></span></h2>
<p>Synchronous realpath(2). Returns the resolved path.

</p>
<h2>fs.unlink(path, [callback])<span><a class="mark" href="#all_fs_unlink_path_callback" id="all_fs_unlink_path_callback">#</a></span></h2>
<p>Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<h2>fs.unlinkSync(path)<span><a class="mark" href="#all_fs_unlinksync_path" id="all_fs_unlinksync_path">#</a></span></h2>
<p>Synchronous unlink(2).

</p>
<h2>fs.rmdir(path, [callback])<span><a class="mark" href="#all_fs_rmdir_path_callback" id="all_fs_rmdir_path_callback">#</a></span></h2>
<p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<h2>fs.rmdirSync(path)<span><a class="mark" href="#all_fs_rmdirsync_path" id="all_fs_rmdirsync_path">#</a></span></h2>
<p>Synchronous rmdir(2).

</p>
<h2>fs.mkdir(path, mode, [callback])<span><a class="mark" href="#all_fs_mkdir_path_mode_callback" id="all_fs_mkdir_path_mode_callback">#</a></span></h2>
<p>Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<h2>fs.mkdirSync(path, mode)<span><a class="mark" href="#all_fs_mkdirsync_path_mode" id="all_fs_mkdirsync_path_mode">#</a></span></h2>
<p>Synchronous mkdir(2).

</p>
<h2>fs.readdir(path, [callback])<span><a class="mark" href="#all_fs_readdir_path_callback" id="all_fs_readdir_path_callback">#</a></span></h2>
<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>&apos;.&apos;</code> and <code>&apos;..&apos;</code>.

</p>
<h2>fs.readdirSync(path)<span><a class="mark" href="#all_fs_readdirsync_path" id="all_fs_readdirsync_path">#</a></span></h2>
<p>Synchronous readdir(3). Returns an array of filenames excluding <code>&apos;.&apos;</code> and
<code>&apos;..&apos;</code>.

</p>
<h2>fs.close(fd, [callback])<span><a class="mark" href="#all_fs_close_fd_callback" id="all_fs_close_fd_callback">#</a></span></h2>
<p>Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.

</p>
<h2>fs.closeSync(fd)<span><a class="mark" href="#all_fs_closesync_fd" id="all_fs_closesync_fd">#</a></span></h2>
<p>Synchronous close(2).

</p>
<h2>fs.open(path, flags, [mode], [callback])<span><a class="mark" href="#all_fs_open_path_flags_mode_callback" id="all_fs_open_path_flags_mode_callback">#</a></span></h2>
<p>Asynchronous file open. See open(2). Flags can be &apos;r&apos;, &apos;r+&apos;, &apos;w&apos;, &apos;w+&apos;, &apos;a&apos;,
or &apos;a+&apos;. <code>mode</code> defaults to 0666. The callback gets two arguments <code>(err, fd)</code>.

</p>
<h2>fs.openSync(path, flags, [mode])<span><a class="mark" href="#all_fs_opensync_path_flags_mode" id="all_fs_opensync_path_flags_mode">#</a></span></h2>
<p>Synchronous open(2).

</p>
<h2>fs.write(fd, buffer, offset, length, position, [callback])<span><a class="mark" href="#all_fs_write_fd_buffer_offset_length_position_callback" id="all_fs_write_fd_buffer_offset_length_position_callback">#</a></span></h2>
<p>Write <code>buffer</code> to the file specified by <code>fd</code>.

</p>
<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.

</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>position</code> is <code>null</code>, the data will be written at the
current position.
See pwrite(2).

</p>
<p>The callback will be given two arguments <code>(err, written)</code> where <code>written</code>
specifies how many <em>bytes</em> were written.

</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.

</p>
<h2>fs.writeSync(fd, buffer, offset, length, position)<span><a class="mark" href="#all_fs_writesync_fd_buffer_offset_length_position" id="all_fs_writesync_fd_buffer_offset_length_position">#</a></span></h2>
<p>Synchronous version of buffer-based <code>fs.write()</code>. Returns the number of bytes
written.

</p>
<h2>fs.writeSync(fd, str, position, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_fs_writesync_fd_str_position_encoding_utf8" id="all_fs_writesync_fd_str_position_encoding_utf8">#</a></span></h2>
<p>Synchronous version of string-based <code>fs.write()</code>. Returns the number of bytes
written.

</p>
<h2>fs.read(fd, buffer, offset, length, position, [callback])<span><a class="mark" href="#all_fs_read_fd_buffer_offset_length_position_callback" id="all_fs_read_fd_buffer_offset_length_position_callback">#</a></span></h2>
<p>Read data from the file specified by <code>fd</code>.

</p>
<p><code>buffer</code> is the buffer that the data will be written to.

</p>
<p><code>offset</code> is offset within the buffer where writing will start.

</p>
<p><code>length</code> is an integer specifying the number of bytes to read.

</p>
<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.

</p>
<p>The callback is given the two arguments, <code>(err, bytesRead)</code>.

</p>
<h2>fs.readSync(fd, buffer, offset, length, position)<span><a class="mark" href="#all_fs_readsync_fd_buffer_offset_length_position" id="all_fs_readsync_fd_buffer_offset_length_position">#</a></span></h2>
<p>Synchronous version of buffer-based <code>fs.read</code>. Returns the number of
<code>bytesRead</code>.

</p>
<h2>fs.readSync(fd, length, position, encoding)<span><a class="mark" href="#all_fs_readsync_fd_length_position_encoding" id="all_fs_readsync_fd_length_position_encoding">#</a></span></h2>
<p>Synchronous version of string-based <code>fs.read</code>. Returns the number of
<code>bytesRead</code>.

</p>
<h2>fs.readFile(filename, [encoding], [callback])<span><a class="mark" href="#all_fs_readfile_filename_encoding_callback" id="all_fs_readfile_filename_encoding_callback">#</a></span></h2>
<p>Asynchronously reads the entire contents of a file. Example:

</p>
<pre><code>fs.readFile(&apos;/etc/passwd&apos;, function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.

</p>
<p>If no encoding is specified, then the raw buffer is returned.


</p>
<h2>fs.readFileSync(filename, [encoding])<span><a class="mark" href="#all_fs_readfilesync_filename_encoding" id="all_fs_readfilesync_filename_encoding">#</a></span></h2>
<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.

</p>
<p>If <code>encoding</code> is specified then this function returns a string. Otherwise it
returns a buffer.


</p>
<h2>fs.writeFile(filename, data, encoding=&apos;utf8&apos;, [callback])<span><a class="mark" href="#all_fs_writefile_filename_data_encoding_utf8_callback" id="all_fs_writefile_filename_data_encoding_utf8_callback">#</a></span></h2>
<p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer.

</p>
<p>Example:

</p>
<pre><code>fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;It\&apos;s saved!&apos;);
});</code></pre>
<h2>fs.writeFileSync(filename, data, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_fs_writefilesync_filename_data_encoding_utf8" id="all_fs_writefilesync_filename_data_encoding_utf8">#</a></span></h2>
<p>The synchronous version of <code>fs.writeFile</code>.

</p>
<h2>fs.watchFile(filename, [options], listener)<span><a class="mark" href="#all_fs_watchfile_filename_options_listener" id="all_fs_watchfile_filename_options_listener">#</a></span></h2>
<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each
time the file is accessed.

</p>
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing two members a boolean, <code>persistent</code>, and <code>interval</code>, a polling
value in milliseconds. The default is <code>{ persistent: true, interval: 0 }</code>.

</p>
<p>The <code>listener</code> gets two arguments the current stat object and the previous
stat object:

</p>
<pre><code>fs.watchFile(f, function (curr, prev) {
  console.log(&apos;the current mtime is: &apos; + curr.mtime);
  console.log(&apos;the previous mtime was: &apos; + prev.mtime);
});</code></pre>
<p>These stat objects are instances of <code>fs.Stat</code>.

</p>
<p>If you want to be notified when the file was modified, not just accessed
you need to compare <code>curr.mtime</code> and `prev.mtime.


</p>
<h2>fs.unwatchFile(filename)<span><a class="mark" href="#all_fs_unwatchfile_filename" id="all_fs_unwatchfile_filename">#</a></span></h2>
<p>Stop watching for changes on <code>filename</code>.

</p>
<h2>fs.Stats<span><a class="mark" href="#all_fs_stats" id="all_fs_stats">#</a></span></h2>
<p>Objects returned from <code>fs.stat()</code> and <code>fs.lstat()</code> are of this type.

</p>
<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<h2>fs.ReadStream<span><a class="mark" href="#all_fs_readstream" id="all_fs_readstream">#</a></span></h2>
<p><code>ReadStream</code> is a <code>Readable Stream</code>.

</p>
<h2>fs.createReadStream(path, [options])<span><a class="mark" href="#all_fs_createreadstream_path_options" id="all_fs_createreadstream_path_options">#</a></span></h2>
<p>Returns a new ReadStream object (See <code>Readable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<pre><code>{ flags: &apos;r&apos;,
  encoding: null,
  fd: null,
  mode: 0666,
  bufferSize: 64 * 1024
}</code></pre>
<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and
start at 0.  When used, both the limits must be specified always.

</p>
<p>An example to read the last 10 bytes of a file which is 100 bytes long:

</p>
<pre><code>fs.createReadStream(&apos;sample.txt&apos;, {start: 90, end: 99});</code></pre>
<h2>fs.WriteStream<span><a class="mark" href="#all_fs_writestream" id="all_fs_writestream">#</a></span></h2>
<p><code>WriteStream</code> is a <code>Writable Stream</code>.

</p>
<h2>Event: &apos;open&apos;<span><a class="mark" href="#all_event_open" id="all_event_open">#</a></span></h2>
<p><code>function (fd) { }</code>

</p>
<p> <code>fd</code> is the file descriptor used by the WriteStream.

</p>
<h2>fs.createWriteStream(path, [options])<span><a class="mark" href="#all_fs_createwritestream_path_options" id="all_fs_createwritestream_path_options">#</a></span></h2>
<p>Returns a new WriteStream object (See <code>Writable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<pre><code>{ flags: &apos;w&apos;,
  encoding: null,
  mode: 0666 }</code></pre>
<h1>Path<span><a class="mark" href="#all_path" id="all_path">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>Este módulo contiene utilidades para trabajar con rutas de fichero.
Casi todos los métodos llevan sólo una transformaciones en el string.
El sistema de archivos no es consulta para comprobar si las rutas son válidos.

</p>
<p>Utilice <code>require(&apos;path&apos;)</code> para utilizarlo.  Los siguientes métodos son provistos:

</p>
<h2>path.normalize(p)<span><a class="mark" href="#all_path_normalize_p" id="all_path_normalize_p">#</a></span></h2>
<p>Normaliza la cadena de texto de una ruta, se encarga de las partes <code>&apos;..&apos;</code> y <code>&apos;.&apos;</code>.

</p>
<p>Cuando se encuentra múltiples barras, se reemplazan por una sola;
cuando la ruta acaba en barra, se conserva.
En windows se utilizan contrabarras.

</p>
<p>Example:

</p>
<pre><code>path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.join([path1], [path2], [...])<span><a class="mark" href="#all_path_join_path1_path2" id="all_path_join_path1_path2">#</a></span></h2>
<p>Junta todos los argumentos y normaliza la ruta resultante.
Non-string arguments are ignored.

</p>
<p>Example:

</p>
<pre><code>path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;

path.join(&apos;foo&apos;, {}, &apos;bar&apos;)
// returns
&apos;foo/bar&apos;</code></pre>
<h2>path.resolve([from ...], to)<span><a class="mark" href="#all_path_resolve_from_to" id="all_path_resolve_from_to">#</a></span></h2>
<p>Resuelve <code>to</code> a una ruta absoluta.

</p>
<p>If <code>to</code> isn&apos;t already absolute <code>from</code> arguments are prepended in right to left
order, until an absolute path is found. If after using all <code>from</code> paths still
no absolute path is found, the current working directory is used as well. The
resulting path is normalized, and trailing slashes are removed unless the path 
gets resolved to the root directory. Non-string arguments are ignored.

</p>
<p>Si <code>to</code> no es absoluta los argumentos <code>from</code> se anteponen ordenados de derecha a 
izquierda, hasta que se encuentra una ruta absoluta. Si después de usar todas las rutas de <code>from</code> 
aún no se encuentra una ruta absoluta, también se utiliza el directorio actual de trabajo. La 
ruta resultante se normaliza, y se eliminan las barras finales a no ser que 
se resuelva el directorio root.

</p>
<p>Otra manera de verlo es como una secuencia de comandos <code>cd</code> en un shell.

</p>
<pre><code>path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</code></pre>
<p>Es como:

</p>
<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>
<p>La diferencia es que las distintas rutas no necesitan existir e incluso pueden 
ser ficheros.

</p>
<p>Ejemplos:

</p>
<pre><code>path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)
// returns
&apos;/foo/bar/baz&apos;

path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)
// returns
&apos;/tmp/file&apos;

path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)
// if currently in /home/myself/node, it returns
&apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos;</code></pre>
<h2>path.relative(from, to)<span><a class="mark" href="#all_path_relative_from_to" id="all_path_relative_from_to">#</a></span></h2>
<p>Solve the relative path from <code>from</code> to <code>to</code>.

</p>
<p>At times we have two absolute paths, and we need to derive the relative
path from one to the other.  This is actually the reverse transform of
<code>path.resolve</code>, which means we see that:

</p>
<pre><code>path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>
<p>Ejemplos:

</p>
<pre><code>path.relative(&apos;C:\\orandea\\test\\aaa&apos;, &apos;C:\\orandea\\impl\\bbb&apos;)
// returns
&apos;..\\..\\impl\\bbb&apos;

path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;)
// returns
&apos;../../impl/bbb&apos;</code></pre>
<h2>path.dirname(p)<span><a class="mark" href="#all_path_dirname_p" id="all_path_dirname_p">#</a></span></h2>
<p>Devuelve el nombre de directorio de una ruta.  Semejante al comando de Unix <code>dirname</code>.

</p>
<p>Ejemplo:

</p>
<pre><code>path.dirname(&apos;/foo/bar/baz/asdf/quux&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.basename(p, [ext])<span><a class="mark" href="#all_path_basename_p_ext" id="all_path_basename_p_ext">#</a></span></h2>
<p>Devuelve la última parte de una ruta.  Semejante al comando de Unix <code>basename</code>.

</p>
<p>Ejemplo:

</p>
<pre><code>path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;)
// returns
&apos;quux.html&apos;

path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;, &apos;.html&apos;)
// returns
&apos;quux&apos;</code></pre>
<h2>path.extname(p)<span><a class="mark" href="#all_path_extname_p" id="all_path_extname_p">#</a></span></h2>
<p>Devuelve la extensión de la ruta.  Todo lo que hay después del último &apos;.&apos; 
en la última parte de la ruta. Si no hay &apos;.&apos; en la última parte de la ruta o el único 
&apos;.&apos; es el primer carácter, entonces devuelve un string vacío.  Ejemplos:

</p>
<pre><code>path.extname(&apos;index.html&apos;)
// returns
&apos;.html&apos;

path.extname(&apos;index.&apos;)
// returns
&apos;.&apos;

path.extname(&apos;index&apos;)
// returns
&apos;&apos;</code></pre>
<h1>net<span><a class="mark" href="#all_net" id="all_net">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include
this module with <code>require(&apos;net&apos;);</code>

</p>
<h2>net.createServer([options], [connectionListener])<span><a class="mark" href="#all_net_createserver_options_connectionlistener" id="all_net_createserver_options_connectionlistener">#</a></span></h2>
<p>Creates a new TCP server. The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="#event_connection_">&apos;connection&apos;</a>
event.

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<pre><code>{ allowHalfOpen: false
}</code></pre>
<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won&apos;t automatically send a FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the <code>end()</code> method explicitly.
See <a href="#event_end_">&apos;end&apos;</a> event for more information.

</p>
<p>Here is an example of a echo server which listens for connections
on port 8124:

</p>
<pre><code>var net = require(&apos;net&apos;);
var server = net.createServer(function(c) { //&apos;connection&apos; listener
  console.log(&apos;server connected&apos;);
  c.on(&apos;end&apos;, function() {
    console.log(&apos;server disconnected&apos;);
  });
  c.write(&apos;hello\r\n&apos;);
  c.pipe(c);
});
server.listen(8124, function() { //&apos;listening&apos; listener
  console.log(&apos;server bound&apos;);
});</code></pre>
<p>Test this by using <code>telnet</code>:

</p>
<pre><code>telnet localhost 8124</code></pre>
<p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would
just be changed to

</p>
<pre><code>server.listen(&apos;/tmp/echo.sock&apos;, function() { //&apos;listening&apos; listener</code></pre>
<p>Use <code>nc</code> to connect to a UNIX domain socket server:

</p>
<pre><code>nc -U /tmp/echo.sock</code></pre>
<h2>net.connect(options, [connectionListener])<span><a class="mark" href="#all_net_connect_options_connectionlistener" id="all_net_connect_options_connectionlistener">#</a></span></h2>
<h2>net.createConnection(options, [connectionListener])<span><a class="mark" href="#all_net_createconnection_options_connectionlistener" id="all_net_createconnection_options_connectionlistener">#</a></span></h2>
<p>Constructs a new socket object and opens the socket to the given location.
When the socket is established, the <a href="#event_connect_">&apos;connect&apos;</a> event will be
emitted.

</p>
<p>For TCP sockets, <code>options</code> argument should be an object which specifies:

</p>
<ul>
<li><p><code>port</code>: Port the client should connect to (Required).</p>
</li>
<li><p><code>host</code>: Host the client should connect to. Defaults to <code>&apos;localhost&apos;</code>.</p>
</li>
</ul>
<p>For UNIX domain sockets, <code>options</code> argument should be an object which specifies:

</p>
<ul>
<li><code>path</code>: Path the client should connect to (Required).</li>
</ul>
<p>Common options are:

</p>
<ul>
<li><code>allowHalfOpen</code>: if <code>true</code>, the socket won&apos;t automatically send
a FIN packet when the other end of the socket sends a FIN packet.
Defaults to <code>false</code>.
See <a href="#event_end_">&apos;end&apos;</a> event for more information.</li>
</ul>
<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="#event_connect_">&apos;connect&apos;</a> event.

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<pre><code>var net = require(&apos;net&apos;);
var client = net.connect({port: 8124},
    function() { //&apos;connect&apos; listener
  console.log(&apos;client connected&apos;);
  client.write(&apos;world!\r\n&apos;);
});
client.on(&apos;data&apos;, function(data) {
  console.log(data.toString());
  client.end();
});
client.on(&apos;end&apos;, function() {
  console.log(&apos;client disconnected&apos;);
});</code></pre>
<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be
changed to

</p>
<pre><code>var client = net.connect({path: &apos;/tmp/echo.sock&apos;},</code></pre>
<h2>net.connect(port, [host], [connectListener])<span><a class="mark" href="#all_net_connect_port_host_connectlistener" id="all_net_connect_port_host_connectlistener">#</a></span></h2>
<h2>net.createConnection(port, [host], [connectListener])<span><a class="mark" href="#all_net_createconnection_port_host_connectlistener" id="all_net_createconnection_port_host_connectlistener">#</a></span></h2>
<p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted,
<code>&apos;localhost&apos;</code> will be assumed.
The <code>connectListener</code> parameter will be added as an listener for the
<a href="#event_connect_">&apos;connect&apos;</a> event.

</p>
<h2>net.connect(path, [connectListener])<span><a class="mark" href="#all_net_connect_path_connectlistener" id="all_net_connect_path_connectlistener">#</a></span></h2>
<h2>net.createConnection(path, [connectListener])<span><a class="mark" href="#all_net_createconnection_path_connectlistener" id="all_net_createconnection_path_connectlistener">#</a></span></h2>
<p>Creates unix socket connection to <code>path</code>.
The <code>connectListener</code> parameter will be added as an listener for the
<a href="#event_connect_">&apos;connect&apos;</a> event.

</p>
<h2>Class: net.Server<span><a class="mark" href="#all_class_net_server" id="all_class_net_server">#</a></span></h2>
<p>This class is used to create a TCP or UNIX server.
A server is a <code>net.Socket</code> that can listen for new incoming connections.

</p>
<h3>server.listen(port, [host], [listeningListener])<span><a class="mark" href="#all_server_listen_port_host_listeninglistener" id="all_server_listen_port_host_listeninglistener">#</a></span></h3>
<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>). A port value of zero will assign a random port.

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="#event_listening_">&apos;listening&apos;</a> event will be emitted.
the last parameter <code>listeningListener</code> will be added as an listener for the
<a href="#event_listening_">&apos;listening&apos;</a> event.

</p>
<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. This means that
another server is already running on the requested port. One way of handling this
would be to wait a second and then try again. This can be done with

</p>
<pre><code>server.on(&apos;error&apos;, function (e) {
  if (e.code == &apos;EADDRINUSE&apos;) {
    console.log(&apos;Address in use, retrying...&apos;);
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>
<p>(Note: All sockets in Node set <code>SO_REUSEADDR</code> already)


</p>
<h3>server.listen(path, [listeningListener])<span><a class="mark" href="#all_server_listen_path_listeninglistener" id="all_server_listen_path_listeninglistener">#</a></span></h3>
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="#event_listening_">&apos;listening&apos;</a> event will be emitted.
the last parameter <code>listeningListener</code> will be added as an listener for the
<a href="#event_listening_">&apos;listening&apos;</a> event.

</p>
<h3>server.close([cb])<span><a class="mark" href="#all_server_close_cb" id="all_server_close_cb">#</a></span></h3>
<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>&apos;close&apos;</code>
event. Optionally, you can pass a callback to listen for the <code>&apos;close&apos;</code> event.


</p>
<h3>server.address()<span><a class="mark" href="#all_server_address" id="all_server_address">#</a></span></h3>
<p>Returns the bound address and port of the server as reported by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address.
Returns an object with two properties, e.g. <code>{&quot;address&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:2121}</code>

</p>
<p>Example:

</p>
<pre><code>var server = net.createServer(function (socket) {
  socket.end(&quot;goodbye\n&quot;);
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log(&quot;opened server on %j&quot;, address);
});</code></pre>
<p>Don&apos;t call <code>server.address()</code> until the <code>&apos;listening&apos;</code> event has been emitted.

</p>
<h3>server.maxConnections<span><a class="mark" href="#all_server_maxconnections_1" id="all_server_maxconnections_1">#</a></span></h3>
<p>Set this property to reject connections when the server&apos;s connection count gets
high.

</p>
<h3>server.connections<span><a class="mark" href="#all_server_connections_1" id="all_server_connections_1">#</a></span></h3>
<p>The number of concurrent connections on the server.


</p>
<p><code>net.Server</code> is an <code>EventEmitter</code> with the following events:

</p>
<h3>Event: &apos;listening&apos;<span><a class="mark" href="#all_event_listening" id="all_event_listening">#</a></span></h3>
<p>Emitted when the server has been bound after calling <code>server.listen</code>.

</p>
<h3>Event: &apos;connection&apos;<span><a class="mark" href="#all_event_connection" id="all_event_connection">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Socket object</span> The connection object</li>
</div></ul>
<p>Emitted when a new connection is made. <code>socket</code> is an instance of
<code>net.Socket</code>.

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_2" id="all_event_close_2">#</a></span></h3>
<p>Emitted when the server closes.

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_2" id="all_event_error_2">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Error Object</span></li>
</div></ul>
<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly
following this event.  See example in discussion of <code>server.listen</code>.

</p>
<h2>Class: net.Socket<span><a class="mark" href="#all_class_net_socket" id="all_class_net_socket">#</a></span></h2>
<p>This object is an abstraction of a TCP or UNIX socket.  <code>net.Socket</code>
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Node
and passed to the user through the <code>&apos;connection&apos;</code> event of a server.

</p>
<h3>new net.Socket([options])<span><a class="mark" href="#all_new_net_socket_options" id="all_new_net_socket_options">#</a></span></h3>
<p>Construct a new socket object.

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<pre><code>{ fd: null
  type: null
  allowHalfOpen: false
}</code></pre>
<p><code>fd</code> allows you to specify the existing file descriptor of socket. <code>type</code>
specified underlying protocol. It can be <code>&apos;tcp4&apos;</code>, <code>&apos;tcp6&apos;</code>, or <code>&apos;unix&apos;</code>.
About <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>&apos;end&apos;</code> event.

</p>
<h3>socket.connect(port, [host], [connectListener])<span><a class="mark" href="#all_socket_connect_port_host_connectlistener" id="all_socket_connect_port_host_connectlistener">#</a></span></h3>
<h3>socket.connect(path, [connectListener])<span><a class="mark" href="#all_socket_connect_path_connectlistener" id="all_socket_connect_path_connectlistener">#</a></span></h3>
<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,
then the socket will be opened as a TCP socket, if <code>host</code> is omitted,
<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be
opened as a unix socket to that path.

</p>
<p>Normally this method is not needed, as <code>net.createConnection</code> opens the
socket. Use this only if you are implementing a custom Socket or if a
Socket is closed and you want to reuse it to connect to another server.

</p>
<p>This function is asynchronous. When the <a href="#event_connect_">&apos;connect&apos;</a> event is
emitted the socket is established. If there is a problem connecting, the
<code>&apos;connect&apos;</code> event will not be emitted, the <code>&apos;error&apos;</code> event will be emitted with
the exception.

</p>
<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="#event_connect_">&apos;connect&apos;</a> event.


</p>
<h3>socket.bufferSize<span><a class="mark" href="#all_socket_buffersize" id="all_socket_buffersize">#</a></span></h3>
<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to
help users get up and running quickly. The computer cannot always keep up
with the amount of data that is written to a socket - the network connection
simply might be too slow. Node will internally queue up the data written to a
socket and send it out over the wire when it is possible. (Internally it is
polling on the socket&apos;s file descriptor for being writable).

</p>
<p>The consequence of this internal buffering is that memory may grow. This
property shows the number of characters currently buffered to be written.
(Number of characters is approximately equal to the number of bytes to be
written, but the buffer may contain strings, and the strings are lazily
encoded, so the exact number of bytes is not known.)

</p>
<p>Users who experience large or growing <code>bufferSize</code> should attempt to
&quot;throttle&quot; the data flows in their program with <code>pause()</code> and <code>resume()</code>.


</p>
<h3>socket.setEncoding([encoding])<span><a class="mark" href="#all_socket_setencoding_encoding" id="all_socket_setencoding_encoding">#</a></span></h3>
<p>Sets the encoding (either <code>&apos;ascii&apos;</code>, <code>&apos;utf8&apos;</code>, or <code>&apos;base64&apos;</code>) for data that is
received. Defaults to <code>null</code>.

</p>
<h3>socket.write(data, [encoding], [callback])<span><a class="mark" href="#all_socket_write_data_encoding_callback" id="all_socket_write_data_encoding_callback">#</a></span></h3>
<p>Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.

</p>
<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<p>The optional <code>callback</code> parameter will be executed when the data is finally
written out - this may not be immediately.

</p>
<h3>socket.end([data], [encoding])<span><a class="mark" href="#all_socket_end_data_encoding" id="all_socket_end_data_encoding">#</a></span></h3>
<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the
server will still send some data.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<code>socket.write(data, encoding)</code> followed by <code>socket.end()</code>.

</p>
<h3>socket.destroy()<span><a class="mark" href="#all_socket_destroy" id="all_socket_destroy">#</a></span></h3>
<p>Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).

</p>
<h3>socket.pause()<span><a class="mark" href="#all_socket_pause" id="all_socket_pause">#</a></span></h3>
<p>Pauses the reading of data. That is, <code>&apos;data&apos;</code> events will not be emitted.
Useful to throttle back an upload.

</p>
<h3>socket.resume()<span><a class="mark" href="#all_socket_resume" id="all_socket_resume">#</a></span></h3>
<p>Resumes reading after a call to <code>pause()</code>.

</p>
<h3>socket.setTimeout(timeout, [callback])<span><a class="mark" href="#all_socket_settimeout_timeout_callback" id="all_socket_settimeout_timeout_callback">#</a></span></h3>
<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on
the socket. By default <code>net.Socket</code> do not have a timeout.

</p>
<p>When an idle timeout is triggered the socket will receive a <code>&apos;timeout&apos;</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the socket.

</p>
<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.

</p>
<p>The optional <code>callback</code> parameter will be added as a one time listener for the
<code>&apos;timeout&apos;</code> event.

</p>
<h3>socket.setNoDelay([noDelay])<span><a class="mark" href="#all_socket_setnodelay_nodelay" id="all_socket_setnodelay_nodelay">#</a></span></h3>
<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>true</code> for
<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.
<code>noDelay</code> defaults to <code>true</code>.

</p>
<h3>socket.setKeepAlive([enable], [initialDelay])<span><a class="mark" href="#all_socket_setkeepalive_enable_initialdelay" id="all_socket_setkeepalive_enable_initialdelay">#</a></span></h3>
<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
<code>enable</code> defaults to <code>false</code>.

</p>
<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting. Defaults to <code>0</code>.

</p>
<h3>socket.address()<span><a class="mark" href="#all_socket_address" id="all_socket_address">#</a></span></h3>
<p>Returns the bound address and port of the socket as reported by the operating
system. Returns an object with two properties, e.g.
<code>{&quot;address&quot;:&quot;192.168.57.1&quot;, &quot;port&quot;:62053}</code>

</p>
<h3>socket.remoteAddress<span><a class="mark" href="#all_socket_remoteaddress" id="all_socket_remoteaddress">#</a></span></h3>
<p>The string representation of the remote IP address. For example,
<code>&apos;74.125.127.100&apos;</code> or <code>&apos;2001:4860:a005::68&apos;</code>.

</p>
<h3>socket.remotePort<span><a class="mark" href="#all_socket_remoteport" id="all_socket_remoteport">#</a></span></h3>
<p>The numeric representation of the remote port. For example,
<code>80</code> or <code>21</code>.

</p>
<h3>socket.bytesRead<span><a class="mark" href="#all_socket_bytesread" id="all_socket_bytesread">#</a></span></h3>
<p>The amount of received bytes.

</p>
<h3>socket.bytesWritten<span><a class="mark" href="#all_socket_byteswritten" id="all_socket_byteswritten">#</a></span></h3>
<p>The amount of bytes sent.


</p>
<p><code>net.Socket</code> instances are EventEmitters with the following events:

</p>
<h3>Event: &apos;connect&apos;<span><a class="mark" href="#all_event_connect" id="all_event_connect">#</a></span></h3>
<p>Emitted when a socket connection is successfully established.
See <code>connect()</code>.

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_1" id="all_event_data_1">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Buffer object</span></li>
</div></ul>
<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or
<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.
(See the <a href="stream.html#readable_stream">Readable Stream</a> section for more
information.)

</p>
<p>Note that the <strong>data will be lost</strong> if there is no listener when a <code>Socket</code>
emits a <code>&apos;data&apos;</code> event.

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_1" id="all_event_end_1">#</a></span></h3>
<p>Emitted when the other end of the socket sends a FIN packet.

</p>
<p>By default (<code>allowHalfOpen == false</code>) the socket will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting <code>allowHalfOpen == true</code> the socket will not automatically <code>end()</code>
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to <code>end()</code> their side now.


</p>
<h3>Event: &apos;timeout&apos;<span><a class="mark" href="#all_event_timeout" id="all_event_timeout">#</a></span></h3>
<p>Emitted if the socket times out from inactivity. This is only to notify that
the socket has been idle. The user must manually close the connection.

</p>
<p>See also: <code>socket.setTimeout()</code>


</p>
<h3>Event: &apos;drain&apos;<span><a class="mark" href="#all_event_drain_1" id="all_event_drain_1">#</a></span></h3>
<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.

</p>
<p>See also: the return values of <code>socket.write()</code>

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error_3" id="all_event_error_3">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Error object</span></li>
</div></ul>
<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly
following this event.

</p>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close_3" id="all_event_close_3">#</a></span></h3>
<div class="signature"><ul>
<li><code>had_error</code> <span class="type">Boolean</span> true if the socket had a transmission error</li>
</div></ul>
<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean
which says if the socket was closed due to a transmission error.

</p>
<h2>net.isIP(input)<span><a class="mark" href="#all_net_isip_input" id="all_net_isip_input">#</a></span></h2>
<p>Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.


</p>
<h2>net.isIPv4(input)<span><a class="mark" href="#all_net_isipv4_input" id="all_net_isipv4_input">#</a></span></h2>
<p>Returns true if input is a version 4 IP address, otherwise returns false.


</p>
<h2>net.isIPv6(input)<span><a class="mark" href="#all_net_isipv6_input" id="all_net_isipv6_input">#</a></span></h2>
<p>Returns true if input is a version 6 IP address, otherwise returns false.

</p>
<h1>UDP / Sockets de Datagrama<span><a class="mark" href="#all_udp_sockets_de_datagrama" id="all_udp_sockets_de_datagrama">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!-- name=dgram -->

<p>Los sockets de datagrama están disponibles a través de <code>require(&apos;dgram&apos;)</code>.  Normalmente los datagramas 
se manejan como mensajes IP/UDP pero también se pueden usar a través de sockets de dominio Unix.

</p>
<h2>Evento: &apos;message&apos;<span><a class="mark" href="#all_evento_message" id="all_evento_message">#</a></span></h2>
<p><code>function (msg, rinfo) { }</code>

</p>
<p>Emitido cuando está disponible un nuevo datagrama en el socket.  <code>msg es un </code>Buffer<code> y </code>rinfo` es 
un objeto con la dirección de quien lo envía y el número de bytes que contiene el datagrama.

</p>
<h3>Evento: &apos;listening&apos;<span><a class="mark" href="#all_evento_listening" id="all_evento_listening">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Emitido cuando un socket empieza a escuchar la llegada de datagramas.  Esto ocurre tan pronto como 
son creados los sockets UDP.  Los sockets de dominio Unix no empiezan a escuchar hasta que se llama 
implícitamente a <code>bind()</code>.

</p>
<h2>Evento: &apos;close&apos;<span><a class="mark" href="#all_evento_close" id="all_evento_close">#</a></span></h2>
<p><code>function () { }</code>

</p>
<p>Emitido cuando se cierra un socket con <code>close()</code>. No se emitirán nuevos <code>message</code>en este 
socket.

</p>
<h3>dgram.createSocket(type, [callback])<span><a class="mark" href="#all_dgram_createsocket_type_callback" id="all_dgram_createsocket_type_callback">#</a></span></h3>
<p>Crea un socket de datagrama del tipo especificado.  Los tipos válidos son:
<code>udp4</code>, <code>udp6</code> y <code>unix_dgram</code>.

</p>
<p>Recibe un callback opcional que se añade como listener de los eventos <code>message</code>.

</p>
<h3>dgram.send(buf, offset, length, path, [callback])<span><a class="mark" href="#all_dgram_send_buf_offset_length_path_callback" id="all_dgram_send_buf_offset_length_path_callback">#</a></span></h3>
<p>Para los sockets de datagrama del dominio Unix, la dirección de destion es un nombre de ruta 
en sistema de ficheros. Se puede pasar un callback opcional que se invoca cuando se completa la llamada 
a <code>sendto</code> por parte del SO. No es seguro reutilizar <code>buf</code> hasta que se ha invocado el callback. Hay 
que tener en cuenta que a no ser que el socket este asociado a un nombre de ruta con <code>bind()</code> no hay manera 
de recibir mensajes en el socket.

</p>
<p>Ejemplo de envío de un mensaje al syslogd en OSX via un socket de dominio Unix <code>/var/run/syslog</code>:

</p>
<pre><code>var dgram = require(&apos;dgram&apos;);
var message = new Buffer(&quot;Un mensaje de log.&quot;);
var client = dgram.createSocket(&quot;unix_dgram&quot;);
client.send(message, 0, message.length, &quot;/var/run/syslog&quot;,
  function (err, bytes) {
    if (err) {
      throw err;
    }
    console.log(&quot;Se han escrito &quot; + bytes + &quot; bytes en el socket.&quot;);
});</code></pre>
<h2>dgram.send(buf, offset, length, port, address, [callback])<span><a class="mark" href="#all_dgram_send_buf_offset_length_port_address_callback" id="all_dgram_send_buf_offset_length_port_address_callback">#</a></span></h2>
<p>Para los sockets UDP, el puerto y la dirección IP de destino tienen que especificarse.  Se 
puede pasar un string al parámetro <code>address</code>, y se podrá resolver por DNS.  Se puede especificar 
un callback opcional para detectar cualquier error de DNS y cuando puede volverse a usar <code>buf</code>.<br>Tener en cuenta que las búsquedas de DNS retrasarán el tiempo del envío, al menos hasta el siguiente 
tick.  La única manera de asegurarse de que se ha realizado un envío es mediante el callback.

</p>
<p>Ejemplo de enviar un paquete UDP a un puerto aleatorio de <code>localhost</code>;

</p>
<pre><code>var dgram = require(&apos;dgram&apos;);
var message = new Buffer(&quot;Algunos bytes&quot;);
var client = dgram.createSocket(&quot;udp4&quot;);
client.send(message, 0, message.length, 41234, &quot;localhost&quot;);
client.close();</code></pre>
<h2>dgram.bind(path)<span><a class="mark" href="#all_dgram_bind_path" id="all_dgram_bind_path">#</a></span></h2>
<p>Para los sockets de datagrama de dominio Unix, empezar a escuchar datagramas entrantes en 
el socket especificado por <code>path</code>. Notar que los clientes pueden hacer <code>send()</code> sin haber hecho <code>bind()</code>, 
pero no se recibirá ningún datagrama sin haber hecho un <code>bind()</code>.

</p>
<p>Ejemplo de un servidor de datagramas de dominio Unix, que devuelve el eco de los mensajes que recibe:

</p>
<pre><code>var dgram = require(&quot;dgram&quot;);
var serverPath = &quot;/tmp/dgram_server_sock&quot;;
var server = dgram.createSocket(&quot;unix_dgram&quot;);

server.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;recibido: &quot; + msg + &quot; de &quot; + rinfo.address);
  server.send(msg, 0, msg.length, rinfo.address);
});

server.on(&quot;listening&quot;, function () {
  console.log(&quot;servidor escuchando &quot; + server.address().address);
})

server.bind(serverPath);</code></pre>
<p>Ejemplo de un cliente de datagramas de dominio Unix que habla con el servidor:

</p>
<pre><code>var dgram = require(&quot;dgram&quot;);
var serverPath = &quot;/tmp/dgram_server_sock&quot;;
var clientPath = &quot;/tmp/dgram_client_sock&quot;;

var message = new Buffer(&quot;Un mensaje el &quot; + (new Date()));

var client = dgram.createSocket(&quot;unix_dgram&quot;);

client.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;recibido: &quot; + msg + &quot; de &quot; + rinfo.address);
});

client.on(&quot;listening&quot;, function () {
  console.log(&quot;cliente escuchando &quot; + client.address().address);
  client.send(message, 0, message.length, serverPath);
});

client.bind(clientPath);</code></pre>
<h3>dgram.bind(port, [address])<span><a class="mark" href="#all_dgram_bind_port_address" id="all_dgram_bind_port_address">#</a></span></h3>
<p>Para los sockets UDP, hay que escuhar los datagramas en un <code>port</code> específico y en el <code>address</code> opcional.  Si 
no se especifica <code>address</code>, el SO intentará escuchar en todas las direcciones.

</p>
<p>Ejemplo de un servidor UDP escuchando en el puerto 41234:

</p>
<pre><code>var dgram = require(&quot;dgram&quot;);

var server = dgram.createSocket(&quot;udp4&quot;);

server.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;el servidor ha recibido: &quot; + msg + &quot; de &quot; +
    rinfo.address + &quot;:&quot; + rinfo.port);
});

server.on(&quot;listening&quot;, function () {
  var address = server.address();
  console.log(&quot;servidor escuchando &quot; +
      address.address + &quot;:&quot; + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>
<h2>dgram.close()<span><a class="mark" href="#all_dgram_close" id="all_dgram_close">#</a></span></h2>
<p>Cierra el socket subyacente y para de escuchar datos en él.  Los sockets UDP 
automáticamente se ponen a escuchar mensjaes, incluso si no han llamado a <code>bind()</code>.

</p>
<h3>dgram.address()<span><a class="mark" href="#all_dgram_address" id="all_dgram_address">#</a></span></h3>
<p>Devuelve un objeto que contiene la información de la dirección de un socket.  Para los sockets 
UDP, este objeto contendrá la <code>address</code> y el <code>port</code>.  Para los sockets de dominio Unix, solo contendrá 
la <code>address</code>.

</p>
<h3>dgram.setBroadcast(flag)<span><a class="mark" href="#all_dgram_setbroadcast_flag" id="all_dgram_setbroadcast_flag">#</a></span></h3>
<p>Establece o borra la opción del socket <code>SO_BROADCAST</code>.  Cuando se activa esta opción, los 
paquetes UDP se pueden enviar una dirección de broadcast de un interfaz local.

</p>
<h2>dgram.setTTL(ttl)<span><a class="mark" href="#all_dgram_setttl_ttl" id="all_dgram_setttl_ttl">#</a></span></h2>
<p>Establece la opción de socket <code>IP_TTL</code>.  TTL significa &quot;Time to Live&quot;, pero en este contexto 
especifica el número de saltos IP que se permite hacer al paquete.  Cada router o gateway que 
reenvíe un paquete decrementa el TTL.  Si un router decrementa el TTL a 0, no se reenviará.<br>El cambio de los valores del TTL es un uso típico para probar la red o con multicasting.

</p>
<p>El argumento que se le pasa a <code>setTTL()</code>es el número de saltos entre 1 y 255.  Por defecto 
en la mayoría de sistemas es 64.

</p>
<h3>dgram.setMulticastTTL(ttl)<span><a class="mark" href="#all_dgram_setmulticastttl_ttl" id="all_dgram_setmulticastttl_ttl">#</a></span></h3>
<p>Establece la opción de socket <code>IP_MULTICAST_TTL</code>. TTL significa &quot;Time to Live&quot;, pero en este contexto 
especifica el número de saltos IP que se permite hacer al paquete.  Cada router o gateway que 
reenvíe un paquete decrementa el TTL.  Si un router decrementa el TTL a 0, no se reenviará.  

</p>
<p>El argumento que se le pasa a <code>setMulticastTTL()</code> es el número de saltos entre 0 y 255.  Por defecto 
en la mayoría de sistemas es 64.

</p>
<h3>dgram.setMulticastLoopback(flag)<span><a class="mark" href="#all_dgram_setmulticastloopback_flag" id="all_dgram_setmulticastloopback_flag">#</a></span></h3>
<p>Establece o borra la opción de socket <code>IP_MULTICAST_LOOP</code>.  Cuand esta opción está activa,<br>también se recibirán paquetes multicast en el interfaz local. 

</p>
<h2>dgram.addMembership(multicastAddress, [multicastInterface])<span><a class="mark" href="#all_dgram_addmembership_multicastaddress_multicastinterface" id="all_dgram_addmembership_multicastaddress_multicastinterface">#</a></span></h2>
<p>Comunica al kernel la suscripción a un grupo multicast con la opción de socket <code>IP_ADD_MEMBERSHIP</code>. 

</p>
<p>Si no se especifica <code>multicastAddress</code>, el SO intentará suscribir todos los interfaces válidos.

</p>
<h2>dgram.dropMembership(multicastAddress, [multicastInterface])<span><a class="mark" href="#all_dgram_dropmembership_multicastaddress_multicastinterface" id="all_dgram_dropmembership_multicastaddress_multicastinterface">#</a></span></h2>
<p>El contrario de <code>addMembership</code> - comunica al kernel el abandono de un grupo multicast con 
la opción de socket <code>IP_DROP_MEMBERSHIP</code>. Este método se llama automáticamente por el kernel 
cuando se cierra el socket o el proceso termina, así que la mayoría de aplicaciones nunca tendrán 
que llamarlo. 

</p>
<p>Si no se especifica <code>multicastAddress</code>, el SO intentará suscribir todos los interfaces válidos.


</p>
<h1>DNS<span><a class="mark" href="#all_dns" id="all_dns">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>Use <code>require(&apos;dns&apos;)</code> to access this module. All methods in the dns module
use C-Ares except for <code>dns.lookup</code> which uses <code>getaddrinfo(3)</code> in a thread
pool. C-Ares is much faster than <code>getaddrinfo</code> but the system resolver is
more constant with how other programs operate. When a user does
<code>net.connect(80, &apos;google.com&apos;)</code> or <code>http.get({ host: &apos;google.com&apos; })</code> the
<code>dns.lookup</code> method is used. Users who need to do a large number of look ups
quickly should use the methods that go through C-Ares.

</p>
<p>Here is an example which resolves <code>&apos;www.google.com&apos;</code> then reverse
resolves the IP addresses which are returned.

</p>
<pre><code>var dns = require(&apos;dns&apos;);

dns.resolve4(&apos;www.google.com&apos;, function (err, addresses) {
  if (err) throw err;

  console.log(&apos;addresses: &apos; + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, domains) {
      if (err) {
        console.log(&apos;reverse for &apos; + a + &apos; failed: &apos; +
          err.message);
      } else {
        console.log(&apos;reverse for &apos; + a + &apos;: &apos; +
          JSON.stringify(domains));
      }
    });
  });
});</code></pre>
<h2>dns.lookup(domain, [family], callback)<span><a class="mark" href="#all_dns_lookup_domain_family_callback" id="all_dns_lookup_domain_family_callback">#</a></span></h2>
<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into the first found A (IPv4) or
AAAA (IPv6) record.
The <code>family</code> can be the integer <code>4</code> or <code>6</code>. Defaults to <code>null</code> that indicates
both Ip v4 and v6 address family.

</p>
<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument
is a string representation of a IP v4 or v6 address. The <code>family</code> argument
is either the integer 4 or 6 and denotes the family of <code>address</code> (not
necessarily the value initially passed to <code>lookup</code>).


</p>
<h2>dns.resolve(domain, [rrtype], callback)<span><a class="mark" href="#all_dns_resolve_domain_rrtype_callback" id="all_dns_resolve_domain_rrtype_callback">#</a></span></h2>
<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into an array of the record types
specified by rrtype. Valid rrtypes are <code>&apos;A&apos;</code> (IPV4 addresses, default),
<code>&apos;AAAA&apos;</code> (IPV6 addresses), <code>&apos;MX&apos;</code> (mail exchange records), <code>&apos;TXT&apos;</code> (text
records), <code>&apos;SRV&apos;</code> (SRV records), <code>&apos;PTR&apos;</code> (used for reverse IP lookups),
<code>&apos;NS&apos;</code> (name server records) and <code>&apos;CNAME&apos;</code> (canonical name records).

</p>
<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item
in <code>addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.

</p>
<p>On error, <code>err</code> would be an instanceof <code>Error</code> object, where <code>err.errno</code> is
one of the error codes listed below and <code>err.message</code> is a string describing
the error in English.


</p>
<h2>dns.resolve4(domain, callback)<span><a class="mark" href="#all_dns_resolve4_domain_callback" id="all_dns_resolve4_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).
<code>addresses</code> is an array of IPv4 addresses (e.g.
<code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>).

</p>
<h2>dns.resolve6(domain, callback)<span><a class="mark" href="#all_dns_resolve6_domain_callback" id="all_dns_resolve6_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).


</p>
<h2>dns.resolveMx(domain, callback)<span><a class="mark" href="#all_dns_resolvemx_domain_callback" id="all_dns_resolvemx_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).

</p>
<p><code>addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>).

</p>
<h2>dns.resolveTxt(domain, callback)<span><a class="mark" href="#all_dns_resolvetxt_domain_callback" id="all_dns_resolvetxt_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).
<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,
<code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>).

</p>
<h2>dns.resolveSrv(domain, callback)<span><a class="mark" href="#all_dns_resolvesrv_domain_callback" id="all_dns_resolvesrv_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).
<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties
of SRV records are priority, weight, port, and name (e.g.,
<code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>).

</p>
<h2>dns.reverse(ip, callback)<span><a class="mark" href="#all_dns_reverse_ip_callback" id="all_dns_reverse_ip_callback">#</a></span></h2>
<p>Reverse resolves an ip address to an array of domain names.

</p>
<p>The callback has arguments <code>(err, domains)</code>.

</p>
<h2>dns.resolveNs(domain, callback)<span><a class="mark" href="#all_dns_resolvens_domain_callback" id="all_dns_resolvens_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for name server records (<code>NS</code> records).
<code>addresses</code> is an array of the name server records available for <code>domain</code>
(e.g., <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>).

</p>
<h2>dns.resolveCname(domain, callback)<span><a class="mark" href="#all_dns_resolvecname_domain_callback" id="all_dns_resolvecname_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for canonical name records (<code>CNAME</code>
records). <code>addresses</code> is an array of the canonical name records available for
<code>domain</code> (e.g., <code>[&apos;bar.example.com&apos;]</code>).

</p>
<p>If there an an error, <code>err</code> will be non-null and an instanceof the Error
object.

</p>
<p>Each DNS query can return an error code.

</p>
<ul>
<li><code>dns.TEMPFAIL</code>: timeout, SERVFAIL or similar.</li>
<li><code>dns.PROTOCOL</code>: got garbled reply.</li>
<li><code>dns.NXDOMAIN</code>: domain does not exists.</li>
<li><code>dns.NODATA</code>: domain exists but no data of reqd type.</li>
<li><code>dns.NOMEM</code>: out of memory while processing.</li>
<li><code>dns.BADQUERY</code>: the query is malformed.</li>
</ul>
<h1>HTTP<span><a class="mark" href="#all_http" id="all_http">#</a></span></h1>
<p>Para usar el servidor y el cliente HTTP se debe añadir <code>require(&apos;http&apos;)</code>.

</p>
<p>Las interfaces HTTP en Node están diseñadas para soportar muchas de las características
del protocolo que tradicionalmente han sido difíciles de usar.
En particular, los mensajes grandes, seguramente fragmentado. La interfaz
se asegura de que las peticiones o respuestas nunca se almacenen completamente en un búfer--se permite al 
usuario hacer stream de datos.

</p>
<p>Las cabeceras de los mensajes HTTP se representan por un objeto como este:
    { &apos;content-length&apos;: &apos;123&apos;,
      &apos;content-type&apos;: &apos;text/plain&apos;,
      &apos;connection&apos;: &apos;keep-alive&apos;,
      &apos;accept&apos;: &apos;<em>/</em>&apos; }

</p>
<p>Las claves se convierten a minúsculas. Los valores no se modifican.

</p>
<p>Para soportar el espectro completo de las posibles aplicaciones HTTP, la API 
HTTP de Node es de muy bajo nivel. Se encarga únicamente de manejar el stream y 
del parsing del mensaje. Parsea el mensaje en sus cabeceras y body pero no parsea 
las cabeceras o el body.


</p>
<h2>http.Server<span><a class="mark" href="#all_http_server" id="all_http_server">#</a></span></h2>
<p>Es un <code>EventEmitter</code> con los siguientes eventos:

</p>
<h3>Evento: &apos;request&apos;<span><a class="mark" href="#all_evento_request" id="all_evento_request">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p> <code>request</code> es una instancia de <code>http.ServerRequest</code> y <code>response</code> es una
 instancia de <code>http.ServerResponse</code>

</p>
<h3>Evento: &apos;connection&apos;<span><a class="mark" href="#all_evento_connection" id="all_evento_connection">#</a></span></h3>
<p><code>function (stream) { }</code>

</p>
<p> Cuando se establece un nuevo stream TCP. <code>stream</code> es un objeto de tipo
<code>net.Stream</code>. Generalmente los usuarios no querrán acceder a este evento. 
También se puede acceder el <code>stream</code> desde  <code>request.connection</code>.

</p>
<h3>Evento: &apos;close&apos;<span><a class="mark" href="#all_evento_close_1" id="all_evento_close_1">#</a></span></h3>
<p><code>function (errno) { }</code>

</p>
<p> Emitido cuando se cierra el servidor.

</p>
<h3>Evento: &apos;request&apos;<span><a class="mark" href="#all_evento_request_1" id="all_evento_request_1">#</a></span></h3>
<p><code>function (request, response) {}</code>

</p>
<p>Emitido cada vez que se produce una petición. Nótese que pueden producirse múltiples peticiones
para cada conexión (en el caso de las conexiones keep-alive).

</p>
<h3>Evento: &apos;checkContinue&apos;<span><a class="mark" href="#all_evento_checkcontinue" id="all_evento_checkcontinue">#</a></span></h3>
<p><code>function (request, response) {}</code>

</p>
<p>Emitido cada vez que se recibe una petición con un http Expect: 100-continue.
Si no se está escuchando a este evento, el servidor responderá automáticamente 
con un 100 Continue.

</p>
<p>Para tratar este evento se tiene que llamar a <code>response.writeContinue</code> si el cliente 
quisiera seguir con el envío la petición de body, o generar una respuesta HTTP adecuada 
(ej. 400 Bad Request) si el cliente no quisiera continuar con el envío de la petición 
del body.

</p>
<p>Tener en cuenta que cuando se emite y se trata este evento, el evento <code>request</code> no se 
emitirá.

</p>
<h3>Evento: &apos;upgrade&apos;<span><a class="mark" href="#all_evento_upgrade" id="all_evento_upgrade">#</a></span></h3>
<p><code>function (request, socket, head)</code>

</p>
<p>Se emite cada vez que un cliente pide una actualización http. Si este evento no 
se está escuchando, entonces se cerrarán las conexiones de los clientes que esten 
pidiendo una actualización.

</p>
<ul>
<li><code>request</code> es el argumento para la petición http, como en el evento request.</li>
<li><code>socket</code> es el socket de red entre el servidor y el cliente.</li>
<li><code>head</code> es una instancia de Buffer, el primer paquete del stream actualizado, puede estar vacío.</li>
</ul>
<p>Después de emitir este evento, el socket de la petición no tendrá un listener del 
evento <code>data</code>, esto significa que necesitarás asociarlo para tratar los datos 
enviados al servidor en ese socket.

</p>
<h3>Evento: &apos;clientError&apos;<span><a class="mark" href="#all_evento_clienterror" id="all_evento_clienterror">#</a></span></h3>
<p><code>function (exception) {}</code>

</p>
<p>Si la conexión de un cliente emite un evento de &apos;error&apos; - será tratado aquí.

</p>
<h3>http.createServer(requestListener)<span><a class="mark" href="#all_http_createserver_requestlistener" id="all_http_createserver_requestlistener">#</a></span></h3>
<p>Devuelve un nuevo objeto de servidor web.

</p>
<p><code>requestListener</code> es una función que se añade automáticamente 
al evento <code>&apos;request&apos;</code>. 

</p>
<h3>server.listen(port, [hostname], [callback])<span><a class="mark" href="#all_server_listen_port_hostname_callback" id="all_server_listen_port_hostname_callback">#</a></span></h3>
<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
<p>To listen to a unix socket, supply a filename instead of port and hostname.

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound to the port.


</p>
<h3>server.listen(path, [callback])<span><a class="mark" href="#all_server_listen_path_callback" id="all_server_listen_path_callback">#</a></span></h3>
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.


</p>
<h3>server.close()<span><a class="mark" href="#all_server_close_1" id="all_server_close_1">#</a></span></h3>
<p>Stops the server from accepting new connections.


</p>
<h2>http.ServerRequest<span><a class="mark" href="#all_http_serverrequest" id="all_http_serverrequest">#</a></span></h2>
<p>This object is created internally by a HTTP server -- not by
the user -- and passed as the first argument to a <code>&apos;request&apos;</code> listener.

</p>
<p>This is an <code>EventEmitter</code> with the following events:

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_2" id="all_event_data_2">#</a></span></h3>
<p><code>function (chunk) { }</code>

</p>
<p>Emitted when a piece of the message body is received.

</p>
<p>Example: A chunk of the body is given as the single
argument. The transfer-encoding has been decoded.  The
body chunk is a string.  The body encoding is set with
<code>request.setBodyEncoding()</code>.

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_2" id="all_event_end_2">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Emitted exactly once for each message. No arguments.  After
emitted no other events will be emitted on the request.


</p>
<h3>request.method<span><a class="mark" href="#all_request_method" id="all_request_method">#</a></span></h3>
<p>The request method as a string. Read only. Example:
<code>&apos;GET&apos;</code>, <code>&apos;DELETE&apos;</code>.


</p>
<h3>request.url<span><a class="mark" href="#all_request_url" id="all_request_url">#</a></span></h3>
<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:

</p>
<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>
<p>Then <code>request.url</code> will be:

</p>
<pre><code>&apos;/status?name=ryan&apos;</code></pre>
<p>If you would like to parse the URL into its parts, you can use
<code>require(&apos;url&apos;).parse(request.url)</code>.  Example:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: &apos;name=ryan&apos;,
  pathname: &apos;/status&apos; }</code></pre>
<p>If you would like to extract the params from the query string,
you can use the <code>require(&apos;querystring&apos;).parse</code> function, or pass
<code>true</code> as the second argument to <code>require(&apos;url&apos;).parse</code>.  Example:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;, true)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: { name: &apos;ryan&apos; },
  pathname: &apos;/status&apos; }</code></pre>
<h3>request.headers<span><a class="mark" href="#all_request_headers" id="all_request_headers">#</a></span></h3>
<p>Read only.

</p>
<h3>request.trailers<span><a class="mark" href="#all_request_trailers" id="all_request_trailers">#</a></span></h3>
<p>Read only; HTTP trailers (if present). Only populated after the &apos;end&apos; event.

</p>
<h3>request.httpVersion<span><a class="mark" href="#all_request_httpversion" id="all_request_httpversion">#</a></span></h3>
<p>The HTTP protocol version as a string. Read only. Examples:
<code>&apos;1.1&apos;</code>, <code>&apos;1.0&apos;</code>.
Also <code>request.httpVersionMajor</code> is the first integer and
<code>request.httpVersionMinor</code> is the second.


</p>
<h3>request.setEncoding(encoding=null)<span><a class="mark" href="#all_request_setencoding_encoding_null" id="all_request_setencoding_encoding_null">#</a></span></h3>
<p>Set the encoding for the request body. Either <code>&apos;utf8&apos;</code> or <code>&apos;binary&apos;</code>. Defaults
to <code>null</code>, which means that the <code>&apos;data&apos;</code> event will emit a <code>Buffer</code> object..


</p>
<h3>request.pause()<span><a class="mark" href="#all_request_pause" id="all_request_pause">#</a></span></h3>
<p>Pauses request from emitting events.  Useful to throttle back an upload.


</p>
<h3>request.resume()<span><a class="mark" href="#all_request_resume" id="all_request_resume">#</a></span></h3>
<p>Resumes a paused request.

</p>
<h3>request.connection<span><a class="mark" href="#all_request_connection" id="all_request_connection">#</a></span></h3>
<p>The <code>net.Stream</code> object associated with the connection.


</p>
<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client&apos;s
authentication details.



</p>
<h2>http.ServerResponse<span><a class="mark" href="#all_http_serverresponse" id="all_http_serverresponse">#</a></span></h2>
<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code>&apos;request&apos;</code> event. It is a <code>Writable Stream</code>.

</p>
<h3>response.writeContinue()<span><a class="mark" href="#all_response_writecontinue" id="all_response_writecontinue">#</a></span></h3>
<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the the <code>checkContinue</code> event on
<code>Server</code>.

</p>
<h3>response.writeHead(statusCode, [reasonPhrase], [headers])<span><a class="mark" href="#all_response_writehead_statuscode_reasonphrase_headers" id="all_response_writehead_statuscode_reasonphrase_headers">#</a></span></h3>
<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
Optionally one can give a human-readable <code>reasonPhrase</code> as the second
argument.

</p>
<p>Example:

</p>
<pre><code>var body = &apos;hello world&apos;;
response.writeHead(200, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
<p>This method must only be called once on a message and it must
be called before <code>response.end()</code> is called.

</p>
<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
implicit/mutable headers will be calculated and call this function for you.

</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode" id="all_response_statuscode">#</a></span></h3>
<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property
controls the status code that will be send to the client when the headers get
flushed.

</p>
<p>Example:

</p>
<pre><code>response.statusCode = 404;</code></pre>
<h3>response.setHeader(name, value)<span><a class="mark" href="#all_response_setheader_name_value" id="all_response_setheader_name_value">#</a></span></h3>
<p>Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, it&apos;s value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.

</p>
<p>Example:

</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
<p>or

</p>
<pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
<h3>response.getHeader(name)<span><a class="mark" href="#all_response_getheader_name" id="all_response_getheader_name">#</a></span></h3>
<p>Reads out a header that&apos;s already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.

</p>
<p>Example:

</p>
<pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>
<h3>response.removeHeader(name)<span><a class="mark" href="#all_response_removeheader_name" id="all_response_removeheader_name">#</a></span></h3>
<p>Removes a header that&apos;s queued for implicit sending.

</p>
<p>Example:

</p>
<pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
<h3>response.write(chunk, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_response_write_chunk_encoding_utf8" id="all_response_write_chunk_encoding_utf8">#</a></span></h3>
<p>If this method is called and <code>response.writeHead()</code> has not been called, it will
switch to implicit header mode and flush the implicit headers.

</p>
<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.

</p>
<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>&apos;utf8&apos;</code>.

</p>
<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.

</p>
<p>The first time <code>response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code>response.write()</code> is called, Node assumes you&apos;re going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.

</p>
<h3>response.addTrailers(headers)<span><a class="mark" href="#all_response_addtrailers_headers" id="all_response_addtrailers_headers">#</a></span></h3>
<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.

</p>
<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.

</p>
<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,

</p>
<pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,
                          &apos;Trailer&apos;: &apos;TraceInfo&apos; });
response.write(fileData);
response.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();</code></pre>
<h3>response.end([data], [encoding])<span><a class="mark" href="#all_response_end_data_encoding" id="all_response_end_data_encoding">#</a></span></h3>
<p>This method signals to the server that all of the response headers and body
has been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each
response.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
followed by <code>response.end()</code>.


</p>
<h2>http.request(options, callback)<span><a class="mark" href="#all_http_request_options_callback" id="all_http_request_options_callback">#</a></span></h2>
<p>Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.

</p>
<p>Options:

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>
<li><code>port</code>: Port of remote server.</li>
<li><code>method</code>: A string specifying the HTTP request method. Possible values:
<code>&apos;GET&apos;</code> (default), <code>&apos;POST&apos;</code>, <code>&apos;PUT&apos;</code>, and <code>&apos;DELETE&apos;</code>.</li>
<li><code>path</code>: Request path. Should include query string and fragments if any.
 E.G. <code>&apos;/index.html?page=12&apos;</code></li>
<li><code>headers</code>: An object containing request headers.</li>
</ul>
<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code>
class. The <code>ClientRequest</code> instance is a writable stream. If one needs to
upload a file with a POST request, then write to the <code>ClientRequest</code> object.

</p>
<p>Example:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/upload&apos;,
  method: &apos;POST&apos;
};

var req = http.request(options, function(res) {
  console.log(&apos;STATUS: &apos; + res.statusCode);
  console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers));
  res.setEncoding(&apos;utf8&apos;);
  res.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

// write data to request body
req.write(&apos;data\n&apos;);
req.write(&apos;data\n&apos;);
req.end();</code></pre>
<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one
must always call <code>req.end()</code> to signify that you&apos;re done with the request -
even if there is no data being written to the request body.

</p>
<p>If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an <code>&apos;error&apos;</code> event is emitted
on the returned request object.

</p>
<p>There are a few special headers that should be noted.

</p>
<ul>
<li><p>Sending a &apos;Connection: keep-alive&apos; will notify Node that the connection to
the server should be persisted until the next request.</p>
</li>
<li><p>Sending a &apos;Content-length&apos; header will disable the default chunked encoding.</p>
</li>
<li><p>Sending an &apos;Expect&apos; header will immediately send the request headers.
Usually, when sending &apos;Expect: 100-continue&apos;, you should both set a timeout
and listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more
information.</p>
</li>
</ul>
<h2>http.get(options, callback)<span><a class="mark" href="#all_http_get_options_callback" id="all_http_get_options_callback">#</a></span></h2>
<p>Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and <code>http.request()</code> is
that it sets the method to GET and calls <code>req.end()</code> automatically.

</p>
<p>Example:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/index.html&apos;
};

http.get(options, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&apos;error&apos;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});</code></pre>
<h2>http.Agent<span><a class="mark" href="#all_http_agent" id="all_http_agent">#</a></span></h2>
<h2>http.getAgent(host, port)<span><a class="mark" href="#all_http_getagent_host_port" id="all_http_getagent_host_port">#</a></span></h2>
<p><code>http.request()</code> uses a special <code>Agent</code> for managing multiple connections to
an HTTP server. Normally <code>Agent</code> instances should not be exposed to user
code, however in certain situations it&apos;s useful to check the status of the
agent. The <code>http.getAgent()</code> function allows you to access the agents.

</p>
<h3>Event: &apos;upgrade&apos;<span><a class="mark" href="#all_event_upgrade" id="all_event_upgrade">#</a></span></h3>
<p><code>function (request, socket, head)</code>

</p>
<p>Emitted each time a server responds to a request with an upgrade. If this event
isn&apos;t being listened for, clients receiving an upgrade header will have their
connections closed.

</p>
<p>See the description of the <code>upgrade</code> event for <code>http.Server</code> for further details.

</p>
<h3>Event: &apos;continue&apos;<span><a class="mark" href="#all_event_continue" id="all_event_continue">#</a></span></h3>
<p><code>function ()</code>

</p>
<p>Emitted when the server sends a &apos;100 Continue&apos; HTTP response, usually because
the request contained &apos;Expect: 100-continue&apos;. This is an instruction that
the client should send the request body.

</p>
<h3>agent.maxSockets<span><a class="mark" href="#all_agent_maxsockets" id="all_agent_maxsockets">#</a></span></h3>
<p>By default set to 5. Determines how many concurrent sockets the agent can have open.

</p>
<h3>agent.sockets<span><a class="mark" href="#all_agent_sockets" id="all_agent_sockets">#</a></span></h3>
<p>An array of sockets currently in use by the Agent. Do not modify.

</p>
<h3>agent.queue<span><a class="mark" href="#all_agent_queue" id="all_agent_queue">#</a></span></h3>
<p>A queue of requests waiting to be sent to sockets.



</p>
<h2>http.ClientRequest<span><a class="mark" href="#all_http_clientrequest" id="all_http_clientrequest">#</a></span></h2>
<p>This object is created internally and returned from <code>http.request()</code>.  It
represents an <em>in-progress</em> request whose header has already been queued.  The 
header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
<code>removeHeader(name)</code> API.  The actual header will be sent along with the first
data chunk or when closing the connection.

</p>
<p>To get the response, add a listener for <code>&apos;response&apos;</code> to the request object.
<code>&apos;response&apos;</code> will be emitted from the request object when the response
headers have been received.  The <code>&apos;response&apos;</code> event is executed with one
argument which is an instance of <code>http.ClientResponse</code>.

</p>
<p>During the <code>&apos;response&apos;</code> event, one can add listeners to the
response object; particularly to listen for the <code>&apos;data&apos;</code> event. Note that
the <code>&apos;response&apos;</code> event is called before any part of the response body is received,
so there is no need to worry about racing to catch the first part of the
body. As long as a listener for <code>&apos;data&apos;</code> is added during the <code>&apos;response&apos;</code>
event, the entire body will be caught.


</p>
<pre><code>// Good
request.on(&apos;response&apos;, function (response) {
  response.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

// Bad - misses all or part of the body
request.on(&apos;response&apos;, function (response) {
  setTimeout(function () {
    response.on(&apos;data&apos;, function (chunk) {
      console.log(&apos;BODY: &apos; + chunk);
    });
  }, 10);
});</code></pre>
<p>This is a <code>Writable Stream</code>.

</p>
<p>This is an <code>EventEmitter</code> with the following events:

</p>
<h3>Event &apos;response&apos;<span><a class="mark" href="#all_event_response" id="all_event_response">#</a></span></h3>
<p><code>function (response) { }</code>

</p>
<p>Emitted when a response is received to this request. This event is emitted only once. The
<code>response</code> argument will be an instance of <code>http.ClientResponse</code>.


</p>
<h3>request.write(chunk, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_request_write_chunk_encoding_utf8" id="all_request_write_chunk_encoding_utf8">#</a></span></h3>
<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code>[&apos;Transfer-Encoding&apos;, &apos;chunked&apos;]</code> header line when
creating the request.

</p>
<p>The <code>chunk</code> argument should be an array of integers
or a string.

</p>
<p>The <code>encoding</code> argument is optional and only
applies when <code>chunk</code> is a string.


</p>
<h3>request.end([data], [encoding])<span><a class="mark" href="#all_request_end_data_encoding" id="all_request_end_data_encoding">#</a></span></h3>
<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>&apos;0\r\n\r\n&apos;</code>.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling <code>request.write(data, encoding)</code>
followed by <code>request.end()</code>.

</p>
<h3>request.abort()<span><a class="mark" href="#all_request_abort" id="all_request_abort">#</a></span></h3>
<p>Aborts a request.  (New since v0.3.8.)


</p>
<h2>http.ClientResponse<span><a class="mark" href="#all_http_clientresponse" id="all_http_clientresponse">#</a></span></h2>
<p>This object is created when making a request with <code>http.request()</code>. It is
passed to the <code>&apos;response&apos;</code> event of the request object.

</p>
<p>The response implements the <code>Readable Stream</code> interface.

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_3" id="all_event_data_3">#</a></span></h3>
<p><code>function (chunk) {}</code>

</p>
<p>Emitted when a piece of the message body is received.


</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_3" id="all_event_end_3">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p>Emitted exactly once for each message. No arguments. After
emitted no other events will be emitted on the response.

</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode_1" id="all_response_statuscode_1">#</a></span></h3>
<p>The 3-digit HTTP response status code. E.G. <code>404</code>.

</p>
<h3>response.httpVersion<span><a class="mark" href="#all_response_httpversion" id="all_response_httpversion">#</a></span></h3>
<p>The HTTP version of the connected-to server. Probably either
<code>&apos;1.1&apos;</code> or <code>&apos;1.0&apos;</code>.
Also <code>response.httpVersionMajor</code> is the first integer and
<code>response.httpVersionMinor</code> is the second.

</p>
<h3>response.headers<span><a class="mark" href="#all_response_headers" id="all_response_headers">#</a></span></h3>
<p>The response headers object.

</p>
<h3>response.trailers<span><a class="mark" href="#all_response_trailers" id="all_response_trailers">#</a></span></h3>
<p>The response trailers object. Only populated after the &apos;end&apos; event.

</p>
<h3>response.setEncoding(encoding=null)<span><a class="mark" href="#all_response_setencoding_encoding_null" id="all_response_setencoding_encoding_null">#</a></span></h3>
<p>Set the encoding for the response body. Either <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.
Defaults to <code>null</code>, which means that the <code>&apos;data&apos;</code> event will emit a <code>Buffer</code> object..

</p>
<h3>response.pause()<span><a class="mark" href="#all_response_pause" id="all_response_pause">#</a></span></h3>
<p>Pauses response from emitting events.  Useful to throttle back a download.

</p>
<h3>response.resume()<span><a class="mark" href="#all_response_resume" id="all_response_resume">#</a></span></h3>
<p>Resumes a paused response.

</p>
<h1>HTTP<span><a class="mark" href="#all_http_1" id="all_http_1">#</a></span></h1>
<p>Para usar el servidor y el cliente HTTP se debe añadir <code>require(&apos;http&apos;)</code>.

</p>
<p>Las interfaces HTTP en Node están diseñadas para soportar muchas de las características
del protocolo que tradicionalmente han sido difíciles de usar.
En particular, los mensajes grandes, seguramente fragmentado. La interfaz
se asegura de que las peticiones o respuestas nunca se almacenen completamente en un búfer--se permite al 
usuario hacer stream de datos.

</p>
<p>Las cabeceras de los mensajes HTTP se representan por un objeto como este:
    { &apos;content-length&apos;: &apos;123&apos;,
      &apos;content-type&apos;: &apos;text/plain&apos;,
      &apos;connection&apos;: &apos;keep-alive&apos;,
      &apos;accept&apos;: &apos;<em>/</em>&apos; }

</p>
<p>Las claves se convierten a minúsculas. Los valores no se modifican.

</p>
<p>Para soportar el espectro completo de las posibles aplicaciones HTTP, la API 
HTTP de Node es de muy bajo nivel. Se encarga únicamente de manejar el stream y 
del parsing del mensaje. Parsea el mensaje en sus cabeceras y body pero no parsea 
las cabeceras o el body.


</p>
<h2>http.Server<span><a class="mark" href="#all_http_server_1" id="all_http_server_1">#</a></span></h2>
<p>Es un <code>EventEmitter</code> con los siguientes eventos:

</p>
<h3>Evento: &apos;request&apos;<span><a class="mark" href="#all_evento_request_2" id="all_evento_request_2">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p> <code>request</code> es una instancia de <code>http.ServerRequest</code> y <code>response</code> es una
 instancia de <code>http.ServerResponse</code>

</p>
<h3>Evento: &apos;connection&apos;<span><a class="mark" href="#all_evento_connection_1" id="all_evento_connection_1">#</a></span></h3>
<p><code>function (stream) { }</code>

</p>
<p> Cuando se establece un nuevo stream TCP. <code>stream</code> es un objeto de tipo
<code>net.Stream</code>. Generalmente los usuarios no querrán acceder a este evento. 
También se puede acceder el <code>stream</code> desde  <code>request.connection</code>.

</p>
<h3>Evento: &apos;close&apos;<span><a class="mark" href="#all_evento_close_2" id="all_evento_close_2">#</a></span></h3>
<p><code>function (errno) { }</code>

</p>
<p> Emitido cuando se cierra el servidor.

</p>
<h3>Evento: &apos;request&apos;<span><a class="mark" href="#all_evento_request_3" id="all_evento_request_3">#</a></span></h3>
<p><code>function (request, response) {}</code>

</p>
<p>Emitido cada vez que se produce una petición. Nótese que pueden producirse múltiples peticiones
para cada conexión (en el caso de las conexiones keep-alive).

</p>
<h3>Evento: &apos;checkContinue&apos;<span><a class="mark" href="#all_evento_checkcontinue_1" id="all_evento_checkcontinue_1">#</a></span></h3>
<p><code>function (request, response) {}</code>

</p>
<p>Emitido cada vez que se recibe una petición con un http Expect: 100-continue.
Si no se está escuchando a este evento, el servidor responderá automáticamente 
con un 100 Continue.

</p>
<p>Para tratar este evento se tiene que llamar a <code>response.writeContinue</code> si el cliente 
quisiera seguir con el envío la petición de body, o generar una respuesta HTTP adecuada 
(ej. 400 Bad Request) si el cliente no quisiera continuar con el envío de la petición 
del body.

</p>
<p>Tener en cuenta que cuando se emite y se trata este evento, el evento <code>request</code> no se 
emitirá.

</p>
<h3>Evento: &apos;upgrade&apos;<span><a class="mark" href="#all_evento_upgrade_1" id="all_evento_upgrade_1">#</a></span></h3>
<p><code>function (request, socket, head)</code>

</p>
<p>Se emite cada vez que un cliente pide una actualización http. Si este evento no 
se está escuchando, entonces se cerrarán las conexiones de los clientes que esten 
pidiendo una actualización.

</p>
<ul>
<li><code>request</code> es el argumento para la petición http, como en el evento request.</li>
<li><code>socket</code> es el socket de red entre el servidor y el cliente.</li>
<li><code>head</code> es una instancia de Buffer, el primer paquete del stream actualizado, puede estar vacío.</li>
</ul>
<p>Después de emitir este evento, el socket de la petición no tendrá un listener del 
evento <code>data</code>, esto significa que necesitarás asociarlo para tratar los datos 
enviados al servidor en ese socket.

</p>
<h3>Evento: &apos;clientError&apos;<span><a class="mark" href="#all_evento_clienterror_1" id="all_evento_clienterror_1">#</a></span></h3>
<p><code>function (exception) {}</code>

</p>
<p>Si la conexión de un cliente emite un evento de &apos;error&apos; - será tratado aquí.

</p>
<h3>http.createServer(requestListener)<span><a class="mark" href="#all_http_createserver_requestlistener_1" id="all_http_createserver_requestlistener_1">#</a></span></h3>
<p>Devuelve un nuevo objeto de servidor web.

</p>
<p><code>requestListener</code> es una función que se añade automáticamente 
al evento <code>&apos;request&apos;</code>. 

</p>
<h3>server.listen(port, [hostname], [callback])<span><a class="mark" href="#all_server_listen_port_hostname_callback_1" id="all_server_listen_port_hostname_callback_1">#</a></span></h3>
<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
<p>To listen to a unix socket, supply a filename instead of port and hostname.

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound to the port.


</p>
<h3>server.listen(path, [callback])<span><a class="mark" href="#all_server_listen_path_callback_1" id="all_server_listen_path_callback_1">#</a></span></h3>
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.


</p>
<h3>server.close()<span><a class="mark" href="#all_server_close_2" id="all_server_close_2">#</a></span></h3>
<p>Stops the server from accepting new connections.


</p>
<h2>http.ServerRequest<span><a class="mark" href="#all_http_serverrequest_1" id="all_http_serverrequest_1">#</a></span></h2>
<p>This object is created internally by a HTTP server -- not by
the user -- and passed as the first argument to a <code>&apos;request&apos;</code> listener.

</p>
<p>This is an <code>EventEmitter</code> with the following events:

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_4" id="all_event_data_4">#</a></span></h3>
<p><code>function (chunk) { }</code>

</p>
<p>Emitted when a piece of the message body is received.

</p>
<p>Example: A chunk of the body is given as the single
argument. The transfer-encoding has been decoded.  The
body chunk is a string.  The body encoding is set with
<code>request.setBodyEncoding()</code>.

</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_4" id="all_event_end_4">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Emitted exactly once for each message. No arguments.  After
emitted no other events will be emitted on the request.


</p>
<h3>request.method<span><a class="mark" href="#all_request_method_1" id="all_request_method_1">#</a></span></h3>
<p>The request method as a string. Read only. Example:
<code>&apos;GET&apos;</code>, <code>&apos;DELETE&apos;</code>.


</p>
<h3>request.url<span><a class="mark" href="#all_request_url_1" id="all_request_url_1">#</a></span></h3>
<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:

</p>
<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>
<p>Then <code>request.url</code> will be:

</p>
<pre><code>&apos;/status?name=ryan&apos;</code></pre>
<p>If you would like to parse the URL into its parts, you can use
<code>require(&apos;url&apos;).parse(request.url)</code>.  Example:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: &apos;name=ryan&apos;,
  pathname: &apos;/status&apos; }</code></pre>
<p>If you would like to extract the params from the query string,
you can use the <code>require(&apos;querystring&apos;).parse</code> function, or pass
<code>true</code> as the second argument to <code>require(&apos;url&apos;).parse</code>.  Example:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;, true)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: { name: &apos;ryan&apos; },
  pathname: &apos;/status&apos; }</code></pre>
<h3>request.headers<span><a class="mark" href="#all_request_headers_1" id="all_request_headers_1">#</a></span></h3>
<p>Read only.

</p>
<h3>request.trailers<span><a class="mark" href="#all_request_trailers_1" id="all_request_trailers_1">#</a></span></h3>
<p>Read only; HTTP trailers (if present). Only populated after the &apos;end&apos; event.

</p>
<h3>request.httpVersion<span><a class="mark" href="#all_request_httpversion_1" id="all_request_httpversion_1">#</a></span></h3>
<p>The HTTP protocol version as a string. Read only. Examples:
<code>&apos;1.1&apos;</code>, <code>&apos;1.0&apos;</code>.
Also <code>request.httpVersionMajor</code> is the first integer and
<code>request.httpVersionMinor</code> is the second.


</p>
<h3>request.setEncoding(encoding=null)<span><a class="mark" href="#all_request_setencoding_encoding_null_1" id="all_request_setencoding_encoding_null_1">#</a></span></h3>
<p>Set the encoding for the request body. Either <code>&apos;utf8&apos;</code> or <code>&apos;binary&apos;</code>. Defaults
to <code>null</code>, which means that the <code>&apos;data&apos;</code> event will emit a <code>Buffer</code> object..


</p>
<h3>request.pause()<span><a class="mark" href="#all_request_pause_1" id="all_request_pause_1">#</a></span></h3>
<p>Pauses request from emitting events.  Useful to throttle back an upload.


</p>
<h3>request.resume()<span><a class="mark" href="#all_request_resume_1" id="all_request_resume_1">#</a></span></h3>
<p>Resumes a paused request.

</p>
<h3>request.connection<span><a class="mark" href="#all_request_connection_1" id="all_request_connection_1">#</a></span></h3>
<p>The <code>net.Stream</code> object associated with the connection.


</p>
<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client&apos;s
authentication details.



</p>
<h2>http.ServerResponse<span><a class="mark" href="#all_http_serverresponse_1" id="all_http_serverresponse_1">#</a></span></h2>
<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code>&apos;request&apos;</code> event. It is a <code>Writable Stream</code>.

</p>
<h3>response.writeContinue()<span><a class="mark" href="#all_response_writecontinue_1" id="all_response_writecontinue_1">#</a></span></h3>
<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the the <code>checkContinue</code> event on
<code>Server</code>.

</p>
<h3>response.writeHead(statusCode, [reasonPhrase], [headers])<span><a class="mark" href="#all_response_writehead_statuscode_reasonphrase_headers_1" id="all_response_writehead_statuscode_reasonphrase_headers_1">#</a></span></h3>
<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
Optionally one can give a human-readable <code>reasonPhrase</code> as the second
argument.

</p>
<p>Example:

</p>
<pre><code>var body = &apos;hello world&apos;;
response.writeHead(200, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
<p>This method must only be called once on a message and it must
be called before <code>response.end()</code> is called.

</p>
<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
implicit/mutable headers will be calculated and call this function for you.

</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode_2" id="all_response_statuscode_2">#</a></span></h3>
<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property
controls the status code that will be send to the client when the headers get
flushed.

</p>
<p>Example:

</p>
<pre><code>response.statusCode = 404;</code></pre>
<h3>response.setHeader(name, value)<span><a class="mark" href="#all_response_setheader_name_value_1" id="all_response_setheader_name_value_1">#</a></span></h3>
<p>Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, it&apos;s value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.

</p>
<p>Example:

</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
<p>or

</p>
<pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
<h3>response.getHeader(name)<span><a class="mark" href="#all_response_getheader_name_1" id="all_response_getheader_name_1">#</a></span></h3>
<p>Reads out a header that&apos;s already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.

</p>
<p>Example:

</p>
<pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>
<h3>response.removeHeader(name)<span><a class="mark" href="#all_response_removeheader_name_1" id="all_response_removeheader_name_1">#</a></span></h3>
<p>Removes a header that&apos;s queued for implicit sending.

</p>
<p>Example:

</p>
<pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
<h3>response.write(chunk, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_response_write_chunk_encoding_utf8_1" id="all_response_write_chunk_encoding_utf8_1">#</a></span></h3>
<p>If this method is called and <code>response.writeHead()</code> has not been called, it will
switch to implicit header mode and flush the implicit headers.

</p>
<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.

</p>
<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>&apos;utf8&apos;</code>.

</p>
<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.

</p>
<p>The first time <code>response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code>response.write()</code> is called, Node assumes you&apos;re going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.

</p>
<h3>response.addTrailers(headers)<span><a class="mark" href="#all_response_addtrailers_headers_1" id="all_response_addtrailers_headers_1">#</a></span></h3>
<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.

</p>
<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.

</p>
<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,

</p>
<pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,
                          &apos;Trailer&apos;: &apos;TraceInfo&apos; });
response.write(fileData);
response.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();</code></pre>
<h3>response.end([data], [encoding])<span><a class="mark" href="#all_response_end_data_encoding_1" id="all_response_end_data_encoding_1">#</a></span></h3>
<p>This method signals to the server that all of the response headers and body
has been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each
response.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
followed by <code>response.end()</code>.


</p>
<h2>http.request(options, callback)<span><a class="mark" href="#all_http_request_options_callback_1" id="all_http_request_options_callback_1">#</a></span></h2>
<p>Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.

</p>
<p>Options:

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>
<li><code>port</code>: Port of remote server.</li>
<li><code>method</code>: A string specifying the HTTP request method. Possible values:
<code>&apos;GET&apos;</code> (default), <code>&apos;POST&apos;</code>, <code>&apos;PUT&apos;</code>, and <code>&apos;DELETE&apos;</code>.</li>
<li><code>path</code>: Request path. Should include query string and fragments if any.
 E.G. <code>&apos;/index.html?page=12&apos;</code></li>
<li><code>headers</code>: An object containing request headers.</li>
</ul>
<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code>
class. The <code>ClientRequest</code> instance is a writable stream. If one needs to
upload a file with a POST request, then write to the <code>ClientRequest</code> object.

</p>
<p>Example:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/upload&apos;,
  method: &apos;POST&apos;
};

var req = http.request(options, function(res) {
  console.log(&apos;STATUS: &apos; + res.statusCode);
  console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers));
  res.setEncoding(&apos;utf8&apos;);
  res.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

// write data to request body
req.write(&apos;data\n&apos;);
req.write(&apos;data\n&apos;);
req.end();</code></pre>
<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one
must always call <code>req.end()</code> to signify that you&apos;re done with the request -
even if there is no data being written to the request body.

</p>
<p>If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an <code>&apos;error&apos;</code> event is emitted
on the returned request object.

</p>
<p>There are a few special headers that should be noted.

</p>
<ul>
<li><p>Sending a &apos;Connection: keep-alive&apos; will notify Node that the connection to
the server should be persisted until the next request.</p>
</li>
<li><p>Sending a &apos;Content-length&apos; header will disable the default chunked encoding.</p>
</li>
<li><p>Sending an &apos;Expect&apos; header will immediately send the request headers.
Usually, when sending &apos;Expect: 100-continue&apos;, you should both set a timeout
and listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more
information.</p>
</li>
</ul>
<h2>http.get(options, callback)<span><a class="mark" href="#all_http_get_options_callback_1" id="all_http_get_options_callback_1">#</a></span></h2>
<p>Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and <code>http.request()</code> is
that it sets the method to GET and calls <code>req.end()</code> automatically.

</p>
<p>Example:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/index.html&apos;
};

http.get(options, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&apos;error&apos;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});</code></pre>
<h2>http.Agent<span><a class="mark" href="#all_http_agent_1" id="all_http_agent_1">#</a></span></h2>
<h2>http.getAgent(host, port)<span><a class="mark" href="#all_http_getagent_host_port_1" id="all_http_getagent_host_port_1">#</a></span></h2>
<p><code>http.request()</code> uses a special <code>Agent</code> for managing multiple connections to
an HTTP server. Normally <code>Agent</code> instances should not be exposed to user
code, however in certain situations it&apos;s useful to check the status of the
agent. The <code>http.getAgent()</code> function allows you to access the agents.

</p>
<h3>Event: &apos;upgrade&apos;<span><a class="mark" href="#all_event_upgrade_1" id="all_event_upgrade_1">#</a></span></h3>
<p><code>function (request, socket, head)</code>

</p>
<p>Emitted each time a server responds to a request with an upgrade. If this event
isn&apos;t being listened for, clients receiving an upgrade header will have their
connections closed.

</p>
<p>See the description of the <code>upgrade</code> event for <code>http.Server</code> for further details.

</p>
<h3>Event: &apos;continue&apos;<span><a class="mark" href="#all_event_continue_1" id="all_event_continue_1">#</a></span></h3>
<p><code>function ()</code>

</p>
<p>Emitted when the server sends a &apos;100 Continue&apos; HTTP response, usually because
the request contained &apos;Expect: 100-continue&apos;. This is an instruction that
the client should send the request body.

</p>
<h3>agent.maxSockets<span><a class="mark" href="#all_agent_maxsockets_1" id="all_agent_maxsockets_1">#</a></span></h3>
<p>By default set to 5. Determines how many concurrent sockets the agent can have open.

</p>
<h3>agent.sockets<span><a class="mark" href="#all_agent_sockets_1" id="all_agent_sockets_1">#</a></span></h3>
<p>An array of sockets currently in use by the Agent. Do not modify.

</p>
<h3>agent.queue<span><a class="mark" href="#all_agent_queue_1" id="all_agent_queue_1">#</a></span></h3>
<p>A queue of requests waiting to be sent to sockets.



</p>
<h2>http.ClientRequest<span><a class="mark" href="#all_http_clientrequest_1" id="all_http_clientrequest_1">#</a></span></h2>
<p>This object is created internally and returned from <code>http.request()</code>.  It
represents an <em>in-progress</em> request whose header has already been queued.  The 
header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
<code>removeHeader(name)</code> API.  The actual header will be sent along with the first
data chunk or when closing the connection.

</p>
<p>To get the response, add a listener for <code>&apos;response&apos;</code> to the request object.
<code>&apos;response&apos;</code> will be emitted from the request object when the response
headers have been received.  The <code>&apos;response&apos;</code> event is executed with one
argument which is an instance of <code>http.ClientResponse</code>.

</p>
<p>During the <code>&apos;response&apos;</code> event, one can add listeners to the
response object; particularly to listen for the <code>&apos;data&apos;</code> event. Note that
the <code>&apos;response&apos;</code> event is called before any part of the response body is received,
so there is no need to worry about racing to catch the first part of the
body. As long as a listener for <code>&apos;data&apos;</code> is added during the <code>&apos;response&apos;</code>
event, the entire body will be caught.


</p>
<pre><code>// Good
request.on(&apos;response&apos;, function (response) {
  response.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

// Bad - misses all or part of the body
request.on(&apos;response&apos;, function (response) {
  setTimeout(function () {
    response.on(&apos;data&apos;, function (chunk) {
      console.log(&apos;BODY: &apos; + chunk);
    });
  }, 10);
});</code></pre>
<p>This is a <code>Writable Stream</code>.

</p>
<p>This is an <code>EventEmitter</code> with the following events:

</p>
<h3>Event &apos;response&apos;<span><a class="mark" href="#all_event_response_1" id="all_event_response_1">#</a></span></h3>
<p><code>function (response) { }</code>

</p>
<p>Emitted when a response is received to this request. This event is emitted only once. The
<code>response</code> argument will be an instance of <code>http.ClientResponse</code>.


</p>
<h3>request.write(chunk, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_request_write_chunk_encoding_utf8_1" id="all_request_write_chunk_encoding_utf8_1">#</a></span></h3>
<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code>[&apos;Transfer-Encoding&apos;, &apos;chunked&apos;]</code> header line when
creating the request.

</p>
<p>The <code>chunk</code> argument should be an array of integers
or a string.

</p>
<p>The <code>encoding</code> argument is optional and only
applies when <code>chunk</code> is a string.


</p>
<h3>request.end([data], [encoding])<span><a class="mark" href="#all_request_end_data_encoding_1" id="all_request_end_data_encoding_1">#</a></span></h3>
<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>&apos;0\r\n\r\n&apos;</code>.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling <code>request.write(data, encoding)</code>
followed by <code>request.end()</code>.

</p>
<h3>request.abort()<span><a class="mark" href="#all_request_abort_1" id="all_request_abort_1">#</a></span></h3>
<p>Aborts a request.  (New since v0.3.8.)


</p>
<h2>http.ClientResponse<span><a class="mark" href="#all_http_clientresponse_1" id="all_http_clientresponse_1">#</a></span></h2>
<p>This object is created when making a request with <code>http.request()</code>. It is
passed to the <code>&apos;response&apos;</code> event of the request object.

</p>
<p>The response implements the <code>Readable Stream</code> interface.

</p>
<h3>Event: &apos;data&apos;<span><a class="mark" href="#all_event_data_5" id="all_event_data_5">#</a></span></h3>
<p><code>function (chunk) {}</code>

</p>
<p>Emitted when a piece of the message body is received.


</p>
<h3>Event: &apos;end&apos;<span><a class="mark" href="#all_event_end_5" id="all_event_end_5">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p>Emitted exactly once for each message. No arguments. After
emitted no other events will be emitted on the response.

</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode_3" id="all_response_statuscode_3">#</a></span></h3>
<p>The 3-digit HTTP response status code. E.G. <code>404</code>.

</p>
<h3>response.httpVersion<span><a class="mark" href="#all_response_httpversion_1" id="all_response_httpversion_1">#</a></span></h3>
<p>The HTTP version of the connected-to server. Probably either
<code>&apos;1.1&apos;</code> or <code>&apos;1.0&apos;</code>.
Also <code>response.httpVersionMajor</code> is the first integer and
<code>response.httpVersionMinor</code> is the second.

</p>
<h3>response.headers<span><a class="mark" href="#all_response_headers_1" id="all_response_headers_1">#</a></span></h3>
<p>The response headers object.

</p>
<h3>response.trailers<span><a class="mark" href="#all_response_trailers_1" id="all_response_trailers_1">#</a></span></h3>
<p>The response trailers object. Only populated after the &apos;end&apos; event.

</p>
<h3>response.setEncoding(encoding=null)<span><a class="mark" href="#all_response_setencoding_encoding_null_1" id="all_response_setencoding_encoding_null_1">#</a></span></h3>
<p>Set the encoding for the response body. Either <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.
Defaults to <code>null</code>, which means that the <code>&apos;data&apos;</code> event will emit a <code>Buffer</code> object..

</p>
<h3>response.pause()<span><a class="mark" href="#all_response_pause_1" id="all_response_pause_1">#</a></span></h3>
<p>Pauses response from emitting events.  Useful to throttle back a download.

</p>
<h3>response.resume()<span><a class="mark" href="#all_response_resume_1" id="all_response_resume_1">#</a></span></h3>
<p>Resumes a paused response.
s
</p>
<h1>URL<span><a class="mark" href="#all_url" id="all_url">#</a></span></h1>
<p>Este módulo posee utilidades para la resolución y análisis de URL.
Para usarlo utilice <code>require(&apos;url&apos;)</code>.

</p>
<p>Analizar objetos URL tiene algo o mucho de los siguientes campos, dependiendo de
que exista o no en la cadena de URL. Las partes que no están en la cadena de URL
no se analizarán y no estarán presente en el objeto. Un ejemplo para la siguiente URL

</p>
<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>

</p>
<ul>
<li><p><code>href</code>: La dirección URL ha sido analizada desde un principio.</p>
<p>Ejemplo: <code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code></p>
</li>
<li><p><code>protocol</code>: El protocolo de petición (request).</p>
<p>Ejemplo: <code>&apos;http:&apos;</code></p>
</li>
<li><p><code>host</code>: Una parte del host de la URL completa, incluyendo la información del puerto y autentificación.</p>
<p>Ejemplo: <code>&apos;user:pass@host.com:8080&apos;</code></p>
</li>
<li><p><code>auth</code>: Parte de la información de autentificación de la URL.</p>
<p>Ejemplo: <code>&apos;user:pass&apos;</code></p>
</li>
<li><p><code>hostname</code>: Sólo la parte del nombre del host.</p>
<p>Ejemplo: <code>&apos;host.com&apos;</code></p>
</li>
<li><p><code>port</code>: El número de puerto del host.</p>
<p>Ejemplo: <code>&apos;8080&apos;</code></p>
</li>
<li><p><code>pathname</code>: La sección de la ruta de la URL, que viene después del host y antes de la consulta, incluyendo la barra inicial si está presente.</p>
<p>Ejemplo: <code>&apos;/p/a/t/h&apos;</code></p>
</li>
<li><p><code>search</code>: La parte de &apos;cadena de consulta&apos; de la URL, incluyendo el signo de interrogación principal.</p>
<p>Ejemplo: <code>&apos;?query=string&apos;</code></p>
</li>
<li><p><code>query</code>: La parte de cualquier &apos;parámetro&apos; de la cadena de consulta, o un parser de un objeto de cadena de consulta.</p>
<p>Ejemplo: <code>&apos;query=string&apos;</code> o <code>{&apos;query&apos;:&apos;string&apos;}</code></p>
</li>
<li><p><code>hash</code>: La parte del &apos;fragmento&apos; de la  URL incluyendo el símbolo de la libra.</p>
<p>Ejemplo: <code>&apos;#hash&apos;</code></p>
</li>
</ul>
<p>Los siguientes métodos son proporcionados por el módulo URL:

</p>
<h2>url.parse(urlStr, [parseQueryString], [slashesDenoteHost])<span><a class="mark" href="#all_url_parse_urlstr_parsequerystring_slashesdenotehost" id="all_url_parse_urlstr_parsequerystring_slashesdenotehost">#</a></span></h2>
<p>Toma una cadena de la URL, y la devuelve como un objeto.  Devuelve <code>true</code> como el segundo argumento  a
la cadena de consulta usando el módulo <code>querystring</code>.

</p>
<h3>url.format(urlObj)<span><a class="mark" href="#all_url_format_urlobj" id="all_url_format_urlobj">#</a></span></h3>
<p>Toma un parser de un objeto URL, y devuelve una cadena de URL.

</p>
<h2>url.resolve(from, to)<span><a class="mark" href="#all_url_resolve_from_to" id="all_url_resolve_from_to">#</a></span></h2>
<p>Toma una URL base, y el atributo href de la URL, y lo determina como un navegador sería la etiqueta anchor (enlace).

</p>
<h1>Cadena de consulta<span><a class="mark" href="#all_cadena_de_consulta" id="all_cadena_de_consulta">#</a></span></h1>
<p>Este módulo provee de utilidades para el tratamiento de cadenas de consultas.
Se ofrece los siguientes métodos:

</p>
<h2>querystring.stringify(obj, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)<span><a class="mark" href="#all_querystring_stringify_obj_sep_eq" id="all_querystring_stringify_obj_sep_eq">#</a></span></h2>
<p>Serializa un objeto a una cadena de consulta.
Opcionalmente reemplaza el separador por omisión y la asignación de caracteres.

</p>
<p>Ejemplo:

</p>
<pre><code>querystring.stringify({foo: &apos;bar&apos;})
// devuelve
&apos;foo=bar&apos;

querystring.stringify({foo: &apos;bar&apos;, baz: &apos;bob&apos;}, &apos;;&apos;, &apos;:&apos;)
// devuelve
&apos;foo:bar;baz:bob&apos;</code></pre>
<h2>querystring.parse(str, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)<span><a class="mark" href="#all_querystring_parse_str_sep_eq" id="all_querystring_parse_str_sep_eq">#</a></span></h2>
<p>Deserializa una cadena de consulta a un objeto.
Opcionamente puede reemplazar el separador por omisión y asignar caracteres.

</p>
<p>Ejemplo:

</p>
<pre><code>querystring.parse(&apos;a=b&amp;b=c&apos;)
// returns
{ a: &apos;b&apos;, b: &apos;c&apos; }</code></pre>
<h2>querystring.escape<span><a class="mark" href="#all_querystring_escape" id="all_querystring_escape">#</a></span></h2>
<p>La función escape es usada por <code>querystring.stringify</code>,
para proporcionar reemplazos si es necesario.

</p>
<h2>querystring.unescape<span><a class="mark" href="#all_querystring_unescape" id="all_querystring_unescape">#</a></span></h2>
<p>La función unescape es usada por <code>querystring.parse</code>,
para proporcionar reemplazos  si es necesario.

</p>
<h1>Readline<span><a class="mark" href="#all_readline" id="all_readline">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>This module allows reading of a stream (such as STDIN) on a line-by-line basis.

</p>
<p>Note that once you&apos;ve invoked this module, your node program will not terminate
until you&apos;ve closed the interface, and the STDIN stream. Here&apos;s how to allow
your program to gracefully terminate:

</p>
<pre>
var readline = require(&apos;readline&apos;);

var i = readline.createInterface(process.sdtin, process.stdout, null);
i.question(&quot;What do you think of node.js?&quot;, function(answer) {
  //TODO: Log the answer in a database
  console.log(&quot;Thank you for your valuable feedback.&quot;);
  i.close();                //These two lines together allow the program to
  process.stdin.destroy();  //terminate. Without them, it would run forever.
});
</pre>

<h2>createInterface(input, output, completer)<span><a class="mark" href="#all_createinterface_input_output_completer" id="all_createinterface_input_output_completer">#</a></span></h2>
<p>Returns an interface object, which reads from input, and writes to output.
TODO: I think &quot;completer&quot; is used for tab-completion, but not sure.

</p>
<h2>interface.setPrompt(prompt, length)<span><a class="mark" href="#all_interface_setprompt_prompt_length" id="all_interface_setprompt_prompt_length">#</a></span></h2>
<p>TODO

</p>
<h2>interface.prompt()<span><a class="mark" href="#all_interface_prompt" id="all_interface_prompt">#</a></span></h2>
<p>TODO: Appears to trigger showing the prompt.

</p>
<h2>interface.question(query, cb)<span><a class="mark" href="#all_interface_question_query_cb" id="all_interface_question_query_cb">#</a></span></h2>
<p>Displays the query to the user, and then calls the callback after the user
has typed in their response.

</p>
<p>Example usage:

</p>
<pre>
interface.question(&quot;What is your favorite food?&quot;, function(answer) {
  console.log(&quot;Oh, so your favorite food is &quot; + answer);
});
</pre>

<h3>interface.close()<span><a class="mark" href="#all_interface_close" id="all_interface_close">#</a></span></h3>
<p>TODO

</p>
<h2>interface.pause()<span><a class="mark" href="#all_interface_pause" id="all_interface_pause">#</a></span></h2>
<p>TODO

</p>
<h2>interface.resume()<span><a class="mark" href="#all_interface_resume" id="all_interface_resume">#</a></span></h2>
<p>TODO

</p>
<h2>interface.write()<span><a class="mark" href="#all_interface_write" id="all_interface_write">#</a></span></h2>
<p>TODO

</p>
<h1>REPL<span><a class="mark" href="#all_repl" id="all_repl">#</a></span></h1>
<p>Read-Eval-Print-Loop (REPL) está disponible como un programa independiente y fácilmente
puede incluirse en otros programas.  REPL proporciona una forma interactiva de ejecutar
JavaScript y ver los resultados.  Puede ser utilizado para la depuración, pruebas, o
simplemente para probar cosas.

</p>
<p>Debe ejectuarlo en <code>node</code> sin singún argumento desde la línea de comandos, debe posicionarse 
dentro de REPL. Posee la edición simple de líneas de emacs.

</p>
<pre><code>mjr:~$ node
Type &apos;.help&apos; for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>
<p>Para editores avanzados, inice node con la variable de entorno <code>NODE_NO_READLINE=1</code>.
Se iniciará la configuración de REPL en la terminal y l permite utilizarlo con <code>rlwrap</code>.

</p>
<p>Por ejemplo, puede añadir lo siguiente al fichero bashrc:

</p>
<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>
<h2>repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined])<span><a class="mark" href="#all_repl_start_prompt_stream_eval_useglobal_ignoreundefined" id="all_repl_start_prompt_stream_eval_useglobal_ignoreundefined">#</a></span></h2>
<p>Inicia REPL con el <code>prompt</code> como el prompt y  el <code>stream</code> para todo los procesos de I/O (Entrada/Salida). 
<code>prompt</code> es opcional y por omisión es <code>&gt; </code>.  <code>stream</code> es opcional y por omisión es 
<code>process.stdin</code>. <code>eval</code> is optional too and defaults to async wrapper for
<code>eval()</code>.

</p>
<p>If <code>useGlobal</code> is set to true, then the repl will use the global object,
instead of running scripts in a separate context. Defaults to <code>false</code>.

</p>
<p>If <code>ignoreUndefined</code> is set to true, then the repl will not output return value
of command if it&apos;s <code>undefined</code>. Defaults to <code>false</code>.

</p>
<p>You can use your own <code>eval</code> function if it has following signature:

</p>
<pre><code>function eval(cmd, callback) {
  callback(null, result);
}</code></pre>
<p>Multiples REPLs pueden iniciar con una misma instancia de node.  Cada
uno de ellos comparten el objeto global, pero tendrán un único proceso de I/O.

</p>
<p>Acontinuación un ejemplo que inicia REPL en stdin, un socket en Unix, y un socket en TCP:

</p>
<pre><code>var net = require(&quot;net&quot;),
    repl = require(&quot;repl&quot;);

connections = 0;

repl.start(&quot;node via stdin&gt; &quot;);

net.createServer(function (socket) {
  connections += 1;
  repl.start(&quot;node via Unix socket&gt; &quot;, socket);
}).listen(&quot;/tmp/node-repl-sock&quot;);

net.createServer(function (socket) {
  connections += 1;
  repl.start(&quot;node via TCP socket&gt; &quot;, socket);
}).listen(5001);</code></pre>
<p>Ejecutando el programa desde la línea de comando iniciará REPL en stdin.  Otros
clientes REPL pueden conectarse a través de un socket Unix o TCP. <code>telnet</code> es útil
para la conexión de sockets TCP, y <code>socat</code> puede ser conectar ambos sockets Unix y
TCP.

</p>
<p>Al iniciar REPL desde un socket Unix basado en una instancia de stdin, puede 
conectarse a un  proceso en ejecución de node sin reiniciar el mismo.


</p>
<h2>Características de REPL<span><a class="mark" href="#all_caracter_sticas_de_repl" id="all_caracter_sticas_de_repl">#</a></span></h2>
<!-- type=misc -->

<p>Dentro de REPL, presione Control+D para salir.  Expresiones de varias líneas pueden ser
ingresadas.

</p>
<p>La variable especial <code>_</code> (underscore) contiene el resultado de la última expresión.

</p>
<pre><code>&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
&gt; _.length
3
&gt; _ += 1
4</code></pre>
<p>REPL proporciona acceso a cualquier variable de ámbito global. Puede exponer 
una variable a REPL explícitamente y asignarle a un contexto de objeto asociado 
con cada <code>REPLServer</code>.  Por ejemplo:

</p>
<pre><code>// repl_test.js
var repl = require(&quot;repl&quot;),
    msg = &quot;message&quot;;

repl.start().context.m = msg;</code></pre>
<p>Los sucesos en el objeto <code>context</code> aparecen como local en REPL:

</p>
<pre><code>mjr:~$ node repl_test.js
&gt; m
&apos;message&apos;</code></pre>
<p>Hay algunos comandos especiales de REPL:

</p>
<ul>
<li><code>.break</code> - Si  bien ingresar expresiones en varias líneas, a veces, pueden perderse
o simplemente no son tomados en cuenta. <code>.break</code> comenzará de nuevo.</li>
<li><code>.clear</code> - Restablece el objeto <code>context</code> a un objeto vacío y borra cualquier
expresión de varias líneas.</li>
<li><code>.exit</code> - Cierra los stream de I/O, que hará que REPL termine.</li>
<li><code>.help</code> - Muestra la lista de comandos especiales.</li>
<li><code>.save</code> - Guarda la sesión actual de REPL en un fichero<blockquote>
<p>.save ./file/to/save.js</p>
</blockquote>
</li>
<li><code>.load</code> - Carga un fichero en la sesión actual de REPL.<blockquote>
<p>.load ./file/to/load.js  </p>
</blockquote>
</li>
</ul>
<p>Lo siguiente son combinaciones del teclado para el uso especial de REPL:

</p>
<ul>
<li><code>&lt;ctrl&gt;C</code> - Similar a la tecla <code>break</code>. Termina el comando
actual. Presione dos veces en la línea para forzar la salida.</li>
<li><code>&lt;ctrl&gt;D</code> - Similar a la tecla <code>.exit</code>.</li>
</ul>
<h1>Executing JavaScript<span><a class="mark" href="#all_executing_javascript" id="all_executing_javascript">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!--name=vm-->

<p>You can access this module with:

</p>
<pre><code>var vm = require(&apos;vm&apos;);</code></pre>
<p>JavaScript code can be compiled and run immediately or compiled, saved, and run later.


</p>
<h2>vm.runInThisContext(code, [filename])<span><a class="mark" href="#all_vm_runinthiscontext_code_filename" id="all_vm_runinthiscontext_code_filename">#</a></span></h2>
<p><code>vm.runInThisContext()</code> compiles <code>code</code>, runs it and returns the result. Running
code does not have access to local scope. <code>filename</code> is optional, it&apos;s used only
in stack traces.

</p>
<p>Example of using <code>vm.runInThisContext</code> and <code>eval</code> to run the same code:

</p>
<pre><code>var localVar = 123,
    usingscript, evaled,
    vm = require(&apos;vm&apos;);

usingscript = vm.runInThisContext(&apos;localVar = 1;&apos;,
  &apos;myfile.vm&apos;);
console.log(&apos;localVar: &apos; + localVar + &apos;, usingscript: &apos; +
  usingscript);
evaled = eval(&apos;localVar = 1;&apos;);
console.log(&apos;localVar: &apos; + localVar + &apos;, evaled: &apos; +
  evaled);

// localVar: 123, usingscript: 1
// localVar: 1, evaled: 1</code></pre>
<p><code>vm.runInThisContext</code> does not have access to the local scope, so <code>localVar</code> is unchanged.
<code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.

</p>
<p>In case of syntax error in <code>code</code>, <code>vm.runInThisContext</code> emits the syntax error to stderr
and throws an exception.


</p>
<h2>vm.runInNewContext(code, [sandbox], [filename])<span><a class="mark" href="#all_vm_runinnewcontext_code_sandbox_filename" id="all_vm_runinnewcontext_code_sandbox_filename">#</a></span></h2>
<p><code>vm.runInNewContext</code> compiles <code>code</code>, then runs it in <code>sandbox</code> and returns the
result. Running code does not have access to local scope. The object <code>sandbox</code>
will be used as the global object for <code>code</code>.
<code>sandbox</code> and <code>filename</code> are optional, <code>filename</code> is only used in stack traces.

</p>
<p>Example: compile and execute code that increments a global variable and sets a new one.
These globals are contained in the sandbox.

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    sandbox = {
      animal: &apos;cat&apos;,
      count: 2
    };

vm.runInNewContext(&apos;count += 1; name = &quot;kitty&quot;&apos;, sandbox, &apos;myfile.vm&apos;);
console.log(util.inspect(sandbox));

// { animal: &apos;cat&apos;, count: 3, name: &apos;kitty&apos; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>vm.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.

</p>
<p>In case of syntax error in <code>code</code>, <code>vm.runInNewContext</code> emits the syntax error to stderr
and throws an exception.

</p>
<h2>vm.runInContext(code, context, [filename])<span><a class="mark" href="#all_vm_runincontext_code_context_filename" id="all_vm_runincontext_code_context_filename">#</a></span></h2>
<p><code>vm.runInContext</code> compiles <code>code</code>, then runs it in <code>context</code> and returns the
result. A (V8) context comprises a global object, together with a set of
built-in objects and functions. Running code does not have access to local scope
and the global object held within <code>context</code> will be used as the global object
for <code>code</code>.
<code>filename</code> is optional, it&apos;s used only in stack traces.

</p>
<p>Example: compile and execute code in a existing context.

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    initSandbox = {
      animal: &apos;cat&apos;,
      count: 2
    },
    context = vm.createContext(initSandbox);

vm.runInContext(&apos;count += 1; name = &quot;CATT&quot;&apos;, context, &apos;myfile.vm&apos;);
console.log(util.inspect(context));

// { animal: &apos;cat&apos;, count: 3, name: &apos;CATT&apos; }</code></pre>
<p>Note that <code>createContext</code> will perform a shallow clone of the supplied sandbox object in order to
initialise the global object of the freshly constructed context.

</p>
<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>vm.runInContext</code> is quite useful, but safely running untrusted code
requires a separate process.

</p>
<p>In case of syntax error in <code>code</code>, <code>vm.runInContext</code> emits the syntax error to stderr
and throws an exception.

</p>
<h2>vm.createContext([initSandbox])<span><a class="mark" href="#all_vm_createcontext_initsandbox" id="all_vm_createcontext_initsandbox">#</a></span></h2>
<p><code>vm.createContext</code> creates a new context which is suitable for use as the 2nd argument of a subsequent
call to <code>vm.runInContext</code>. A (V8) context comprises a global object together with a set of
build-in objects and functions. The optional argument <code>initSandbox</code> will be shallow-copied
to seed the initial contents of the global object used by the context.

</p>
<h2>vm.createScript(code, [filename])<span><a class="mark" href="#all_vm_createscript_code_filename" id="all_vm_createscript_code_filename">#</a></span></h2>
<p><code>createScript</code> compiles <code>code</code> but does not run it. Instead, it returns a
<code>vm.Script</code> object representing this compiled code. This script can be run
later many times using methods below. The returned script is not bound to any
global object. It is bound before each run, just for that run. <code>filename</code> is
optional, it&apos;s only used in stack traces.

</p>
<p>In case of syntax error in <code>code</code>, <code>createScript</code> prints the syntax error to stderr
and throws an exception.


</p>
<h2>Class: Script<span><a class="mark" href="#all_class_script" id="all_class_script">#</a></span></h2>
<p>A class for running scripts.  Returned by vm.createScript.

</p>
<h3>script.runInThisContext()<span><a class="mark" href="#all_script_runinthiscontext" id="all_script_runinthiscontext">#</a></span></h3>
<p>Similar to <code>vm.runInThisContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInThisContext</code> runs the code of <code>script</code> and returns the result.
Running code does not have access to local scope, but does have access to the <code>global</code> object
(v8: in actual context).

</p>
<p>Example of using <code>script.runInThisContext</code> to compile code once and run it multiple times:

</p>
<pre><code>var vm = require(&apos;vm&apos;);

globalVar = 0;

var script = vm.createScript(&apos;globalVar += 1&apos;, &apos;myfile.vm&apos;);

for (var i = 0; i &lt; 1000 ; i += 1) {
  script.runInThisContext();
}

console.log(globalVar);

// 1000</code></pre>
<h3>script.runInNewContext([sandbox])<span><a class="mark" href="#all_script_runinnewcontext_sandbox" id="all_script_runinnewcontext_sandbox">#</a></span></h3>
<p>Similar to <code>vm.runInNewContext</code> a method of a precompiled <code>Script</code> object.
<code>script.runInNewContext</code> runs the code of <code>script</code> with <code>sandbox</code> as the global object and returns the result.
Running code does not have access to local scope. <code>sandbox</code> is optional.

</p>
<p>Example: compile code that increments a global variable and sets one, then execute this code multiple times.
These globals are contained in the sandbox.

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    sandbox = {
      animal: &apos;cat&apos;,
      count: 2
    };

var script = vm.createScript(&apos;count += 1; name = &quot;kitty&quot;&apos;, &apos;myfile.vm&apos;);

for (var i = 0; i &lt; 10 ; i += 1) {
  script.runInNewContext(sandbox);
}

console.log(util.inspect(sandbox));

// { animal: &apos;cat&apos;, count: 12, name: &apos;kitty&apos; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>script.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.
</p>
<h1>Child Process<span><a class="mark" href="#all_child_process" id="all_child_process">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>Node proporciona un <code>popen(3)</code> tri-direccional a través del
módulo <code>ChildProcess</code>.

</p>
<p>Es posible pasar un stream de datos a través del <code>stdin</code>, <code>stdout</code>, y
<code>stderr</code> del proceso hijo (child) de manera totalmente sin bloqueo.

</p>
<p>Para crear un proceso hijo utilice <code>require(&apos;child_process&apos;).spawn()</code> o
<code>require(&apos;child_process&apos;).fork()</code>.  La semántica de cada uno son un poco
diferente, y se explica a continuación.

</p>
<h2>Class: ChildProcess<span><a class="mark" href="#all_class_childprocess" id="all_class_childprocess">#</a></span></h2>
<p><code>ChildProcess</code> es <code>EventEmitter</code>.

</p>
<p>Los procesos hijo siempre tienen tres streams asociados a ellos. <code>child.stdin</code>,
<code>child.stdout</code>, y <code>child.stderr</code>.  These may be shared with the stdio
streams of the parent process, or they may be separate stream objects
which can be piped to and from.

</p>
<p>The ChildProcess class is not intended to be used directly.  Use the
<code>spawn()</code> or <code>fork()</code> methods to create a Child Process instance.

</p>
<h3>Evento:  &apos;exit&apos;<span><a class="mark" href="#all_evento_exit_1" id="all_evento_exit_1">#</a></span></h3>
<div class="signature"><ul>
<li><code>code</code> <span class="type">Number</span> the exit code, if it exited normally.</li>
<li><code>signal</code> <span class="type">String</span> the signal passed to kill the child process, if it
was killed by the parent.</li>
</div></ul>
<p>Este evento es emitido después de termine el proceso hijo. Si el proceso terminó
de manera normal, <code>code</code> es el código de salida final, en caso contrario <code>null</code>. Si
el proceso terminó debido al recibo de una señal, <code>signal</code> es el nombre string de
la señal, en caso contrario <code>null</code>.

</p>
<p>Véase <code>waitpid(2)</code>.

</p>
<h3>Event: &apos;disconnect&apos;<span><a class="mark" href="#all_event_disconnect" id="all_event_disconnect">#</a></span></h3>
<p>This event is emitted after using the <code>.disconnect()</code> method in the parent or
in the child. After disconnecting it is no longer possible to send messages.
An alternative way to check if you can send messages is to see if the
<code>child.connected</code> property is <code>true</code>.

</p>
<h3>child.stdin<span><a class="mark" href="#all_child_stdin" id="all_child_stdin">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p>Un <code>Stream de Escritura</code> que representa el <code>stdin</code> del proceso hijo.
Cerrar este stream vía <code>end()</code> a menudo causa que termine el proceso hijo.

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<h3>child.stdout<span><a class="mark" href="#all_child_stdout" id="all_child_stdout">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p>Un <code>Stream de Lectura</code> que representa el <code>stdout</code> del proceso hijo.

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<h3>child.stderr<span><a class="mark" href="#all_child_stderr" id="all_child_stderr">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p>Un <code>Stream de Lectura</code> que representa el <code>stderr</code> del proceso hijo.

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<h3>child.pid<span><a class="mark" href="#all_child_pid" id="all_child_pid">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Integer</span></li>
</div></ul>
<p>El PID del proceso hijo.

</p>
<p>Ejemplo:

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

console.log(&apos;Spawned child pid: &apos; + grep.pid);
grep.stdin.end();</code></pre>
<h3>child.kill([signal])<span><a class="mark" href="#all_child_kill_signal" id="all_child_kill_signal">#</a></span></h3>
<div class="signature"><ul>
<li><code>signal</code> <span class="type">String</span></li>
</div></ul>
<p>Manda una señal al proceso hijo. Si ningún argumento es dado, el proceso 
enviará <code>&apos;SIGTERM&apos;</code>. Véase <code>signal(7)</code> para una lista de señales disponibles.

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

grep.on(&apos;exit&apos;, function (code, signal) {
  console.log(&apos;child process terminated due to receipt of signal &apos;+signal);
});

// send SIGHUP to process
grep.kill(&apos;SIGHUP&apos;);</code></pre>
<p>Observa que mientras la función se llama <code>kill</code>, la señal entregada al proceso hijo
puede o no terminarlo.  <code>kill</code> realmente solo manda una señal a un proceso.

</p>
<p>Véase <code>kill(2)</code>


</p>
<h3>child.send(message, [sendHandle])<span><a class="mark" href="#all_child_send_message_sendhandle" id="all_child_send_message_sendhandle">#</a></span></h3>
<div class="signature"><ul>
<li><code>message</code> <span class="type">Object</span></li>
<li><code>sendHandle</code> <span class="type">Handle object</span></li>
</div></ul>
<p>Send a message (and, optionally, a handle object) to a child process.

</p>
<p>See <code>child_process.fork()</code> for details.

</p>
<h2>child_process.spawn(command, [args], [options])<span><a class="mark" href="#all_child_process_spawn_command_args_options" id="all_child_process_spawn_command_args_options">#</a></span></h2>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> The command to run</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See below)</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
</ul>
</li>
<li>return: <span class="type">ChildProcess object</span></li>
</div></ul>
<p>Inicia un nuevo proceso con el <code>command</code> proporcionado, con argumentos de linea de comandos <code>args</code>.
Si es omitido, <code>args</code> por defecto sera un Array vacío.

</p>
<p>El tercer argumento es usado para especificar opciones adicionales, que por defecto serán:

</p>
<pre><code>{ cwd: undefined,
  env: process.env
}</code></pre>
<p><code>cwd</code> te deja especificar el directorio actual de trabajo del cual es iniciado el proceso.
Usa <code>env</code> para especificar variables de entorno que serán visibles al nuevo proceso.

</p>
<p>Ejemplo ejecutando <code>ls -lh /usr</code>, capturando <code>stdout</code>, <code>stderr</code>, y el codigo de salida:

</p>
<pre><code>var util  = require(&apos;util&apos;),
    spawn = require(&apos;child_process&apos;).spawn,
    ls    = spawn(&apos;ls&apos;, [&apos;-lh&apos;, &apos;/usr&apos;]);

ls.stdout.on(&apos;data&apos;, function (data) {
  console.log(&apos;stdout: &apos; + data);
});

ls.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;stderr: &apos; + data);
});

ls.on(&apos;exit&apos;, function (code) {
  console.log(&apos;child process exited with code &apos; + code);
});</code></pre>
<p>Ejemplo: Una manera muy elaborada de ejecutar &apos;ps ax | grep ssh&apos;

</p>
<pre><code>var util  = require(&apos;util&apos;),
    spawn = require(&apos;child_process&apos;).spawn,
    ps    = spawn(&apos;ps&apos;, [&apos;ax&apos;]),
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

ps.stdout.on(&apos;data&apos;, function (data) {
  grep.stdin.write(data);
});

ps.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;ps stderr: &apos; + data);
});

ps.on(&apos;exit&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;ps process exited with code &apos; + code);
  }
  grep.stdin.end();
});

grep.stdout.on(&apos;data&apos;, function (data) {
  console.log(data);
});

grep.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;grep stderr: &apos; + data);
});

grep.on(&apos;exit&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;grep process exited with code &apos; + code);
  }
});</code></pre>
<p>Ejemplo de comprobar por ejecución fallida:

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    child = spawn(&apos;bad_command&apos;);

child.stderr.setEncoding(&apos;utf8&apos;);
child.stderr.on(&apos;data&apos;, function (data) {
  if (/^execvp\(\)/.test(data)) {
    console.log(&apos;Failed to start child process.&apos;);
  }
});</code></pre>
<p>Note that if spawn receives an empty options object, it will result in
spawning the process with an empty environment rather than using
<code>process.env</code>. This due to backwards compatibility issues with a deprecated
API.

</p>
<p>There is a deprecated option called <code>customFds</code> which allows one to specify
specific file descriptors for the stdio of the child process. This API was
not portable to all platforms and therefore removed.
With <code>customFds</code> it was possible to hook up the new process&apos; <code>[stdin, stdout,
stderr]</code> to existing streams; <code>-1</code> meant that a new stream should be created.
Use at your own risk.

</p>
<p>There are several internal options. In particular <code>stdinStream</code>,
<code>stdoutStream</code>, <code>stderrStream</code>. They are for INTERNAL USE ONLY. As with all
undocumented APIs in Node, they should not be used.

</p>
<p>Véase tambien: <code>child_process.exec()</code> y <code>child_process.fork()</code>

</p>
<h2>child_process.exec(command, [options], callback)<span><a class="mark" href="#all_child_process_exec_command_options_callback" id="all_child_process_exec_command_options_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> The command to run, with space-separated arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See below)</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
<li><code>encoding</code> <span class="type">String</span> (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span class="type">Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span class="type">Number</span> (Default: 200*1024)</li>
<li><code>killSignal</code> <span class="type">String</span> (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code>code</code> <span class="type">Integer</span> Exit code</li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</div></ul>
<p>Runs a command in a shell and buffers the output.

</p>
<pre><code>var util = require(&apos;util&apos;),
    exec = require(&apos;child_process&apos;).exec,
    child;

child = exec(&apos;cat *.js bad_file | wc -l&apos;,
  function (error, stdout, stderr) {
    console.log(&apos;stdout: &apos; + stdout);
    console.log(&apos;stderr: &apos; + stderr);
    if (error !== null) {
      console.log(&apos;exec error: &apos; + error);
    }
});</code></pre>
<p>El callback recibe los argumentos <code>(error, stdout, stderr)</code>. Cuando termina
con éxito, <code>error</code> sera <code>null</code>.  Cuando termina con error, <code>error</code> sera una 
instancia de <code>Error</code> y <code>err.code</code> sera el código de salida del proceso hijo,
y <code>err.signal</code> sera la señal que terminó el proceso.

</p>
<p>Hay un segundo argumento opcional para especificar varias opciones. Las 
opciones predeterminadas son

</p>
<pre><code>{ encoding: &apos;utf8&apos;,
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: &apos;SIGTERM&apos;,
  cwd: null,
  env: null }</code></pre>
<p>Si <code>timeout</code> es mayor que 0, entonces detendrá el proceso hijo 
si este se ejecuta mas de <code>timeout</code> milisegundos. El proceso hijo se detiene con
<code>killSignal</code> (por defecto: <code>&apos;SIGTERM&apos;</code>). <code>maxBuffer</code> especifica la mayor cantidad
de datos permitidos en stdout o stderr - si este valor se excede el proceso hijo
sera terminado.


</p>
<h2>child_process.execFile(file, args, options, callback)<span><a class="mark" href="#all_child_process_execfile_file_args_options_callback" id="all_child_process_execfile_file_args_options_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>file</code> <span class="type">String</span> The filename of the program to run</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See below)</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
<li><code>encoding</code> <span class="type">String</span> (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span class="type">Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span class="type">Number</span> (Default: 200*1024)</li>
<li><code>killSignal</code> <span class="type">String</span> (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code>code</code> <span class="type">Integer</span> Exit code</li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</div></ul>
<p>This is similar to <code>child_process.exec()</code> except it does not execute a
subshell but rather the specified file directly. This makes it slightly
leaner than <code>child_process.exec</code>. It has the same options.


</p>
<h2>child_process.fork(modulePath, [args], [options])<span><a class="mark" href="#all_child_process_fork_modulepath_args_options" id="all_child_process_fork_modulepath_args_options">#</a></span></h2>
<div class="signature"><ul>
<li><code>modulePath</code> <span class="type">String</span> The module to run in the child</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See below)</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
<li><code>encoding</code> <span class="type">String</span> (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span class="type">Number</span> (Default: 0)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code>code</code> <span class="type">Integer</span> Exit code</li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</div></ul>
<p>This is a special case of the <code>spawn()</code> functionality for spawning Node
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. The
channel is written to with <code>child.send(message, [sendHandle])</code> and messages
are received by a <code>&apos;message&apos;</code> event on the child.

</p>
<p>For example:

</p>
<pre><code>var cp = require(&apos;child_process&apos;);

var n = cp.fork(__dirname + &apos;/sub.js&apos;);

n.on(&apos;message&apos;, function(m) {
  console.log(&apos;PARENT got message:&apos;, m);
});

n.send({ hello: &apos;world&apos; });</code></pre>
<p>And then the child script, <code>&apos;sub.js&apos;</code> might look like this:

</p>
<pre><code>process.on(&apos;message&apos;, function(m) {
  console.log(&apos;CHILD got message:&apos;, m);
});

process.send({ foo: &apos;bar&apos; });</code></pre>
<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
will emit objects each time it receives a message on its channel.

</p>
<p>There is a special case when sending a <code>{cmd: &apos;NODE_foo&apos;}</code> message. All messages
containing a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in
the <code>message</code> event, since they are internal messages used by node core.
Messages containing the prefix are emitted in the <code>internalMessage</code> event, you
should by all means avoid using this feature, it may change without warranty.

</p>
<p>By default the spawned Node process will have the stdout, stderr associated
with the parent&apos;s. To change this behavior set the <code>silent</code> property in the
<code>options</code> object to <code>true</code>.

</p>
<p>These child Nodes are still whole new instances of V8. Assume at least 30ms
startup and 10mb memory for each new Node. That is, you cannot create many
thousands of them.

</p>
<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a handle object to
another process. Child will receive the handle as as second argument to the
<code>message</code> event. Here is an example of sending a handle:

</p>
<pre><code>var server = require(&apos;net&apos;).createServer();
var child = require(&apos;child_process&apos;).fork(__dirname + &apos;/child.js&apos;);
// Open up the server object and send the handle.
server.listen(1337, function() {
  child.send({ server: true }, server._handle);
});</code></pre>
<p>Here is an example of receiving the server handle and sharing it between
processes:

</p>
<pre><code>process.on(&apos;message&apos;, function(m, serverHandle) {
  if (serverHandle) {
    var server = require(&apos;net&apos;).createServer();
    server.listen(serverHandle);
  }
});</code></pre>
<p>To close the IPC connection between parent and child use the
<code>child.disconnect()</code> method. This allows the child to exit gracefully since
there is no IPC channel keeping it alive. When calling this method the
<code>disconnect</code> event will be emitted in both parent and child, and the
<code>connected</code> flag will be set to <code>false</code>. Please note that you can also call
<code>process.disconnect()</code> in the child process.
</p>
<h1>Assert<span><a class="mark" href="#all_assert" id="all_assert">#</a></span></h1>
<p>Este módulo es usado para escribir pruebas unitarias de sus aplicaciones, puede
acceder con <code>require(&apos;assert&apos;)</code>.

</p>
<h2>assert.fail(actual, expected, message, operator)<span><a class="mark" href="#all_assert_fail_actual_expected_message_operator" id="all_assert_fail_actual_expected_message_operator">#</a></span></h2>
<p>Evalua si <code>actual</code> es igual a <code>expected</code> usando el operador provisto.

</p>
<h2>assert.ok(value, [message])<span><a class="mark" href="#all_assert_ok_value_message" id="all_assert_ok_value_message">#</a></span></h2>
<p>Evalua si el valor es <code>true</code>, si es equivalente a <code>assert.equal(true, value, message);</code>

</p>
<h2>assert.equal(actual, expected, [message])<span><a class="mark" href="#all_assert_equal_actual_expected_message" id="all_assert_equal_actual_expected_message">#</a></span></h2>
<p>Evalua la igualdad con el operador de comparación ( <code>==</code> ).

</p>
<h2>assert.notEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notequal_actual_expected_message" id="all_assert_notequal_actual_expected_message">#</a></span></h2>
<p>Evalua la no igualdad con el operador de comparación en negación ( <code>!=</code> ).

</p>
<h2>assert.deepEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_deepequal_actual_expected_message" id="all_assert_deepequal_actual_expected_message">#</a></span></h2>
<p>Pruebas para las pruebas de afirmación de desigualdad profunda.

</p>
<h2>assert.notDeepEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notdeepequal_actual_expected_message" id="all_assert_notdeepequal_actual_expected_message">#</a></span></h2>
<p>Pruebas para cualquier desigualdad profunda.

</p>
<h2>assert.strictEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_strictequal_actual_expected_message" id="all_assert_strictequal_actual_expected_message">#</a></span></h2>
<p>Pruebas de igualdad estrictas, según lo determinado por el operador de igualdad estricto ( <code>===</code> )

</p>
<h2>assert.notStrictEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notstrictequal_actual_expected_message" id="all_assert_notstrictequal_actual_expected_message">#</a></span></h2>
<p>Pruebas de no igualdad estrictas, según lo determinado por el operador de no igualdad estricto ( <code>!==</code> )

</p>
<h2>assert.throws(block, [error], [message])<span><a class="mark" href="#all_assert_throws_block_error_message" id="all_assert_throws_block_error_message">#</a></span></h2>
<p>Se espera lanzar un <code>bloque</code>(block) de error. El <code>error</code> puede ser un constructor, expresión regular (regexp) o 
una función de validación.

</p>
<p>Validar instanceof usando el constructor:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  Error
);</code></pre>
<p>Validar un mensaje de error usando RegExp:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  /value/
);</code></pre>
<p>Error de validación personalizado:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  &quot;unexpected error&quot;
);</code></pre>
<h2>assert.doesNotThrow(block, [error], [message])<span><a class="mark" href="#all_assert_doesnotthrow_block_error_message" id="all_assert_doesnotthrow_block_error_message">#</a></span></h2>
<p>Se espera un <code>bloque</code> (block) y no produzca un error, vea assert.throws para más detalles.

</p>
<h2>assert.ifError(value)<span><a class="mark" href="#all_assert_iferror_value" id="all_assert_iferror_value">#</a></span></h2>
<p>Comprueba si el valor no es falso, se produce un lanzamiento si el valor es verdadero. Muy útil
cuando se prueba el primer argumento, <code>error</code> en los callbacks.

</p>
<h1>TTY (Terminal)<span><a class="mark" href="#all_tty_terminal" id="all_tty_terminal">#</a></span></h1>
<p>Utilice <code>require(&apos;tty&apos;)</code> para acceder al módulo.

</p>
<p>Ejemplo:

</p>
<pre><code>var tty = require(&apos;tty&apos;);
tty.setRawMode(true);
process.stdin.resume();
process.stdin.on(&apos;keypress&apos;, function(char, key) {
  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == &apos;c&apos;) {
    console.log(&apos;salida airosa&apos;);
    process.exit()
  }
});</code></pre>
<h2>tty.open(path, args=[])<span><a class="mark" href="#all_tty_open_path_args" id="all_tty_open_path_args">#</a></span></h2>
<p>Genera un nuevo proceso con el fichero ejecutable en la <code>ruta</code> como la sesión
actual a una nueva pseudo terminal.

</p>
<p>Devuelve un array <code>[slaveFD, childProcess]</code>. <code>slaveFD</code> es el descriptor de fichero
esclavo de la pseudo terminal. <code>childProcess</code> es un proceso hijo de un 
objeto.


</p>
<h2>tty.isatty(fd)<span><a class="mark" href="#all_tty_isatty_fd" id="all_tty_isatty_fd">#</a></span></h2>
<p>Devuelve <code>true</code> o <code>false</code> dependiendo si el <code>fd</code> es asociado con el
terminal.


</p>
<h2>tty.setRawMode(mode)<span><a class="mark" href="#all_tty_setrawmode_mode" id="all_tty_setrawmode_mode">#</a></span></h2>
<p><code>mode</code> debe ser <code>true</code> o <code>false</code>. Se establece las propiedades al proceso actual
de stdin fd para actuar ya sea como un dispositivo de modo sin formato o por omisión.


</p>
<h2>tty.setWindowSize(fd, row, col)<span><a class="mark" href="#all_tty_setwindowsize_fd_row_col" id="all_tty_setwindowsize_fd_row_col">#</a></span></h2>
<p><code>ioctl</code> ajusta la configuración de la ventana del descriptor de fichero.


</p>
<h2>tty.getWindowSize(fd)<span><a class="mark" href="#all_tty_getwindowsize_fd" id="all_tty_getwindowsize_fd">#</a></span></h2>
<p>Devuelve <code>[row, col]</code> associado a la TTY con el descriptor de fichero.



</p>
<h1>Zlib<span><a class="mark" href="#all_zlib" id="all_zlib">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<p>You can access this module with:

</p>
<pre><code>var zlib = require(&apos;zlib&apos;);</code></pre>
<p>This provides bindings to Gzip/Gunzip, Deflate/Inflate, and
DeflateRaw/InflateRaw classes.  Each class takes the same options, and
is a readable/writable Stream.

</p>
<h2>Examples<span><a class="mark" href="#all_examples" id="all_examples">#</a></span></h2>
<p>Compressing or decompressing a file can be done by piping an
fs.ReadStream into a zlib stream, then into an fs.WriteStream.

</p>
<pre><code>var gzip = zlib.createGzip();
var fs = require(&apos;fs&apos;);
var inp = fs.createReadStream(&apos;input.txt&apos;);
var out = fs.createWriteStream(&apos;input.txt.gz&apos;);

inp.pipe(gzip).pipe(out);</code></pre>
<p>Compressing or decompressing data in one step can be done by using
the convenience methods.

</p>
<pre><code>var input = &apos;.................................&apos;;
zlib.deflate(input, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString(&apos;base64&apos;));
  }
});

var buffer = new Buffer(&apos;eJzT0yMAAGTvBe8=&apos;, &apos;base64&apos;);
zlib.unzip(buffer, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString());
  }
});</code></pre>
<p>To use this module in an HTTP client or server, use the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a>
on requests, and the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a>
header on responses.

</p>
<p><strong>Note: these examples are drastically simplified to show
the basic concept.</strong>  Zlib encoding can be expensive, and the results
ought to be cached.  See <a href="#memory_Usage_Tuning">Memory Usage Tuning</a>
below for more information on the speed/memory/compression
tradeoffs involved in zlib usage.

</p>
<pre><code>// client request example
var zlib = require(&apos;zlib&apos;);
var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
var request = http.get({ host: &apos;izs.me&apos;,
                         path: &apos;/&apos;,
                         port: 80,
                         headers: { &apos;accept-encoding&apos;: &apos;gzip,deflate&apos; } });
request.on(&apos;response&apos;, function(response) {
  var output = fs.createWriteStream(&apos;izs.me_index.html&apos;);

  switch (response.headers[&apos;content-encoding&apos;]) {
    // or, just use zlib.createUnzip() to handle both cases
    case &apos;gzip&apos;:
      response.pipe(zlib.createGunzip()).pipe(output);
      break;
    case &apos;deflate&apos;:
      response.pipe(zlib.createInflate()).pipe(output);
      break;
    default:
      response.pipe(output);
      break;
  }
});

// server example
// Running a gzip operation on every request is quite expensive.
// It would be much more efficient to cache the compressed buffer.
var zlib = require(&apos;zlib&apos;);
var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
http.createServer(function(request, response) {
  var raw = fs.createReadStream(&apos;index.html&apos;);
  var acceptEncoding = request.headers[&apos;accept-encoding&apos;];
  if (!acceptEncoding) {
    acceptEncoding = &apos;&apos;;
  }

  // Note: this is not a conformant accept-encoding parser.
  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
  if (acceptEncoding.match(/\bdeflate\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;deflate&apos; });
    raw.pipe(zlib.createDeflate()).pipe(response);
  } else if (acceptEncoding.match(/\bgzip\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;gzip&apos; });
    raw.pipe(zlib.createGzip()).pipe(response);
  } else {
    response.writeHead(200, {});
    raw.pipe(response);
  }
}).listen(1337);</code></pre>
<h2>Constants<span><a class="mark" href="#all_constants" id="all_constants">#</a></span></h2>
<!--type=misc-->

<p>All of the constants defined in zlib.h are also defined on
<code>require(&apos;zlib&apos;)</code>.  They are described in more detail in the zlib
documentation.  See <a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a>
for more details.

</p>
<h2>zlib.createGzip([options])<span><a class="mark" href="#all_zlib_creategzip_options" id="all_zlib_creategzip_options">#</a></span></h2>
<p>Returns a new <a href="#zlib.Gzip">Gzip</a> object with an <a href="#options">options</a>.

</p>
<h2>zlib.createGunzip([options])<span><a class="mark" href="#all_zlib_creategunzip_options" id="all_zlib_creategunzip_options">#</a></span></h2>
<p>Returns a new <a href="#zlib.Gunzip">Gunzip</a> object with an <a href="#options">options</a>.

</p>
<h2>zlib.createDeflate([options])<span><a class="mark" href="#all_zlib_createdeflate_options" id="all_zlib_createdeflate_options">#</a></span></h2>
<p>Returns a new <a href="#zlib.Deflate">Deflate</a> object with an <a href="#options">options</a>.

</p>
<h2>zlib.createInflate([options])<span><a class="mark" href="#all_zlib_createinflate_options" id="all_zlib_createinflate_options">#</a></span></h2>
<p>Returns a new <a href="#zlib.Inflate">Inflate</a> object with an <a href="#options">options</a>.

</p>
<h2>zlib.createDeflateRaw([options])<span><a class="mark" href="#all_zlib_createdeflateraw_options" id="all_zlib_createdeflateraw_options">#</a></span></h2>
<p>Returns a new <a href="#zlib.DeflateRaw">DeflateRaw</a> object with an <a href="#options">options</a>.

</p>
<h2>zlib.createInflateRaw([options])<span><a class="mark" href="#all_zlib_createinflateraw_options" id="all_zlib_createinflateraw_options">#</a></span></h2>
<p>Returns a new <a href="#zlib.InflateRaw">InflateRaw</a> object with an <a href="#options">options</a>.

</p>
<h2>zlib.createUnzip([options])<span><a class="mark" href="#all_zlib_createunzip_options" id="all_zlib_createunzip_options">#</a></span></h2>
<p>Returns a new <a href="#zlib.Unzip">Unzip</a> object with an <a href="#options">options</a>.


</p>
<h2>Class: zlib.Gzip<span><a class="mark" href="#all_class_zlib_gzip" id="all_class_zlib_gzip">#</a></span></h2>
<p>Compress data using gzip.

</p>
<h2>Class: zlib.Gunzip<span><a class="mark" href="#all_class_zlib_gunzip" id="all_class_zlib_gunzip">#</a></span></h2>
<p>Decompress a gzip stream.

</p>
<h2>Class: zlib.Deflate<span><a class="mark" href="#all_class_zlib_deflate" id="all_class_zlib_deflate">#</a></span></h2>
<p>Compress data using deflate.

</p>
<h2>Class: zlib.Inflate<span><a class="mark" href="#all_class_zlib_inflate" id="all_class_zlib_inflate">#</a></span></h2>
<p>Decompress a deflate stream.

</p>
<h2>Class: zlib.DeflateRaw<span><a class="mark" href="#all_class_zlib_deflateraw" id="all_class_zlib_deflateraw">#</a></span></h2>
<p>Compress data using deflate, and do not append a zlib header.

</p>
<h2>Class: zlib.InflateRaw<span><a class="mark" href="#all_class_zlib_inflateraw" id="all_class_zlib_inflateraw">#</a></span></h2>
<p>Decompress a raw deflate stream.

</p>
<h2>Class: zlib.Unzip<span><a class="mark" href="#all_class_zlib_unzip" id="all_class_zlib_unzip">#</a></span></h2>
<p>Decompress either a Gzip- or Deflate-compressed stream by auto-detecting
the header.

</p>
<h2>Convenience Methods<span><a class="mark" href="#all_convenience_methods" id="all_convenience_methods">#</a></span></h2>
<!--type=misc-->

<p>All of these take a string or buffer as the first argument, and call the
supplied callback with <code>callback(error, result)</code>.  The
compression/decompression engine is created using the default settings
in all convenience methods.  To supply different options, use the
zlib classes directly.

</p>
<h2>zlib.deflate(buf, callback)<span><a class="mark" href="#all_zlib_deflate_buf_callback" id="all_zlib_deflate_buf_callback">#</a></span></h2>
<p>Compress a string with Deflate.

</p>
<h2>zlib.deflateRaw(buf, callback)<span><a class="mark" href="#all_zlib_deflateraw_buf_callback" id="all_zlib_deflateraw_buf_callback">#</a></span></h2>
<p>Compress a string with DeflateRaw.

</p>
<h2>zlib.gzip(buf, callback)<span><a class="mark" href="#all_zlib_gzip_buf_callback" id="all_zlib_gzip_buf_callback">#</a></span></h2>
<p>Compress a string with Gzip.

</p>
<h2>zlib.gunzip(buf, callback)<span><a class="mark" href="#all_zlib_gunzip_buf_callback" id="all_zlib_gunzip_buf_callback">#</a></span></h2>
<p>Decompress a raw Buffer with Gunzip.

</p>
<h2>zlib.inflate(buf, callback)<span><a class="mark" href="#all_zlib_inflate_buf_callback" id="all_zlib_inflate_buf_callback">#</a></span></h2>
<p>Decompress a raw Buffer with Inflate.

</p>
<h2>zlib.inflateRaw(buf, callback)<span><a class="mark" href="#all_zlib_inflateraw_buf_callback" id="all_zlib_inflateraw_buf_callback">#</a></span></h2>
<p>Decompress a raw Buffer with InflateRaw.

</p>
<h2>zlib.unzip(buf, callback)<span><a class="mark" href="#all_zlib_unzip_buf_callback" id="all_zlib_unzip_buf_callback">#</a></span></h2>
<p>Decompress a raw Buffer with Unzip.

</p>
<h2>Options<span><a class="mark" href="#all_options" id="all_options">#</a></span></h2>
<!--type=misc-->

<p>Each class takes an options object.  All options are optional.  (The
convenience methods use the default settings for all options.)

</p>
<p>Note that some options are only
relevant when compressing, and are ignored by the decompression classes.

</p>
<ul>
<li>chunkSize (default: 16*1024)</li>
<li>windowBits</li>
<li>level (compression only)</li>
<li>memLevel (compression only)</li>
<li>strategy (compression only)</li>
<li>dictionary (deflate/inflate only, empty dictionary by default)</li>
</ul>
<p>See the description of <code>deflateInit2</code> and <code>inflateInit2</code> at
</p>
<p><a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> for more information on these.

</p>
<h2>Memory Usage Tuning<span><a class="mark" href="#all_memory_usage_tuning" id="all_memory_usage_tuning">#</a></span></h2>
<!--type=misc-->

<p>From <code>zlib/zconf.h</code>, modified to node&apos;s usage:

</p>
<p>The memory requirements for deflate are (in bytes):

</p>
<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>
<p>that is: 128K for windowBits=15  +  128K for memLevel = 8
(default values) plus a few kilobytes for small objects.

</p>
<p>For example, if you want to reduce
the default memory requirements from 256K to 128K, set the options to:

</p>
<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>
<p>Of course this will generally degrade compression (there&apos;s no free lunch).

</p>
<p>The memory requirements for inflate are (in bytes)

</p>
<pre><code>1 &lt;&lt; windowBits</code></pre>
<p>that is, 32K for windowBits=15 (default value) plus a few kilobytes
for small objects.

</p>
<p>This is in addition to a single internal output slab buffer of size
<code>chunkSize</code>, which defaults to 16K.

</p>
<p>The speed of zlib compression is affected most dramatically by the
<code>level</code> setting.  A higher level will result in better compression, but
will take longer to complete.  A lower level will result in less
compression, but will be much faster.

</p>
<p>In general, greater memory usage options will mean that node has to make
fewer calls to zlib, since it&apos;ll be able to process more data in a
single <code>write</code> operation.  So, this is another factor that affects the
speed, at the cost of memory usage.

</p>
<h1>Módulo os<span><a class="mark" href="#all_m_dulo_os" id="all_m_dulo_os">#</a></span></h1>
<p>Utilice <code>require(&apos;os&apos;)</code> para acceder al módulo.

</p>
<h2>os.hostname()<span><a class="mark" href="#all_os_hostname" id="all_os_hostname">#</a></span></h2>
<p>Devuelve el hostname del sistema operativo.

</p>
<h2>os.type()<span><a class="mark" href="#all_os_type" id="all_os_type">#</a></span></h2>
<p>Devuelve el nombre del sistema operativo.

</p>
<h2>os.release()<span><a class="mark" href="#all_os_release" id="all_os_release">#</a></span></h2>
<p>Devuelve la versión del sistema operativo.

</p>
<h2>os.uptime()<span><a class="mark" href="#all_os_uptime" id="all_os_uptime">#</a></span></h2>
<p>Devuelve el uptime en segundos del sistema.

</p>
<h2>os.loadavg()<span><a class="mark" href="#all_os_loadavg" id="all_os_loadavg">#</a></span></h2>
<p>Devuelve un array conteniendo los promedios en 1, 5, y 15 minutos de carga.

</p>
<h2>os.totalmem()<span><a class="mark" href="#all_os_totalmem" id="all_os_totalmem">#</a></span></h2>
<p>Devuelve la cantidad total en memoria del sistema en bytes

</p>
<h2>os.freemem()<span><a class="mark" href="#all_os_freemem" id="all_os_freemem">#</a></span></h2>
<p>Devuelve la cantidad de memoria libre del sistema en bytes.

</p>
<h2>os.cpus()<span><a class="mark" href="#all_os_cpus" id="all_os_cpus">#</a></span></h2>
<p>Devuelve un array de objetos que contiene información acerca de cada CPU/core instalado: modelo, velocidad (en MHz), y los tiempos (un objeto que contiene el número de CPU usado por: usuario, nice, sys, idle, e irq).

</p>
<p>Ejemplo de inspección de os.cpus:

</p>
<pre><code>[ { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>
<h1>Depurador<span><a class="mark" href="#all_depurador" id="all_depurador">#</a></span></h1>
<pre><code>Stability: 3 - Stable</code></pre>
<!-- type=misc -->

<p>V8 viene con el complemento depurador (debugger), el cual puede ser accedido desde fuera 
del proceso vía el <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">protocolo TCP</a>.
Node posee un cliente incorporado para el depurador. Para usarlo, inicie Node con el argumento
<code>debug</code>; y aparecerá:

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt;</code></pre>
<p>El cliente depurador de Node no soporta toda una gama de comandos, pero
para cosas sencillas y tareas de inspección es posible su uso. Al poner la declaración <code>debugger;</code>
en el código fuente del script, permitirá un punto de interrupción.

</p>
<p>Por ejemplo, supongamos que <code>myscript.js</code> era así:

</p>
<pre><code>// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log(&quot;mundo&quot;);
}, 1000);
console.log(&quot;hola&quot;);</code></pre>
<p>Entonces una vez que el depurador se ejecute, se generará un break en la línea 4.

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt; cont
&lt; hello
break in /home/indutny/Code/git/indutny/myscript.js:3
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
debug&gt; next
break in /home/indutny/Code/git/indutny/myscript.js:4
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
debug&gt; repl
Press Ctrl + C to leave debug repl
&gt; x
5
&gt; 2+2
4
debug&gt; next
&lt; world
break in /home/indutny/Code/git/indutny/myscript.js:5
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
  7
debug&gt; quit
%</code></pre>
<p>El comando <code>repl</code> te permite evaluar el código remotamente. El comando <code>next</code> 
continúa la siguiente línea. Hay otros comandos disponibles y algunos más por venir de
tipo ayuda. Escriba <code>help</code> para ver otros comandos.

</p>
<h2>Watchers<span><a class="mark" href="#all_watchers" id="all_watchers">#</a></span></h2>
<p>You can watch expression and variable values while debugging your code.
On every breakpoint each expression from the watchers list will be evaluated
in the current context and displayed just before the breakpoint&apos;s source code
listing.

</p>
<p>To start watching an expression, type <code>watch(&quot;my_expression&quot;)</code>. <code>watchers</code>
prints the active watchers. To remove a watcher, type
<code>unwatch(&quot;my_expression&quot;)</code>.

</p>
<h2>Commands reference<span><a class="mark" href="#all_commands_reference" id="all_commands_reference">#</a></span></h2>
<h3>Stepping<span><a class="mark" href="#all_stepping" id="all_stepping">#</a></span></h3>
<ul>
<li><code>cont</code>, <code>c</code> - Continue execution</li>
<li><code>next</code>, <code>n</code> - Step next</li>
<li><code>step</code>, <code>s</code> - Step in</li>
<li><code>out</code>, <code>o</code> - Step out</li>
<li><code>pause</code> - Pause running code (like pause button in Developer TOols)</li>
</ul>
<h3>Breakpoints<span><a class="mark" href="#all_breakpoints" id="all_breakpoints">#</a></span></h3>
<div class="signature"><ul>
<li><code>setBreakpoint()</code>, <code>sb()</code> - Set breakpoint on current line</li>
<li><code>setBreakpoint(line)</code>, <code>sb(line)</code> - Set breakpoint on specific line</li>
<li><code>setBreakpoint(&apos;fn()&apos;)</code>, <code>sb(...)</code> - Set breakpoint on a first statement in
functions body</li>
<li><code>setBreakpoint(&apos;script.js&apos;, 1)</code>, <code>sb(...)</code> - Set breakpoint on first line of
script.js</li>
<li><code>clearBreakpoint</code>, <code>cb(...)</code> - Clear breakpoint</li>
</div></ul>
<h3>Info<span><a class="mark" href="#all_info" id="all_info">#</a></span></h3>
<div class="signature"><ul>
<li><code>backtrace</code>, <code>bt</code> - Print backtrace of current execution frame</li>
<li><code>list(5)</code> - List scripts source code with 5 line context (5 lines before and
after)</li>
<li><code>watch(expr)</code> - Add expression to watch list</li>
<li><code>unwatch(expr)</code> - Remove expression from watch list</li>
<li><code>watchers</code> - List all watchers and their values (automatically listed on each
breakpoint)</li>
<li><code>repl</code> - Open debugger&apos;s repl for evaluation in debugging script&apos;s context</li>
</div></ul>
<h3>Execution control<span><a class="mark" href="#all_execution_control" id="all_execution_control">#</a></span></h3>
<div class="signature"><ul>
<li><code>run</code> - Run script (automatically runs on debugger&apos;s start)</li>
<li><code>restart</code> - Restart script</li>
<li><code>kill</code> - Kill script</li>
</div></ul>
<h3>Various<span><a class="mark" href="#all_various" id="all_various">#</a></span></h3>
<div class="signature"><ul>
<li><code>scripts</code> - List all loaded scripts</li>
<li><code>version</code> - Display v8&apos;s version</li>
</div></ul>
<h2>Uso avanzado<span><a class="mark" href="#all_uso_avanzado" id="all_uso_avanzado">#</a></span></h2>
<p>El depurador V8 puede ser habilitado y accedido ya sea al iniciar Node con el 
comando <code>--debug</code> o al señalar un proceso en Node existente 
con <code>SIGUSR1</code>.
</p>
<h1>Cluster<span><a class="mark" href="#all_cluster" id="all_cluster">#</a></span></h1>
<pre><code>Stability: 1 - Experimental</code></pre>
<p>A single instance of Node runs in a single thread. To take advantage of
multi-core systems the user will sometimes want to launch a cluster of Node
processes to handle the load.

</p>
<p>The cluster module allows you to easily create a network of processes that
all share server ports.

</p>
<pre><code>var cluster = require(&apos;cluster&apos;);
var http = require(&apos;http&apos;);
var numCPUs = require(&apos;os&apos;).cpus().length;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on(&apos;death&apos;, function(worker) {
    console.log(&apos;worker &apos; + worker.pid + &apos; died&apos;);
  });
} else {
  // Workers can share any TCP connection
  // In this case its a HTTP server
  http.createServer(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
  }).listen(8000);
}</code></pre>
<p>Running node will now share port 8000 between the workers:

</p>
<pre><code>% node server.js
Worker 2438 online
Worker 2437 online</code></pre>
<p>This feature was introduced recently, and may change in future versions.
Please try it out and provide feedback.

</p>
<h2>cluster.settings<span><a class="mark" href="#all_cluster_settings" id="all_cluster_settings">#</a></span></h2>
<div class="signature"><ul>
<li><span class="type">Object</span><ul>
<li><code>exec</code> <span class="type">String</span> file path to worker file.  (Default=<code>__filename</code>)</li>
<li><code>args</code> <span class="type">Array</span> string arguments passed to worker.
(Default=<code>process.argv.slice(2)</code>)</li>
<li><code>silent</code> <span class="type">Boolean</span> whether or not to send output to parent&apos;s stdio.
(Default=<code>false</code>)</li>
</ul>
</li>
</div></ul>
<p>All settings set by the <code>.setupMaster</code> is stored in this settings object.
This object is not supposed to be change or set manually, by you.

</p>
<h2>cluster.isMaster<span><a class="mark" href="#all_cluster_ismaster" id="all_cluster_ismaster">#</a></span></h2>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<p>True if the process is a master. This is determined
by the <code>process.env.NODE_UNIQUE_ID</code>. If <code>process.env.NODE_UNIQUE_ID</code> is
undefined, then <code>isMaster</code> is <code>true</code>.

</p>
<h2>cluster.isWorker<span><a class="mark" href="#all_cluster_isworker" id="all_cluster_isworker">#</a></span></h2>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<p>This boolean flag is true if the process is a worker forked from a master.
If the <code>process.env.NODE_UNIQUE_ID</code> is set to a value, then
<code>isWorker</code> is <code>true</code>.

</p>
<h2>Event: &apos;fork&apos;<span><a class="mark" href="#all_event_fork" id="all_event_fork">#</a></span></h2>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>When a new worker is forked the cluster module will emit a &apos;fork&apos; event.
This can be used to log worker activity, and create you own timeout.

</p>
<pre><code>var timeouts = [];
var errorMsg = function () {
  console.error(&quot;Something must be wrong with the connection ...&quot;);
});

cluster.on(&apos;fork&apos;, function (worker) {
  timeouts[worker.uniqueID] = setTimeout(errorMsg, 2000);
});
cluster.on(&apos;listening&apos;, function (worker) {
  clearTimeout(timeouts[worker.uniqueID]);
});
cluster.on(&apos;death&apos;, function (worker) {
  clearTimeout(timeouts[worker.uniqueID]);
  errorMsg();
});</code></pre>
<h2>Event: &apos;online&apos;<span><a class="mark" href="#all_event_online" id="all_event_online">#</a></span></h2>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>After forking a new worker, the worker should respond with a online message.
When the master receives a online message it will emit such event.
The difference between &apos;fork&apos; and &apos;online&apos; is that fork is emitted when the
master tries to fork a worker, and &apos;online&apos; is emitted when the worker is
being executed.

</p>
<pre><code>cluster.on(&apos;online&apos;, function (worker) {
  console.log(&quot;Yay, the worker responded after it was forked&quot;);
});</code></pre>
<h2>Event: &apos;listening&apos;<span><a class="mark" href="#all_event_listening_1" id="all_event_listening_1">#</a></span></h2>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>When calling <code>listen()</code> from a worker, a &apos;listening&apos; event is automatically assigned
to the server instance. When the server is listening a message is send to the master
where the &apos;listening&apos; event is emitted.

</p>
<pre><code>cluster.on(&apos;listening&apos;, function (worker) {
  console.log(&quot;We are now connected&quot;);
});</code></pre>
<h2>Event: &apos;death&apos;<span><a class="mark" href="#all_event_death" id="all_event_death">#</a></span></h2>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>When any of the workers die the cluster module will emit the &apos;death&apos; event.
This can be used to restart the worker by calling <code>fork()</code> again.

</p>
<pre><code>cluster.on(&apos;death&apos;, function(worker) {
  console.log(&apos;worker &apos; + worker.pid + &apos; died. restart...&apos;);
  cluster.fork();
});</code></pre>
<h2>Event: &apos;setup&apos;<span><a class="mark" href="#all_event_setup" id="all_event_setup">#</a></span></h2>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>When the <code>.setupMaster()</code> function has been executed this event emits.
If <code>.setupMaster()</code> was not executed before <code>fork()</code> this function will
call <code>.setupMaster()</code> with no arguments.

</p>
<h2>cluster.setupMaster([settings])<span><a class="mark" href="#all_cluster_setupmaster_settings" id="all_cluster_setupmaster_settings">#</a></span></h2>
<div class="signature"><ul>
<li><code>settings</code> <span class="type">Object</span><ul>
<li><code>exec</code> <span class="type">String</span> file path to worker file.  (Default=<code>__filename</code>)</li>
<li><code>args</code> <span class="type">Array</span> string arguments passed to worker.
(Default=<code>process.argv.slice(2)</code>)</li>
<li><code>silent</code> <span class="type">Boolean</span> whether or not to send output to parent&apos;s stdio.
(Default=<code>false</code>)</li>
</ul>
</li>
</div></ul>
<p>The <code>setupMaster</code> is used to change the default &apos;fork&apos; behavior. It takes
one option object argument.

</p>
<p>Example:

</p>
<pre><code>var cluster = require(&quot;cluster&quot;);
cluster.setupMaster({
  exec : &quot;worker.js&quot;,
  args : [&quot;--use&quot;, &quot;https&quot;],
  silent : true
});
cluster.autoFork();</code></pre>
<h2>cluster.fork([env])<span><a class="mark" href="#all_cluster_fork_env" id="all_cluster_fork_env">#</a></span></h2>
<div class="signature"><ul>
<li><code>env</code> <span class="type">Object</span> Key/value pairs to add to child process environment.</li>
<li>return <span class="type">Worker object</span></li>
</div></ul>
<p>Spawn a new worker process. This can only be called from the master process.

</p>
<h2>cluster.settings<span><a class="mark" href="#all_cluster_settings_1" id="all_cluster_settings_1">#</a></span></h2>
<div class="signature"><ul>
<li><span class="type">Object</span><ul>
<li><code>exec</code> <span class="type">String</span> file path to worker file.  Default: <code>__filename</code></li>
<li><code>args</code> <span class="type">Array</span> string arguments passed to worker.
(Default=<code>process.argv.slice(2)</code>)</li>
<li><code>silent</code> <span class="type">Boolean</span> whether or not to send output to parent&apos;s stdio.
(Default=<code>false</code>)</li>
</ul>
</li>
</div></ul>
<p>All settings set by the <code>.setupMaster</code> is stored in this settings object.
This object is not supposed to be change or set manually.

</p>
<h2>cluster.workers<span><a class="mark" href="#all_cluster_workers" id="all_cluster_workers">#</a></span></h2>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>In the cluster all living worker objects are stored in this object by there
<code>uniqueID</code> as the key. This makes it easy to loop through all living workers.

</p>
<pre><code>// Go through all workers
function eachWorker(callback) {
  for (var uniqueID in cluster.workers) {
    callback(cluster.workers[uniqueID]);
  }
}
eachWorker(function (worker) {
  worker.send(&apos;big announcement to all workers&apos;);
});</code></pre>
<p>Should you wish to reference a worker over a communication channel, using
the worker&apos;s uniqueID is the easiest way to find the worker.

</p>
<pre><code>socket.on(&apos;data&apos;, function (uniqueID) {
  var worker = cluster.workers[uniqueID];
});</code></pre>
<h2>Class: Worker<span><a class="mark" href="#all_class_worker" id="all_class_worker">#</a></span></h2>
<p>A Worker object contains all public information and method about a worker.
In the master it can be obtained using <code>cluster.workers</code>. In a worker
it can be obtained using <code>cluster.worker</code>.

</p>
<h3>worker.uniqueID<span><a class="mark" href="#all_worker_uniqueid" id="all_worker_uniqueid">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">String</span></li>
</div></ul>
<p>Each new worker is given its own unique id, this id is stored in the
<code>uniqueID</code>.

</p>
<p>While a worker is alive, this is the key that indexes it in
cluster.workers

</p>
<h3>worker.process<span><a class="mark" href="#all_worker_process" id="all_worker_process">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">ChildProcess object</span></li>
</div></ul>
<p>All workers are created using <code>child_process.fork()</code>, the returned object
from this function is stored in process.

</p>
<p>See: <a href="child_process.html">Child Process module</a>

</p>
<h3>worker.suicide<span><a class="mark" href="#all_worker_suicide" id="all_worker_suicide">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<p>This property is a boolean. It is set when a worker dies, until then it is
<code>undefined</code>.  It is true if the worker was killed using the <code>.destroy()</code>
method, and false otherwise.

</p>
<h3>worker.send(message, [sendHandle])<span><a class="mark" href="#all_worker_send_message_sendhandle" id="all_worker_send_message_sendhandle">#</a></span></h3>
<div class="signature"><ul>
<li><code>message</code> <span class="type">Object</span></li>
<li><code>sendHandle</code> <span class="type">Handle object</span></li>
</div></ul>
<p>This function is equal to the send methods provided by
<code>child_process.fork()</code>.  In the master you should use this function to
send a message to a specific worker.  However in a worker you can also use
<code>process.send(message)</code>, since this is the same function.

</p>
<p>This example will echo back all messages from the master:

</p>
<pre><code>if (cluster.isMaster) {
  var worker = cluster.fork();
  worker.send(&apos;hi there&apos;);

} else if (cluster.isWorker) {
  process.on(&apos;message&apos;, function (msg) {
    process.send(msg);
  });
}</code></pre>
<h3>worker.destroy()<span><a class="mark" href="#all_worker_destroy" id="all_worker_destroy">#</a></span></h3>
<p>This function will kill the worker, and inform the master to not spawn a
new worker.  To know the difference between suicide and accidentally death
a suicide boolean is set to true.

</p>
<pre><code>cluster.on(&apos;death&apos;, function (worker) {
  if (worker.suicide === true) {
    console.log(&apos;Oh, it was just suicide\&apos; – no need to worry&apos;).
  }
});

// destroy worker
worker.destroy();</code></pre>
<h3>Event: &apos;message&apos;<span><a class="mark" href="#all_event_message" id="all_event_message">#</a></span></h3>
<div class="signature"><ul>
<li><code>message</code> <span class="type">Object</span></li>
</div></ul>
<p>This event is the same as the one provided by <code>child_process.fork()</code>.
In the master you should use this event, however in a worker you can also use
<code>process.on(&apos;message&apos;)</code>

</p>
<p>As an example, here is a cluster that keeps count of the number of requests
in the master process using the message system:

</p>
<pre><code>var cluster = require(&apos;cluster&apos;);
var http = require(&apos;http&apos;);

if (cluster.isMaster) {

  // Keep track of http requests
  var numReqs = 0;
  setInterval(function() {
    console.log(&quot;numReqs =&quot;, numReqs);
  }, 1000);

  // Count requestes
  var messageHandler = function (msg) {
    if (msg.cmd &amp;&amp; msg.cmd == &apos;notifyRequest&apos;) {
      numReqs += 1;
    }
  };

  // Start workers and listen for messages containing notifyRequest
  cluster.autoFork();
  Object.keys(cluster.workers).forEach(function (uniqueID) {
    cluster.workers[uniqueID].on(&apos;message&apos;, messageHandler);
  });

} else {

  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);

    // notify master about the request
    process.send({ cmd: &apos;notifyRequest&apos; });
  }).listen(8000);
}</code></pre>
<h3>Event: &apos;online&apos;<span><a class="mark" href="#all_event_online_1" id="all_event_online_1">#</a></span></h3>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>Same as the <code>cluster.on(&apos;online&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<pre><code>cluster.fork().on(&apos;online&apos;, function (worker) {
  // Worker is online
};</code></pre>
<h3>Event: &apos;listening&apos;<span><a class="mark" href="#all_event_listening_2" id="all_event_listening_2">#</a></span></h3>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>Same as the <code>cluster.on(&apos;listening&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<pre><code>cluster.fork().on(&apos;listening&apos;, function (worker) {
  // Worker is listening
};</code></pre>
<h2>Event: &apos;death&apos;<span><a class="mark" href="#all_event_death_1" id="all_event_death_1">#</a></span></h2>
<div class="signature"><ul>
<li><code>worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>Same as the <code>cluster.on(&apos;death&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<pre><code>cluster.fork().on(&apos;death&apos;, function (worker) {
  // Worker has died
};</code></pre>
<h1>Apéndice 1 - Módulos de terceros<span><a class="mark" href="#all_ap_ndice_1_m_dulos_de_terceros" id="all_ap_ndice_1_m_dulos_de_terceros">#</a></span></h1>
<p>Existen muchos módulos de terceros para Node. En el momento de escribir esto,
Agosto 2010, el repositorio principal de módulos es 
<a href="http://github.com/joyent/node/wiki/modules">esta página del wiki</a>.

</p>
<p>Este apéndice pretente ser una pequeña guía de ayuda a los recién llegados a
que puedan encontrar rápidamente módulos de calidad. No prentede ser una
lista completa. Ya que se puede encontrar mejores módulos y más completos en
donde sea.

</p>
<ul>
<li><p>Module Installer: <a href="http://github.com/isaacs/npm">npm</a></p>
</li>
<li><p>HTTP Middleware: <a href="http://github.com/senchalabs/connect">Connect</a></p>
</li>
<li><p>Web Framework: <a href="http://github.com/visionmedia/express">Express</a></p>
</li>
<li><p>Web Sockets: <a href="https://github.com/learnboost/socket.io">Socket.IO</a></p>
</li>
<li><p>HTML Parsing: <a href="http://github.com/aredridel/html5">HTML5</a></p>
</li>
<li><p><a href="http://github.com/agnat/node_mdns">mDNS/Zeroconf/Bonjour</a></p>
</li>
<li><p><a href="https://github.com/postwait/node-amqp">RabbitMQ, AMQP</a></p>
</li>
<li><p><a href="https://github.com/felixge/node-mysql">mysql</a></p>
</li>
<li><p>Serialization: <a href="https://github.com/pgriess/node-msgpack">msgpack</a></p>
</li>
<li><p>Scraping: <a href="https://github.com/silentrob/Apricot">Apricot</a></p>
</li>
<li><p>Debugger: <a href="https://github.com/smtlaissezfaire/ndb">ndb</a> is a CLI debugger
<a href="https://github.com/dannycoates/node-inspector">inspector</a> is a web based
tool.</p>
</li>
<li><p><a href="https://github.com/mranney/node_pcap">pcap binding</a></p>
</li>
<li><p><a href="https://github.com/mscdex/node-ncurses">ncurses</a></p>
</li>
<li><p>Testing/TDD/BDD: <a href="http://vowsjs.org/">vows</a>,
<a href="https://github.com/visionmedia/mocha">mocha</a>,
<a href="https://github.com/tmpvar/mjsunit.runner">mjsunit.runner</a></p>
</li>
</ul>
<p>Parches a esta lista son bienvenidos.</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <ul class="clearfix">
            <li><a href="/">Node.js</a></li>
            <li><a href="/#download">Download</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="http://search.npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/docs/latest/api/index.html">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright 2010 <a href="http://joyent.com">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.6.10/LICENSE">license</a>.</p>
    </div>

  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>

