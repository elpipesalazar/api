<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>TLS (SSL) Node.js v0.6.18 Manual &amp; Documentación</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/tls.html">
</head>
<body class="alt apidoc" id="api-section-tls">
    <div id="intro" class="interior">
        <a href="http://www.nodejs.es/" title="Go back to the home page">
            <img id="logo" src="images/logo-light-es.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
      <div id="column2" class="interior">
        <div class="official-nodejs-es menu-block">
          <h2>Nodejs.es</h2>
            <ul>
                <li><a href="http://www.nodejs.es/" class="home">Home</a></li>
                <li><a href="http://api.nodejs.es" class="docs current">Docs</a></li>
                <li><a href="http://trabajos.nodejs.es/" class="jobs">Trabajos</a></li>
                <li><a href="https://github.com/nodejs-es/api/" class="download">GitHub</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs_es">@nodejs_es</a></p>
        </div>

        <div class="official-site menu-block">
          <h2>Sitio Oficial</h2>
            <ul>
                <li><a href="http://www.nodejs.org/" class="home">Home</a></li>
                <li><a href="http://www.nodejs.org/#download" class="download">Descargar</a></li>
                <li><a href="http://www.nodejs.org/about/" class="about">Acerca</a></li>
                <li><a href="http://search.npmjs.org/" class="npm">Registo npm</a></li>
                <li><a href="http://nodejs.org/api/" class="docs">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="http://www.nodejs.org/community/" class="community">Comunidad</a></li>
                <li><a href="http://www.nodejs.org/logos/" class="logos">Logos</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Trabajos</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>
      </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.6.18 Manual &amp; Documentación</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Indice</a> |
                <a href="all.html">Ver todo en una misma página</a> |
                <a href="tls.json">Ver como JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Tabla de Contenidos</h2>
            <ul>
<li><a href="#tls_tls_ssl">TLS (SSL)</a><ul>
<li><a href="#tls_s_tls_connect_port_host_options_callback">s = tls.connect(port, [host], [options], callback)</a></li>
<li><a href="#tls_starttls">STARTTLS</a></li>
<li><a href="#tls_tls_server">tls.Server</a><ul>
<li><a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer(options, secureConnectionListener)</a></li>
<li><a href="#tls_event_secureconnection">Event: &apos;secureConnection&apos;</a></li>
<li><a href="#tls_server_listen_port_host_callback">server.listen(port, [host], [callback])</a></li>
<li><a href="#tls_server_close">server.close()</a></li>
<li><a href="#tls_server_maxconnections">server.maxConnections</a></li>
<li><a href="#tls_server_connections">server.connections</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>TLS (SSL)<span><a class="mark" href="#tls_tls_ssl" id="tls_tls_ssl">#</a></span></h1>
<p>Usa <code>require(&apos;tls&apos;)</code> para acceder a este módulo.

</p>
<p>El módulo <code>tls</code> utiliza OpenSSL para proveer seguridad en la Transport Layer Security y/o Secure Socket Layer: encriptacion de flujo de comunicaciones.

</p>
<p>TLS/SSL es una infraestructura de clave publica/privada. Cada cliente y cada servidor deben tener una clave privada. Una clave privada se crea como sigue:

</p>
<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>
<p>Todos los servidores y algunos clientes necesitan tener un certificado. Los certificados son claves públicas firmadas por una autoridad certificadora (CA) o por ellas mismas. El primer paso para obtener un certificado es crear un fichero de &quot;Petición de firma de Certificado&quot; (CSR). Esto se hace como sigue:

</p>
<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p>Para crear un certificado auto firmado con el CSR, hay que hacer:

</p>
<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p>De forma alternativa puedes enviar el CSR a la autoridad certificadora para firmarlo.

</p>
<p>(TODO: documentos sobre la creación de una CA, por ahora los usuarios interesados deberían echar un vistazo a <code>test/fixtures/keys/Makefile</code> en el código fuente de Node)

</p>
<h2>s = tls.connect(port, [host], [options], callback)<span><a class="mark" href="#tls_s_tls_connect_port_host_options_callback" id="tls_s_tls_connect_port_host_options_callback">#</a></span></h2>
<p>Crea una nueva conexión cliente al <code>port</code> y al <code>host</code> dados. (<code>host</code> por defecto es <code>localhost</code>.) <code>options</code> debe ser un objeto que especifique:

</p>
<ul>
<li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la llave privada del servidor en formato PEM. (Requerido)</p>
</li>
<li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene la clave del certificado del servidor en formato PEM.</p>
</li>
<li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs &quot;root&quot; bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p>
</li>
</ul>
<p><code>tls.connect()</code> devuelve un objeto <code>CryptoStream</code> en texto plano.

</p>
<p>Después del TSL/SSL handshake el <code>callback</code> es invocado. El <code>callback</code> será invocado independientemente si el certificado del servidor fue autorizado o no. Es responsabilidad del usuario probar <code>s.authorized</code> para ver si el certificado del servidor estaba firmado por una de las CAs especificadas. Si <code>s.authorized === false</code> entonces el error puede encontrarse en <code>s.authorizationError</code>.


</p>
<h2>STARTTLS<span><a class="mark" href="#tls_starttls" id="tls_starttls">#</a></span></h2>
<p>In the v0.4 branch no function exists for starting a TLS session on an
already existing TCP connection.  This is possible it just requires a bit of
work. The technique is to use <code>tls.createSecurePair()</code> which returns two
streams: an encrypted stream and a plaintext stream. The encrypted stream is then
piped to the socket, the plaintext stream is what the user interacts with thereafter.

</p>
<p><a href="http://gist.github.com/848444">Here is some code that does it.</a>




</p>
<h2>tls.Server<span><a class="mark" href="#tls_tls_server" id="tls_tls_server">#</a></span></h2>
<p>Esta clase es una subclase de <code>net.Server</code> y tiene los mismos métodos.
En lugar de aceptar solo conexiones TCP en bruto, acepta conexiones encriptadas usando TLS o SSL.

</p>
<p>Aquí hay un ejemplo simple de un servidor eco:

</p>
<pre><code>var tls = require(&apos;tls&apos;);
var fs = require(&apos;fs&apos;);

var options = {
  key: fs.readFileSync(&apos;server-key.pem&apos;),
  cert: fs.readFileSync(&apos;server-cert.pem&apos;)
};

tls.createServer(options, function (s) {
  s.write(&quot;welcome!\n&quot;);
  s.pipe(s);
}).listen(8000);</code></pre>
<p>Puedes probar este servidor conectándose a él con <code>openssl s_client</code>:

</p>
<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
<h3>tls.createServer(options, secureConnectionListener)<span><a class="mark" href="#tls_tls_createserver_options_secureconnectionlistener" id="tls_tls_createserver_options_secureconnectionlistener">#</a></span></h3>
<p>Este es un constructor para la clase <code>tls.Server</code>. El objeto options puede contener:

</p>
<ul>
<li><p><code>key</code>: Un string o <code>Buffer</code> que contiene la clave privada del servidor en formato PEM. (Requerido)</p>
</li>
<li><p><code>cert</code>: Un string o <code>Buffer</code> que contiene el certificado del servidor en formato PEM. (Requerido)</p>
</li>
<li><p><code>ca</code>: Un array de strings o <code>Buffer</code>s de certificados de confianza. Si esto es omitido, varias CAs &quot;root&quot; bien conocidas serán usadas, como VeriSign. Estas son usadas para autorizar conexiones.</p>
</li>
<li><p><code>requestCert</code>: Si es <code>true</code> el servidor solicitará un certificado de todos los clientes que se conecten e intenten verificar ese certificado. Por defecto: <code>false</code></p>
</li>
<li><p><code>rejectUnauthorized</code>: Si es <code>true</code> el servidor rechazará cualquier conexión no autorizada por la lista de CAs suministradas. Esta opción solo tiene efecto si <code>requestCert</code> es <code>true</code>. Por defecto: <code>false</code>.</p>
</li>
</ul>
<h3>Event: &apos;secureConnection&apos;<span><a class="mark" href="#tls_event_secureconnection" id="tls_event_secureconnection">#</a></span></h3>
<p><code>function (cleartextStream) {}</code>

</p>
<p>Este evento es emitido después de que una nueva conexión haya realizado con éxito el handshake. El argumento es una instancia de <code>stream.Stream</code>. Tiene todos los métodos y eventos de stream.

</p>
<p><code>cleartextStream.authorized</code> es un valor boolean que indica si el cliente está verificado por una de las CA suministradas por el servidor. Si <code>cleartextStream.authorized</code> es false, entonces <code>cleartextStream.authorizationError</code> describe como falló la autorización. Relacionado pero merece mencionarse: dependiendo de la configuración del servidor TLS, tus autorizaciones de conexión pueden ser aceptadas.

</p>
<h3>server.listen(port, [host], [callback])<span><a class="mark" href="#tls_server_listen_port_host_callback" id="tls_server_listen_port_host_callback">#</a></span></h3>
<p>Empieza aceptando conexiones en el <code>port</code> y el <code>host</code> especificados. Si el <code>host</code> es omitido, el servidor aceptará conexiones dirigidas a cualquier dirección IPv4 (<code>INADDR_ANY</code>).

</p>
<p>Esta función es asíncrona. El último parámetro <code>callback</code> se invocará cuando el servidor esté saturado.

</p>
<p>Mirar <code>net.Server</code> para más información.

</p>
<h3>server.close()<span><a class="mark" href="#tls_server_close" id="tls_server_close">#</a></span></h3>
<p>Detiene el servidor, dejando de aceptar conexiones. Esta función es asíncrona, el servidor finalmente se cierra cuando emite un evento <code>&apos;close&apos;</code>.

</p>
<h3>server.maxConnections<span><a class="mark" href="#tls_server_maxconnections" id="tls_server_maxconnections">#</a></span></h3>
<p>Establece esta propiedad para rechazar conexiones cuando el número de conexiones del servidor sea alta.

</p>
<h3>server.connections<span><a class="mark" href="#tls_server_connections" id="tls_server_connections">#</a></span></h3>
<p>Número de conexiones concurrentes en el servidor.
</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <ul class="clearfix">
            <li><a href="http://www.nodejs.org/">Node.js</a></li>
            <li><a href="http://www.nodejs.es/">Node.js en español</a></li>
            <li><a href="http://twitter.com/nodejs_es" class="twitter">@nodejs_es</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.6.18/LICENSE">license</a>.</p>
    </div>
</body>
</html>

