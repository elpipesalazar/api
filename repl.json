{
  "source": "doc/api/repl-es.markdown",
  "modules": [
    {
      "textRaw": "REPL",
      "name": "repl",
      "desc": "<p>Read-Eval-Print-Loop (REPL) está disponible como un programa independiente y fácilmente\npuede incluirse en otros programas.  REPL proporciona una forma interactiva de ejecutar\nJavaScript y ver los resultados.  Puede ser utilizado para la depuración, pruebas, o\nsimplemente para probar cosas.\n\n</p>\n<p>Debe ejectuarlo en <code>node</code> sin singún argumento desde la línea de comandos, debe posicionarse \ndentro de REPL. Posee la edición simple de líneas de emacs.\n\n</p>\n<pre><code>mjr:~$ node\nType &apos;.help&apos; for options.\n&gt; a = [ 1, 2, 3];\n[ 1, 2, 3 ]\n&gt; a.forEach(function (v) {\n...   console.log(v);\n...   });\n1\n2\n3</code></pre>\n<p>Para editores avanzados, inice node con la variable de entorno <code>NODE_NO_READLINE=1</code>.\nSe iniciará la configuración de REPL en la terminal y l permite utilizarlo con <code>rlwrap</code>.\n\n</p>\n<p>Por ejemplo, puede añadir lo siguiente al fichero bashrc:\n\n</p>\n<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>\n",
      "methods": [
        {
          "textRaw": "repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined])",
          "type": "method",
          "name": "start",
          "desc": "<p>Inicia REPL con el <code>prompt</code> como el prompt y  el <code>stream</code> para todo los procesos de I/O (Entrada/Salida). \n<code>prompt</code> es opcional y por omisión es <code>&gt; </code>.  <code>stream</code> es opcional y por omisión es \n<code>process.stdin</code>. <code>eval</code> is optional too and defaults to async wrapper for\n<code>eval()</code>.\n\n</p>\n<p>If <code>useGlobal</code> is set to true, then the repl will use the global object,\ninstead of running scripts in a separate context. Defaults to <code>false</code>.\n\n</p>\n<p>If <code>ignoreUndefined</code> is set to true, then the repl will not output return value\nof command if it&apos;s <code>undefined</code>. Defaults to <code>false</code>.\n\n</p>\n<p>You can use your own <code>eval</code> function if it has following signature:\n\n</p>\n<pre><code>function eval(cmd, callback) {\n  callback(null, result);\n}</code></pre>\n<p>Multiples REPLs pueden iniciar con una misma instancia de node.  Cada\nuno de ellos comparten el objeto global, pero tendrán un único proceso de I/O.\n\n</p>\n<p>Acontinuación un ejemplo que inicia REPL en stdin, un socket en Unix, y un socket en TCP:\n\n</p>\n<pre><code>var net = require(&quot;net&quot;),\n    repl = require(&quot;repl&quot;);\n\nconnections = 0;\n\nrepl.start(&quot;node via stdin&gt; &quot;);\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start(&quot;node via Unix socket&gt; &quot;, socket);\n}).listen(&quot;/tmp/node-repl-sock&quot;);\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start(&quot;node via TCP socket&gt; &quot;, socket);\n}).listen(5001);</code></pre>\n<p>Ejecutando el programa desde la línea de comando iniciará REPL en stdin.  Otros\nclientes REPL pueden conectarse a través de un socket Unix o TCP. <code>telnet</code> es útil\npara la conexión de sockets TCP, y <code>socat</code> puede ser conectar ambos sockets Unix y\nTCP.\n\n</p>\n<p>Al iniciar REPL desde un socket Unix basado en una instancia de stdin, puede \nconectarse a un  proceso en ejecución de node sin reiniciar el mismo.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prompt",
                  "optional": true
                },
                {
                  "name": "stream",
                  "optional": true
                },
                {
                  "name": "eval",
                  "optional": true
                },
                {
                  "name": "useGlobal",
                  "optional": true
                },
                {
                  "name": "ignoreUndefined",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "miscs": [
        {
          "textRaw": "Características de REPL",
          "name": "Características de REPL",
          "type": "misc",
          "desc": "<p>Dentro de REPL, presione Control+D para salir.  Expresiones de varias líneas pueden ser\ningresadas.\n\n</p>\n<p>La variable especial <code>_</code> (underscore) contiene el resultado de la última expresión.\n\n</p>\n<pre><code>&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\n[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]\n&gt; _.length\n3\n&gt; _ += 1\n4</code></pre>\n<p>REPL proporciona acceso a cualquier variable de ámbito global. Puede exponer \nuna variable a REPL explícitamente y asignarle a un contexto de objeto asociado \ncon cada <code>REPLServer</code>.  Por ejemplo:\n\n</p>\n<pre><code>// repl_test.js\nvar repl = require(&quot;repl&quot;),\n    msg = &quot;message&quot;;\n\nrepl.start().context.m = msg;</code></pre>\n<p>Los sucesos en el objeto <code>context</code> aparecen como local en REPL:\n\n</p>\n<pre><code>mjr:~$ node repl_test.js\n&gt; m\n&apos;message&apos;</code></pre>\n<p>Hay algunos comandos especiales de REPL:\n\n</p>\n<ul>\n<li><code>.break</code> - Si  bien ingresar expresiones en varias líneas, a veces, pueden perderse\no simplemente no son tomados en cuenta. <code>.break</code> comenzará de nuevo.</li>\n<li><code>.clear</code> - Restablece el objeto <code>context</code> a un objeto vacío y borra cualquier\nexpresión de varias líneas.</li>\n<li><code>.exit</code> - Cierra los stream de I/O, que hará que REPL termine.</li>\n<li><code>.help</code> - Muestra la lista de comandos especiales.</li>\n<li><code>.save</code> - Guarda la sesión actual de REPL en un fichero<blockquote>\n<p>.save ./file/to/save.js</p>\n</blockquote>\n</li>\n<li><code>.load</code> - Carga un fichero en la sesión actual de REPL.<blockquote>\n<p>.load ./file/to/load.js  </p>\n</blockquote>\n</li>\n</ul>\n<p>Lo siguiente son combinaciones del teclado para el uso especial de REPL:\n\n</p>\n<ul>\n<li><code>&lt;ctrl&gt;C</code> - Similar a la tecla <code>break</code>. Termina el comando\nactual. Presione dos veces en la línea para forzar la salida.</li>\n<li><code>&lt;ctrl&gt;D</code> - Similar a la tecla <code>.exit</code>.</li>\n</ul>\n"
        }
      ],
      "type": "module",
      "displayName": "REPL"
    }
  ]
}
